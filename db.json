{"site":[{"key":"intro","value":"这是一个在全栈工程师的博客，翻译优质的英文技术类文章，EMQ，ejabberd，Erlang等开源项目的代码分析和优化"},{"key":"utm_medium","value":"website"},{"key":"utm_campaign","value":"Tech Talk"},{"key":"footer","value":"  <div class=\"text-right my-2 mx-4\">\n    <p>Power by \n      <a href=\"https://www.vultr.com/?ref=6833358\" target=\"_blank\" class=\"text-teal-500\">Vultr</a>\n      and\n      <a href=\"https://github.com/DavidAlphaFox/aiwiki\" target=\"_blank\"  class=\"text-teal-500\">AiWiki</a>\n    </p>\n  </div>\n  <div class=\"text-center my-2 mx-4\">\n    Copyright &copy; 2019 \n      <a href=\"https://github.com/DavidAlphaFox\" target=\"_blank\">\n      <span class=\"text-teal-500\">David Fox</span> \n      </a>\n      All Rights Reserved.\n  </div>"},{"key":"utm_source","value":"ttalk.im"},{"key":"brand","value":"Tech Talk 让技术发出声音"},{"key":"keywords","value":"这是一个在全栈工程师的博客,Teach Talk,ttalk,ttalk.im"},{"key":"header","value":"<meta name=\"sogou_site_verification\" content=\"LDr1SVp3uj\"/>                                                                          \n<meta name=\"baidu-site-verification\" content=\"KtrGHEgmbm\" />                                                                         \n<meta name=\"yandex-verification\" content=\"3f3058855112a67e\" />                                                                       \n<meta name=\"msvalidate.01\" content=\"4465C24C5B60CB9646F81B436D4F2EB7\" />                                                             \n<meta name=\"google-site-verification\" content=\"83LaWT9pg7-AF1wlj9aJTtI0lNJ5QeObtqnyO35qg9c\" />                                       \n<!-- Global site tag (gtag.js) - Google Analytics -->                                                                                \n<script async src=\"https://www.googletagmanager.com/gtag/js?id=UA-79214584-5\"></script>                                             \n<script>                                                                                                                            \nwindow.dataLayer = window.dataLayer || [];                                                                                        \nfunction gtag(){dataLayer.push(arguments);}                                                                                       \ngtag('js', new Date());                                                                                                           \ngtag('config', 'UA-79214584-5');                                                                                                  \n</script>                                                                                                                           \n<script data-ad-client=\"ca-pub-7166741407343632\" async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>"},{"key":"host","value":"https://www.ttalk.im"}],"page":[{"content":"<h2>文件系统</h2>\n\n<p>在介绍Linux目录前，我们需要知道什么是文件系统，什么是目录。为了更好的理解Linux目录结构，我们先要了解Linux在文件系统上和我们常用的Windows相比有什么差异。</p>\n\n<h3>什么是文件系统</h3>\n\n<p>文件系统是操作系统用于明确存储设备或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。文件系统由三部分组成：文件系统的接口，对对象操纵和管理的软件集合，对象及属性。从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。</p>\n\n<h3>什么是文件目录</h3>\n\n<p>一个计算机系统中有成千上万个文件，为了便于对文件进行存取和管理，计算机系统建立文件的索引，即文件名和文件物理位置之间的映射关系，这种文件的索引称为文件目录。在我们一般的计算机操作时候，Windows上我们看到的文件夹就是文件目录。</p>\n\n<h3>Windows和Linux文件系统的差异</h3>\n\n<h4>访问路径的差异</h4>\n\n<p>在Windows系统中， 一切东西都是存放在硬盘上的。启动系统后，先确定硬盘，再确定硬盘上的分区以及每个分区所对应文件系统，最后是存放在某个分区特定的文件系统中的文件。 也就是说，Windows是通过 “硬盘上的某个分区-分区上的目录-特定文件” 这样的顺序来访问到一个文件的。</p>\n\n<p>在Linux系统中的一切都是存放在唯一的虚拟文件系统中，这个虚拟文件系统是树状的结构以一个根目录开始。启动系统后，先有这个虚拟文件系统，再识别出各个硬盘， 再把某个硬盘的某个分区挂载到这个虚拟文件系统的某个子树上，再确定分区对应的子目录文件系统，最后的文件就存放在这个特定的文件系统中。 也就是说， Linux 系统是通过 “虚拟文件系统-虚拟文件系统的目录-特定文件” 这样的顺序来访问一个文件的。</p>\n\n<p>从这里面我们可以明确的看出，Windows是直接映射物理设备如实的映射到系统中，而Linux是将物理设备映射到一个已经建立好的结构上。</p>\n\n<h4>设计理念的不同</h4>\n\n<p>在Windows系统中，可以把文件大体分为两种： 系统文件和用户文件 。一般来说系统文件（例如Windows操作系统本身，一些系统程序，程序运行所需的库文件，以及一些系统配置文件等）存放的默认位置在C盘，其它用户文件，包含用户后来安装的程序以及一些数据文件等，用户可以把它们随意存放在任意的分区。</p>\n\n<p>在Linux 系统中，Linux将除了内核之外的东西，无论是键盘，鼠标，数据，程序，CPU，内存，网卡等硬件、软件和数据，还是内存中的东西，我们都可以在虚拟文件系统中的相应子目录对他们进行访问和操作。</p>\n\n<h2>Linux的目录结构</h2>\n\n<p>因为Linux是一个开源可定制的操作系统，Linux的开发者们可以随便重新定义这些目录结构。为了防止发生这种情况，Linux开发者和爱好者们组建了FHS（Filesystem Hierarchy Standard）用来规范化Linux的虚拟目录结构。</p>\n\n<p>简单的可以说，Linux目录结构中，大致可以用，是否可变和是否可以被别的主机共享来概括</p>\n\n<p>|         |可共享的|不可共享的|\r\n| &mdash;&mdash;&ndash; | &mdash;&mdash;&ndash; |&mdash;&mdash;&ndash;| &mdash;&mdash;-|\r\n|不可变的|/usr（一般软件）、/opt（第三方可选文件）等 | /etc（全局配置文件）、/boot（启动文件）等|\r\n|可变的|/var/db（数据库文件）等|/var/run（进程PID）等|</p>\n\n<h3>Linux的目录起点-根目录（/）</h3>\n\n<p>根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的，同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、 静态或动态库等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 </p>\n\n<h3>Linux下比较重要的目录</h3>\n\n<h4>/boot目录</h4>\n\n<p>主要放置开机会使用到的文件，包括Linux核心档案以及开机选单与开机所需配置文件等等。Linux kernel常用的档名为：vmlinuz，如果使用的是GRUB做引导程序，则还会存在/boot/grub/这个目录。</p>\n\n<h4>/bin目录</h4>\n\n<p>/bin是根目录下比较特殊的一个目录。因为/bin放置的是在单人维护模式下还能够被操作的指令。在/bin底下的指令可以被root与一般帐号所使用，主要有：cat，chmod（修改权限），chown，date， mv，mkdir，cp，bash等等常用的指令。所以并不推荐挂载在和/boot目录上不同的硬盘上。</p>\n\n<h4>/sbin目录</h4>\n\n<p>和/bin目录类似，但是更加重要，里面的命令功能也更加强大一些。</p>\n\n<h4>/lib目录</h4>\n\n<p>/lib放置系统开机时可能用到的动态库或者静态库，，以及在/bin下的指令使用到的动态库或者静态库。 </p>\n\n<h4>/etc目录</h4>\n\n<p>系统主要的配置几乎都放置在这个目录内，例如人员的帐号密码文件、各种服务的配置文件等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。</p>\n\n<h4>/root目录</h4>\n\n<p>系统管理员（root）的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。</p>\n\n<h4>/home目录</h4>\n\n<p>这是系统预设的使用者家目录（home directory）。 在你新增一个一般使用者帐号时，预设的使用者家目录都会放到这里来。这里一般都是存放用户的个人文件，root可以读取和写入，非家目录的所有者是根据家目录所有者设置的权限来决定是否能看到里面的内容。一般在Linux交互终端的shell中 “~”代表当前使用者的家目录。</p>\n\n<h3>Linux目录结构为什么是这样的</h3>\n\n<p>Linux目录结构是由Unix目录结构演变而来的。因为Unix的设计者们为了简化设计和提高可操作性提出了一切皆文件的理念，从而有了虚拟文件系统和这个看起来很复杂的目录结构。但是实际上是因为一些历史原因（我会告诉你是磁盘满了吗？）造成的。</p>\n\n<p>请参考阮一峰大神博客Unix目录结构的来历。</p>\n\n<h2>总结</h2>\n\n<p>对于Linux新人来说，Linux的目录结构确实让人混乱，但是它是有规律可寻找的，只要经常使用Linux就会发现里面有很多规律可循。因此我们不要看到Linux中复杂的文件目录结构就被吓到了，从而敬而远之。</p>\n","id":78424632857902727281794757704453263222,"intro":"Linux/Docker","published":false,"published_at":63734916123,"title":"Linux 目录结构","topic_id":1},{"content":"<h2>两大基本概念</h2>\n\n<p>学过计算机编程的读者们都会知道，程序是由算法和数据组成的，近一步说是控制结构和数据体。拿C语言举个例子来说，控制结构有if语句，for语句和case语句等，就是这些控制结构和逻辑判断组成了一个又一个算法。在Erlang这个函数语言中，只要理解递归和模式匹配这两个概念，就完全可以组合出上面的控制结构。本文将重点介绍这两大概念，并用实际例子向读者说明。</p>\n\n<h2>递归</h2>\n\n<p>我们都知道阶乘这个算法，下面先用C实现一遍这个算法：\r\n<code>c\r\nint factorial(int a){\r\n   if(a &gt; 0) {\r\n     return a * factorial( a - 1);\r\n   } else {\r\n     return 1;\r\n   }\r\n} \r\n</code>\r\n 有经验的读者会发现这个例子会导致堆栈溢出，int上溢出等问题，在此我们不深究这些问题。读者可以很容易发现这个是一个递归算法，那么现在就用Erlang来编写下这个例子：\r\n <code>erlang\r\n-module(ex1).\r\n-export([factorial/1]).\r\nfactorial(0) -&gt; 1;\r\nfactorial(A) -&gt; A * factorial(A -1). \r\n</code>\r\n 在Erlang中这种递归一样存在堆栈溢出的问题，读者都知道C语言可以通过使用for循环和一个中间变量来解决堆栈溢出。那么对于变量不可变的Erlang应当怎么做呢？让我们重新修改下上面阶乘这个例子：\r\n<code>erlang\r\n-module(ex2).\r\n-export([factorial/1]).\r\nfactorial(N) -&gt; factorial(N,1).\r\nfactorial(0,Acc) -&gt; Acc;\r\nfactorial(N,Acc) when N &gt; 0 -&gt; factorial(N-1,N*Acc).\r\n</code>\r\n看起来似乎和前面的那个ex1版本没什么区别，但是其中的差异很大。ex2版本的factorial被称为尾递归，Erlang编译器在编译的过程中，会自动将代码转化成循环形式。同时尾递归也是Erlang中用来保持进程存活，进行列表（数组）遍历的重要工具，在后面教程中，会不断深入介绍相关知识。</p>\n\n<h2>模式匹配</h2>\n\n<p>在上面ex1中的例子，可以看到factorial(0)这种写法，这种写法就是Erlang的模式匹配。Erlang会将传入函数的参数和函数的参数列表进行匹配。</p>\n\n<p>就ex1的例子来说，当我们传入参数3，Erlang会按照factorial函数的定义的顺序，从上到下逐条匹配。第一次执行的时候，参数3和factorial(0)并不匹配，直接进入第二条和factorial(A)进行匹配，Erlang会自动的将参数3绑定到A上。并且值得注意的是，Erlang中大写字母开头的变量一旦绑定了在作用范围内就不可以再次绑定。当执行到最后一次的时候，参数已经变成0，直接和factorial(0)匹配，Erlang对于两个常量并不会进行绑定。</p>\n\n<p>为了理解模式匹配，我们需要理解Erlang的变量。</p>\n\n<h2>变量</h2>\n\n<p>Erlang的变量比较特殊，Erlang的变量是不可变的。Erlang的变量一旦绑定了特定的值之后，再作用范围之内就不能再次进行绑定，因此Erlang的变量是被认为不可变的。Erlang中变量的语法非常简单，任何以大写字母开头的单词，大写字母开头后续是字母和数字混合的标识或以下划线开头的标识。例如说，Erlang，JID1，UserA和User1都是合法的变量标识。</p>\n\n<p>我们可以将Erlang的变量想象成一个盒子，这个盒子一开始是空的，但是一旦放入东西后，就不能放入别的东西了，并且当我们取出这个东西的时候，盒子会自动生成一个一模一样的东西。\r\n<img src=\"http://otioh6qxv.bkt.clouddn.com/pattern1.png\" alt=\"\" />\r\n如图所示，绑定变量的时候就相当于我们把东西放入盒子。\r\n<img src=\"http://otioh6qxv.bkt.clouddn.com/pattern2.png\" alt=\"\" />\r\n如图所示，当我们取出变量的时候，我们得到一个东西和一个仍装有东西的盒子。因此，我们依然不能将别的东西继续放入这个盒子了。</p>\n\n<p>Erlang中还有一个比较特殊的变量 “_”，我们可以把它认为是个黑洞，它无需遵循Erlang变量不变的特性，任何放入 “_” 中的值都无法再次取出使用。“_” 虽然在作为变量使用时，虽然没有什么太大的意义，但是当进行模式匹配的时候它就非常有意义了。</p>\n\n<h2>什么是模式匹配</h2>\n\n<p>那么对于“=”这个操作符号就很好理解了，“=”先检查左侧和右侧两个值，如果左侧是一个未绑定的变量，右侧是一个常量，就把常量放入变量这个盒子里面；如果左侧是一个绑定的变量，右侧是一个绑定变量，就都把盒子打开拿出里面的东西进行比较；如果左侧是绑定的变量，右侧是常量，那么就把盒子打开取出东西进行比较。</p>\n\n<p>从这里我们就可以看出，模式匹配就是尝试比较装有东西的盒子里面的东西和外面的东西比较，或者比较两个装有东西的盒子中的两个东西是否一样。</p>\n\n<p>对于上面提到的黑洞‘“_”，在进行模式匹配的时候，它会匹配任何内容，并且在匹配完成后立刻忘记，这么做就可以让我们在写Erlang代码的时候忽略那些我们不行关心的变量。尤其是Erlang的函数有多个参数需要匹配或匹配元组的时候。</p>\n\n<p>读者这时也许会问到，上面ex1的例子中函数并没有使用“=”的地方，那它怎么进行的模式匹配呢？这是因为Erlang编译器默认替我们做了一下，将函数定义的参数和函数调用时候传入的参数进行了下绑定操作。</p>\n","id":329512074290221596090997317937815792507,"intro":"Erlang","published":false,"published_at":63734916123,"title":"Erlang 入门-递归和模式匹配","topic_id":1},{"content":"<h2>我又回来了</h2>\n\n<p>前面的文章中，其中重点介绍了<a href=\"https://www.ttalk.im/topics/55\" >花名册管理</a>和<a href=\"https://www.ttalk.im/topics/58\" >出席订阅</a>。花名册通过在服务器存储，解决了用户好友关系在多个机器上漫游的问题。出席订阅机制重点的解决了如何建立好友关系的过程。<br/>\n本篇将重点介绍下出席通知，那么出席通知主要解决什么问题呢？可能各位读者已经猜测到了，就是好友上线通知。</p>\n\n<h2>出席通知</h2>\n\n<p>XMPP出席通知是典型地遵循一个&ldquo;发布-订阅&rdquo;或&ldquo;观察者&rdquo;模型的通知系统。 这里，一个实体发送出席信息给它的服务器，它的服务器接着广播那个信息给所有订阅了该实体的出席信息的联系人。</p>\n\n<h3>出席探测</h3>\n\n<p>出席探测是一个对某联系人的当前出席信息的请求的操作， 由代表某个用户的服务器代表该用户发送；语法上它是一个<code>type</code>属性值为<code>probe</code>的出席信息节.。在出席信息订阅的上下文中，<code>from</code>地址的值必须是订阅的用户的纯JID（不带资源的JID）而<code>to</code>地址的值必须是被订阅的联系人的纯JID, 因为出席信息订阅是基于纯JID（不带资源的JID）的。 </p>\n\n<p><code>XML\r\n&lt;presence from='juliet@example.com'\r\n              id='ign291v5'\r\n              to='romeo@example.net'\r\n              type='probe'/&gt;\r\n</code>\r\n用户上线后，虽然会立刻接收服务器发来的花名册，但是花名册并不携带用户好友的出席信息，因此需要服务器帮助探测所有的好友出席信息。</p>\n\n<h3>出席通知</h3>\n\n<p>一个客户端，在完成XMPP的<a href=\"https://tools.ietf.org/html/rfc6120\" >RFC6120 Extensible Messaging and Presence Protocol (XMPP): Core </a>中所有规定动作，就需要发送出席通知给服务器，告知服务器客户端已经上线，可以进行常规通讯了。这个出席通知非常简单，是一个没有任何属性的节。\r\n<code>XML\r\n&lt;presence/&gt;\r\n</code>\r\n虽然该节不包含任何属性，但是该节可以包含<priority/>元素, <show/>元素, 一个一个或多个<status/>元素实例。<br/>\n这个出席通知虽然很简单，但是会在服务器上触发一系列动作。</p>\n\n<h3>ejabberd如何实现</h3>\n\n<p>ejabberd在实现XMPP中<code>presence</code>的部分非常完善，在关于代表客户端操作的方法都集中在<code>ejabberd_c2s</code>中。如前面文章所说的，出席订阅部分集中在<code>presence_track</code>这部分，而关于出席通知这部分，重点集中在 <code>presence_update</code>部分。</p>\n\n<p>下面是比较重要的代码</p>\n\n<pre><code><span class=\"code\"><span class=\"comment\">%% 更新出席信息\r\n</span><span class=\"comment\">%% @doc User updates his presence (non-directed presence packet)\r\n</span><span class=\"attribute\">-spec</span> presence_update<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Acc</span> :: mongoose_acc:t<span class=\"paren2\">(<span class=\"code\"></span>)</span>,\r\n                      <span class=\"variable\">From</span> :: <span class=\"atom\">'undefined'</span> | ejabberd:jid<span class=\"paren2\">(<span class=\"code\"></span>)</span>,\r\n                      <span class=\"variable\">State</span> :: state<span class=\"paren2\">(<span class=\"code\"></span>)</span></span>)</span> -&gt; <span class=\"paren1\">{<span class=\"code\">mongoose_acc:t<span class=\"paren2\">(<span class=\"code\"></span>)</span>, state<span class=\"paren2\">(<span class=\"code\"></span>)</span></span>}</span>.\r\n<span class=\"function\">presence_update</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Acc</span>, <span class=\"variable\">From</span>, <span class=\"variable\">StateData</span></span>)</span> -&gt;\r\n    <span class=\"variable\">Packet</span> = mongoose_acc:get<span class=\"paren1\">(<span class=\"code\"><span class=\"symbol\">element</span>, <span class=\"variable\">Acc</span></span>)</span>,\r\n    <span class=\"symbol\">case</span> mongoose_acc:get<span class=\"paren1\">(<span class=\"code\">type, <span class=\"variable\">Acc</span></span>)</span> <span class=\"symbol\">of</span>\r\n        &lt;&lt;<span class=\"string\">\"unavailable\"</span>&gt;&gt; -&gt;\r\n            <span class=\"variable\">Status</span> = <span class=\"symbol\">case</span> xml:get_subtag<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Packet</span>, &lt;&lt;<span class=\"string\">\"status\"</span>&gt;&gt;</span>)</span> <span class=\"symbol\">of</span>\r\n                         false -&gt;\r\n                             &lt;&lt;&gt;&gt;;\r\n                         <span class=\"variable\">StatusTag</span> -&gt;\r\n                             xml:get_tag_cdata<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">StatusTag</span></span>)</span>\r\n                     <span class=\"symbol\">end</span>,\r\n            <span class=\"variable\">Info</span> = <span class=\"paren1\">[<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">ip, <span class=\"variable\">StateData#state</span>.ip</span>}</span>, <span class=\"paren2\">{<span class=\"code\">conn, <span class=\"variable\">StateData#state</span>.conn</span>}</span>,\r\n                    <span class=\"paren2\">{<span class=\"code\">auth_module, <span class=\"variable\">StateData#state</span>.auth_module</span>}</span></span>]</span>,\r\n            <span class=\"variable\">Acc1</span> = ejabberd_sm:unset_presence<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Acc</span>,\r\n                                              <span class=\"variable\">StateData#state</span>.sid,\r\n                                              <span class=\"variable\">StateData#state</span>.user,\r\n                                              <span class=\"variable\">StateData#state</span>.server,\r\n                                              <span class=\"variable\">StateData#state</span>.resource,\r\n                                              <span class=\"variable\">Status</span>,\r\n                                              <span class=\"variable\">Info</span></span>)</span>,\r\n            <span class=\"variable\">Acc2</span> = presence_broadcast<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Acc1</span>, <span class=\"variable\">StateData#state</span>.pres_a, <span class=\"variable\">StateData</span></span>)</span>,\r\n            <span class=\"variable\">Acc3</span> = presence_broadcast<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Acc2</span>, <span class=\"variable\">StateData#state</span>.pres_i, <span class=\"variable\">StateData</span></span>)</span>,\r\n            <span class=\"comment\">% and here we reach the end\r\n</span>            <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Acc3</span>, <span class=\"variable\">StateData#state</span><span class=\"paren2\">{<span class=\"code\">pres_last = undefined,\r\n                                   pres_timestamp = undefined,\r\n                                   pres_a = gb_sets:new<span class=\"paren3\">(<span class=\"code\"></span>)</span>,\r\n                                   pres_i = gb_sets:new<span class=\"paren3\">(<span class=\"code\"></span>)</span>,\r\n                                   pres_invis = false</span>}</span></span>}</span>;\r\n        &lt;&lt;<span class=\"string\">\"invisible\"</span>&gt;&gt; -&gt;\r\n            <span class=\"variable\">NewPriority</span> = get_priority_from_presence<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Packet</span></span>)</span>,\r\n            <span class=\"variable\">Acc0</span> = update_priority<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Acc</span>, <span class=\"variable\">NewPriority</span>, <span class=\"variable\">Packet</span>, <span class=\"variable\">StateData</span></span>)</span>,\r\n            <span class=\"symbol\">case</span> <span class=\"variable\">StateData#state</span>.pres_invis <span class=\"symbol\">of</span>\r\n                false -&gt;\r\n                    <span class=\"variable\">Acc1</span> = presence_broadcast<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Acc0</span>,\r\n                                              <span class=\"variable\">StateData#state</span>.pres_a,\r\n                                              <span class=\"variable\">StateData</span></span>)</span>,\r\n                    <span class=\"variable\">Acc2</span> = presence_broadcast<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Acc1</span>,\r\n                                              <span class=\"variable\">StateData#state</span>.pres_i,\r\n                                              <span class=\"variable\">StateData</span></span>)</span>,\r\n                    <span class=\"variable\">S1</span> = <span class=\"variable\">StateData#state</span><span class=\"paren1\">{<span class=\"code\">pres_last = undefined,\r\n                                         pres_timestamp = undefined,\r\n                                         pres_a = gb_sets:new<span class=\"paren2\">(<span class=\"code\"></span>)</span>,\r\n                                         pres_i = gb_sets:new<span class=\"paren2\">(<span class=\"code\"></span>)</span>,\r\n                                         pres_invis = true</span>}</span>,\r\n                    presence_broadcast_first<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Acc2</span>, <span class=\"variable\">From</span>, <span class=\"variable\">S1</span>, <span class=\"variable\">Packet</span></span>)</span>;\r\n                true -&gt;\r\n                    <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Acc0</span>, <span class=\"variable\">StateData</span></span>}</span>\r\n            <span class=\"symbol\">end</span>;\r\n        &lt;&lt;<span class=\"string\">\"error\"</span>&gt;&gt; -&gt;\r\n            <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Acc</span>, <span class=\"variable\">StateData</span></span>}</span>;\r\n        &lt;&lt;<span class=\"string\">\"probe\"</span>&gt;&gt; -&gt;\r\n            <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Acc</span>, <span class=\"variable\">StateData</span></span>}</span>;\r\n        &lt;&lt;<span class=\"string\">\"subscribe\"</span>&gt;&gt; -&gt;\r\n            <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Acc</span>, <span class=\"variable\">StateData</span></span>}</span>;\r\n        &lt;&lt;<span class=\"string\">\"subscribed\"</span>&gt;&gt; -&gt;\r\n            <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Acc</span>, <span class=\"variable\">StateData</span></span>}</span>;\r\n        &lt;&lt;<span class=\"string\">\"unsubscribe\"</span>&gt;&gt; -&gt;\r\n            <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Acc</span>, <span class=\"variable\">StateData</span></span>}</span>;\r\n        &lt;&lt;<span class=\"string\">\"unsubscribed\"</span>&gt;&gt; -&gt;\r\n            <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Acc</span>, <span class=\"variable\">StateData</span></span>}</span>;\r\n        <span class=\"variable\">_</span> -&gt;\r\n            presence_update_to_available<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Acc</span>, <span class=\"variable\">From</span>, <span class=\"variable\">Packet</span>, <span class=\"variable\">StateData</span></span>)</span>\r\n    <span class=\"symbol\">end</span>.\r\n\r\n<span class=\"function\">presence_update_to_available</span><span class=\"paren1\">(<span class=\"code\">true, <span class=\"variable\">Acc</span>, <span class=\"variable\">_</span>, <span class=\"variable\">NewPriority</span>, <span class=\"variable\">From</span>, <span class=\"variable\">Packet</span>, <span class=\"variable\">StateData</span></span>)</span> -&gt;\r\n    <span class=\"variable\">Acc2</span> = ejabberd_hooks:run_fold<span class=\"paren1\">(<span class=\"code\">user_available_hook,\r\n                                   <span class=\"variable\">StateData#state</span>.server,\r\n                                   <span class=\"variable\">Acc</span>,\r\n                                   <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">StateData#state</span>.jid</span>]</span></span>)</span>,\r\n    <span class=\"variable\">Res</span> = <span class=\"symbol\">case</span> <span class=\"variable\">NewPriority</span> &gt;= 0 <span class=\"symbol\">of</span>\r\n              true -&gt;\r\n                  <span class=\"variable\">Acc3</span> = ejabberd_hooks:run_fold<span class=\"paren1\">(<span class=\"code\">roster_get_subscription_lists,\r\n                                                 <span class=\"variable\">StateData#state</span>.server,\r\n                                                 <span class=\"variable\">Acc2</span>,\r\n                                                 <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">StateData#state</span>.user,\r\n                                                 <span class=\"variable\">StateData#state</span>.server</span>]</span></span>)</span>,\r\n                  <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">_</span>, <span class=\"variable\">_</span>, <span class=\"variable\">Pending</span></span>}</span> = mongoose_acc:get<span class=\"paren1\">(<span class=\"code\">subscription_lists, <span class=\"variable\">Acc3</span>, <span class=\"paren2\">{<span class=\"code\"><span class=\"paren3\">[<span class=\"code\"></span>]</span>, <span class=\"paren3\">[<span class=\"code\"></span>]</span>, <span class=\"paren3\">[<span class=\"code\"></span>]</span></span>}</span></span>)</span>,\r\n                  <span class=\"variable\">Acc4</span> = resend_offline_messages<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Acc3</span>, <span class=\"variable\">StateData</span></span>)</span>,\r\n                  resend_subscription_requests<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Acc4</span>,\r\n                                               <span class=\"variable\">StateData#state</span><span class=\"paren2\">{<span class=\"code\">pending_invitations = <span class=\"variable\">Pending</span></span>}</span></span>)</span>;\r\n              false -&gt;\r\n                  <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Acc2</span>, <span class=\"variable\">StateData</span></span>}</span>\r\n              <span class=\"symbol\">end</span>,\r\n    <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Accum</span>, <span class=\"variable\">NewStateData1</span></span>}</span> = <span class=\"variable\">Res</span>,\r\n    <span class=\"comment\">%% 得到订阅者的信息，全局广播\r\n</span>    presence_broadcast_first<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Accum</span>, <span class=\"variable\">From</span>, <span class=\"variable\">NewStateData1</span>, <span class=\"variable\">Packet</span></span>)</span>;</span></code></pre>\n\n<p>其中，ejabberd会根据<code>type</code>进行判断，该进行哪些操作，接着<code>presence_update_to_available</code>会在客户端首次上线和从离线状态变为上线状态的时候进行出席通知。正如前面所描述的XMPP出席通知是典型地遵循一个&ldquo;发布-订阅&rdquo;或&ldquo;观察者&rdquo;模型的通知系统，因此出席通知会通知所有在出席订阅过程中订阅的用户也就是用户的好友。</p>\n\n<p>另一方面，eJabberd借助了Erlang的特性，会在客户端断开连接后通知用户的好友用户离线了。\r\n``` Erlang\r\n-spec terminate(Reason :: any(), statename(), state()) &rarr; ok.\r\nterminate(_Reason, StateName, StateData) &rarr;\r\n    case {should_close_session(StateName), StateData#state.authenticated} of\r\n        {false, <em>} &rarr;\r\n            ok;\r\n        %% if we are in an state wich have a session established\r\n        {</em>, replaced} &rarr;\r\n            ?INFO_MSG(&ldquo;(~w) Replaced session for ~s&rdquo;,\r\n                      [StateData#state.socket,\r\n                       jid:to_binary(StateData#state.jid)]),\r\n            From = StateData#state.jid,\r\n            StatusEl = #xmlel{name = &lt;&lt;&ldquo;status&rdquo;&gt;&gt;,\r\n                              children = [#xmlcdata{content = &lt;&lt;&ldquo;Replaced by new connection&rdquo;&gt;&gt;}]},\r\n            Packet = #xmlel{name = &lt;&lt;&ldquo;presence&rdquo;&gt;&gt;,\r\n                            attrs = [{&lt;&lt;&ldquo;type&rdquo;&gt;&gt;, &lt;&lt;&ldquo;unavailable&rdquo;&gt;&gt;}],\r\n                            children = [StatusEl]},\r\n            Acc0 = mongoose_acc:from_element(Packet),\r\n            Acc = mongoose_acc:put(from_jid, From, Acc0),\r\n            ejabberd_sm:close_session_unset_presence(\r\n              StateData#state.sid,\r\n              StateData#state.user,\r\n              StateData#state.server,\r\n              StateData#state.resource,\r\n              &lt;&lt;&ldquo;Replaced by new connection&rdquo;&gt;&gt;,\r\n              replaced),\r\n            Acc1 = presence_broadcast(Acc, StateData#state.pres_a, StateData),\r\n            presence_broadcast(Acc1, StateData#state.pres_i, StateData),\r\n            reroute_unacked_messages(StateData);\r\n        {_, resumed} &rarr;\r\n            ?INFO_MSG(&ldquo;(~w) Stream ~p resumed for ~s&rdquo;,\r\n                      [StateData#state.socket,\r\n                       StateData#state.stream_mgmt_id,\r\n                       jid:to_binary(StateData#state.jid)]);\r\n        _ &rarr;\r\n            ?INFO_MSG(&ldquo;(~w) Close session for ~s&rdquo;,\r\n                      [StateData#state.socket,\r\n                       jid:to_binary(StateData#state.jid)]),</p>\n\n<pre><code>        EmptySet = gb_sets:new(),\r\n        case StateData of\r\n            #state{pres_last = undefined,\r\n                   pres_a = EmptySet,\r\n                   pres_i = EmptySet,\r\n                   pres_invis = false} -&gt;\r\n                ejabberd_sm:close_session(StateData#state.sid,\r\n                                          StateData#state.user,\r\n                                          StateData#state.server,\r\n                                          StateData#state.resource,\r\n                                          normal);\r\n            _ -&gt;\r\n                From = StateData#state.jid,\r\n                Packet = #xmlel{name = &lt;&lt;&quot;presence&quot;&gt;&gt;,\r\n                                attrs = [{&lt;&lt;&quot;type&quot;&gt;&gt;, &lt;&lt;&quot;unavailable&quot;&gt;&gt;}]},\r\n                Acc0 = mongoose_acc:from_element(Packet),\r\n                Acc = mongoose_acc:put(from_jid, From, Acc0),\r\n                ejabberd_sm:close_session_unset_presence(\r\n                  StateData#state.sid,\r\n                  StateData#state.user,\r\n                  StateData#state.server,\r\n                  StateData#state.resource,\r\n                  &lt;&lt;&quot;&quot;&gt;&gt;,\r\n                  normal),\r\n                Acc1 = presence_broadcast(Acc, StateData#state.pres_a, StateData),\r\n                presence_broadcast(Acc1, StateData#state.pres_i, StateData)\r\n        end,\r\n        reroute_unacked_messages(StateData)\r\nend,\r\n(StateData#state.sockmod):close(StateData#state.socket),\r\nok.\r\n</code></pre>\n\n<p>```</p>\n\n<p>不管是上线，还是离线，从代码中都可以看到这里面的两个函数<code>presence_broadcast</code>和<code>presence_broadcast_first</code>的命名上都含有broadcast，也就是说这两个函数会进行广播操作。</p>\n\n<h2>必须知道的问题</h2>\n\n<p>XMPP的花名册和出席机制是非常完美的，就是因为它很完美，这就给实际生产使用带来了一些弊端。      </p>\n\n<h3>花名册</h3>\n\n<p>XMPP的花名册现在已经通过版本机制来避免每次全量同步花名册的操作，所以在客户端开发的时候，一定要注意相关功能是否被启用。否则会被移动用户抱怨飞速的消耗流量。</p>\n\n<h3>出席通知</h3>\n\n<ol>\n<li>在客户端首次上线的时候，会通过<code>presence_broadcast_first</code>来进行广播，从<code>presence_broadcast_first</code> 的代码中可以看到，服务器会给我们所有的订阅用户发送出席探测的消息，同时给所有订阅用户发送用户出席的信息，如果一个用户有超级多的好友的情况下，用户的<code>ejabberd_c2s</code>进程会长时间无法处理别的信息。</li>\n<li>异常离线的时候，也会给所有用户的好友发送离线出席信息的广播，所以在网络环境不好的情况，对用户的好友的流量会产生极大的负担，同时会加重服务器的负担。</li>\n<li>考虑到XMPP的分布式特性，XMPP服务器本身并不集中保存用户的出席状态，而是通过出席探测的方式进行逐个探测，这个虽然很准确。但是会给用户用户和好友造成大量的流量负担。</li>\n</ol>\n\n<h3>如何解决</h3>\n\n<p>对于流量负担，是在所难免的，但是可以通过自己定制出席通知的方式，建立出席信息集中存储来降低用户流量的负担。</p>\n\n<h2>总结</h2>\n\n<p>至此，已经带各位读者了解了部分ejabberd中是如何实现花名册和出席相关的知识，省下的部分就需要读者们进一步深入到源代码和RFC相关规范中，带着需求去阅读源代码，从而从根本上解决自己业务上的需求。</p>\n","id":190333738792184659643134739929469497256,"intro":"XMPP","published":false,"published_at":63734916126,"title":"eJabberd 的花名册和出席 (3)","topic_id":1},{"content":"<p>原文地址： <a href=\"https://nukemanbill.blogspot.com/2008/06/how-to-sell-your-software-for-20000.html?utm_source=wanqu.co&utm_campaign=Wanqu%20Daily&utm_medium=website&utm_source=ttalk.im&utm_medium=website&utm_campaign=Tech%2520Talk\">How to sell your software for $20,000 </a></p>\n\n<p>我猜你可以经你的软件以一年20美元卖给10000人或者也可以一年2万美元将它卖给购买10个席位的商业公司。并且这这两种方式都是非常好的商业模式。虽然我不知道那个方式更容易，但是我选择了后者。当只有我一个人的时候，我只需要每年获取一个用户，我认为这是一种非常好的生活方式。</p>\n\n<p>下面我将分享我的想法，如果你对此感兴趣，请继续阅读下去。</p>\n\n<h2>找到一个可以卖到2万美元的软件</h2>\n\n<p>这个想法是，我们不要尝试提出新的东西，因为每一个用户的痛点都已经被分析的很透彻了，如果当前还没有这样的产品，那么很大概率这个产品没有存在的必要性。</p>\n\n<p>同样，对于“新”产品，我们就必须游说企业或组织，他们为什么需要“新”产品，这需要花费营销资金和额外的时间来让企业或组织接受这些新观念和新产品。这就是为什么我们需要选择一个现有产品的更好版本，因为客户已经知道这种产品的存在，并且他们也清楚他们需要这个产品，这样会更加容易起步和花费更少的启动资金。</p>\n\n<p>而且他们可能已经在使用竞争对手产品，但是这并不重要，因为当他们决定进行“技术更新”或以其他方式更新到更新和更好的产品时或者当他们无法忍受现有的软件供应商，寻找更好的技术支持和更优秀的产品的时候，这就是我们的机会。</p>\n\n<p>我并不知道何处可以知道售价为2万美元的软件。我的产品构想，完全是因为我碰巧在工作中使用2万美元（实际上更像5万美元）软件，并且我也发现他们确实付出了更高的价格。我认为我可以做的更好，所以我就开始了这项业务。</p>\n\n<p>当我在大型科技或者软件承包商时，我就知道我们的某些产品可以卖到每份1万美元或者2万美元，同时我在聊天室中也看到别人提到过每份软件可以卖到2万或者3万美元，所以它绝对值这个价钱。但是，我认为2万美元的软件不会在网络上标价，因为它通常以定制报价的“解决方案”出售。 因此，我们无法简单的在网上搜索就能找到。</p>\n\n<p>我认为，找到一个20,000美元的B2B产品，最好方法是不仅仅着眼于“企业真正需要哪种软件？” 而是“什么样的企业依靠技术来经营业务？” 这项技术的背后可能是一台计算机，我们可以为此编写更好的软件。 如果其余技术是现成的专用外设，我饿吗也可以轻松提供这些外设并将其作为“整体解决方案”出售。 这就是我公司所做的。</p>\n\n<p>让我来举一个B2B产品的例子：自动停车计费软件。从我上次不得不在本地机场的停车场支付100美元的时候，我就在思考它。 停车场当然需要技术手段进行运营。当我们按下停车按钮，它会打印出带有时间的停车票，并为车牌拍照。5天后，当我们离开停车场的时候，我们需要将停车票交给收银员或者放入自动读卡机中。 他们将从扫描停车票，根据时间计算出费用，并可能保留各种统计信息以做出各种报告。这种软件并不复杂对吧？ 但是他们每天都要使用它，并依靠它来运行运营。 我敢打赌那些系统的软件部分很容易以2万美元，5万美元或10万美元的价格出售。 想想他们所收的费用。。。如果软件能为每辆车节省10秒钟，那么如果一天有5000辆汽车，那么10万美元对他们来说就不是一个很昂贵的价格。</p>\n\n<p>“整体解决方案”将涉及什么？除了售票亭中的“终端”（标准PC，也许带有触摸屏？）以及总公司中的一些中央计算机，我们还需要使用网络，自动抬杆器，票务打印机，按按钮打印停车票的服务亭，自动拍摄车牌的某种照相机&hellip;网络交换机&hellip;还有什么？我不知道，但我们可能可以从制造它们的任何人那里“立即购买”的所有东西。因此，我们只需将所有功能集成在一起，然后用我们的软件进行整合，并打印出精美的报告，在停车场无空位或者某些事情发生时提示老板。我们可以将其作为整体解决方案来出售，比如说20万美元，其中5万美元是硬件成本，其余的都是从软件中获得的“利润”。我不知道它是否能卖出去，但是如果我正在寻找新的想法，我会对该行业进行研究。</p>\n\n<p>因此我的产品想法是来自对那些依赖技术的企业或业务进行研究，而不仅仅是考虑他们需要什么软件。除了在办公室PC或Web浏览器上运行的东西之外，还有更多的东西，所以我建议不要用“我应该制造什么软件？”来限制自己。</p>\n\n<h2>选则一个大企业的产品</h2>\n\n<p>如果主要提供商是价值数百万美元的公司，那么该产品可能是这个公司的主打产品或者是非常重要的产品。这就意味着，这个市场是可行的且非常大。 例如，我们只需要获得1亿美元市场的1％或5000万美元市场的2％的年收入即可。</p>\n\n<p>同样，那些价值数百万美元的公司将花费大量资金说服任何新客户，为什么客户需要他们的产品（同时也为我们的产品扩大销路），这意味着我们不必去做这件事情了。 我们的竞争对手将花费所有的时间和精力说服客户购买，然后客户将从每个人那里获得报价，最终可能最终购买了我们的报价，而我们却没有花费任何营销成本。如果我们没有足够的费用，我们不妨借竞争对手的东风，进行销售。</p>\n\n<h2>构建一个最简产品</h2>\n\n<p>最初，我们只需要制作一个“精简版”版本，我们就可以以更低的价格获得一些客户。这个想法是要获得最初的客户，并用这笔钱持续开发它，持续构建复杂且介个略高的“精简版”，直到这个产品和市场上现有的产品相似或者能更好。</p>\n\n<p>“精简”版本可能对部分客户很有用，因为市场上当前的软件都经历过风风雨雨，里面很多功能已经破败不堪。这就是软件随时间推移都会发生的情况。他们的核心产品在首次进入市场开始销售时起，就需要像竞争对手一样对其进行升级并添加新的东西，两者都试图使某件东西变得独一无二。但是，对客户而言，很多时候他们只需要核心功能，所以我们只需要了解一些基础知识就好了。</p>\n\n<p>我们的策略将是仅制造这些核心功能，并降低价格。客户并不总是根据价格决定购买，而是根据价值来决定购买。也许他们可以以5000美元的价格购买具有某些主要功能的软件，或者以20000美元的价格购买具有远超5000美元价格功能，成熟，市场领先，经过验证的软件，但是他们依然只使用那5000美元核心功能。</p>\n\n<p>对于客户而言，这可能不是一个容易的决定，有些选择20000美元的产品，有些会选择5000美元的产品。但是重要的是有时客户会选择我们，尤其是对于可能在使用现有产品或公司方面曾经有过糟糕的体验，或者正在寻找与他们竞争对手所用产品不同的市场领域。记住，我们只需要一个1亿美元市场的1％，而无需完全占有。</p>\n\n<p>自然，我们需要弄清楚需要构建的基本核心功能是什么。这需要某个领域知识。在我的领域内，我已经知道核心功能是什么，但是也许进入另一个领域也是一件好事，因为我们可能会以不同的方式处理事情并提出新的想法。</p>\n\n<p>我知道如果我决定制造自动停车计费系统，我至少想在一些停车场里闲逛，然后和工作人员闲聊几天。不是要弄清楚他们做错了什么以及我的软件如何解决它，而是要学习他们的工作，了解他们当前的系统做什么，并弄清他们喜欢什么，不喜欢当前系统的部分。</p>\n\n<p>现在，当然可以很容易地说“仅具有核心功能的产品精简版”，但是如果有很多核心功能，那么什么才是最需要的功能？ 我花了差不多十年的时间（兼职/晚上和周末）来制作我的“精简版”版本。 也许这是一个极端的情况，但是如果它是2万美元的软件，我怀疑其中的核心功能是否会在六个月或一年内被同时使用，因为很多人已经做了。 不是吗？ 也许不是，我也不确定， 我花了很长时间。 我预计至少要花几年时间，这也有助于避免潜在的未来竞争（设置竞争壁垒）。</p>\n\n<p>我认为有太多人想雇佣一堆天才，然后在一个月之内迅速致富。 我要说的是，在别人浪费时间制作一堆共享软件的时候，我们去构建一个真正的产品。</p>\n\n<h2>在业界创出名声</h2>\n\n<p>价值2万美元的软件肯定是一个“小众”软件，不会有太多购买它的客户。也许是几十个或几百个，但肯定不是几万个。因此，客户很可能都聚集在某个主要行业会议上，或者都订阅了他们的主要行业贸易杂志，或者可以从他们的行业贸易协会或他们的贸易杂志出版商那里购买全部列表，如果可能，就打电话给每个直接可能的客户。</p>\n\n<p>在此阶段，我们只需要让客户知道自己的公司名称，这样每个人都知道我们在出售系统，并且可以替代现有系统。我们不必将系统出售给他们，只需说出我们的名字即可。我们可以通过电子邮件，邮件或电话打给所有潜在客户，打个招呼，介绍自己和公司。他们处在小众市场，可能不会接到很多销售电话，因此与一般的推销电话不一样，实际上，他们可能很高兴听到他们的业务中有新的供应商。但是，请在此处进行常规营销，这超出了这个帖子的主题，例如，我们还可以在他们的展会上获得一个摊位，在他们的杂志上刊登广告，在他们的行业杂志和网站上发布您的新闻稿等。</p>\n\n<p>只透露我们的名字而不是立刻销售的这一想法是当他们中的一个正在寻求升级时，或者他们讨厌当前的系统并想尝试其他东西时，他们知道我们后会向我们发出邀约，要我们提供方案，报价或提供演示系统。 那时，就是我们进行销售的时间。 现在，只要确保每个人都知道我们的存在，就可以收到报价和投标的请求。\n（显然，一旦准备好出售，就必须完成产品，建立基本业务，准备发送小册子等，这里每一项都是复杂的主题，这里仅仅是说明下。）</p>\n\n<h2>即便和大公司进行也没关系，假装自己是一位咨询顾问</h2>\n\n<p>即使竞争对手有很多大公司案例来背书，我们也无需如此。我们只需要考虑：</p>\n\n<ul>\n<li>任何经常使用的软件都会有一部分人讨厌它</li>\n<li>任何“拥有”或拥有很大市场份额的公司都会有讨厌他们的人</li>\n</ul>\n\n<p>在某些市场中，商业客户可能不希望使用竞争对手使用的相同产品，而是愿意尝试使用新的或未经验证的系统，以期获得优势（更高的生产率，更低的间接费用等）。 未经验证的产品可能会失败，但是有些人愿意尝试。\n因此，即使我们的产品尚不完整和我们的销售向一个单人秀，但是仍会有一些全新的市场像我们敞开或者至少部分客户会考虑我们。</p>\n\n<p>好了，我们如何销售我们的软件？\n首先，降低的价格涵盖了我们是“精简版”版本这一的事实。 我们将以5000美元或10000美元的价格出售精简版，或低于竞争对手的价格，以说明它是基本产品。 同时，尽管我们要按其价值出售它们，但要说服我们的客户，客户不需要像其他产品那样的花哨的东西，那么为什么要为它们买单呢？ 销售技巧已经超出了这篇文章的范围，但是我们可以使用功能的价值和所付的价格对比这种标准的销售话术来说服客户。</p>\n\n<p>更大的问题是公司就只有我们自己。 客户会直接问我们，并且我们最好提前解决，客户希望我们为他们提供有100人的竞争对手所能提供的相同品质的服务。\n并且对于客户来说这是他们最核心的技术或产品，所以他们最关心的问题会是，如果我们被公共汽车撞到或者失踪，他们将如何应对。</p>\n\n<p>这是我如何解决有关一人公司的常见问题：</p>\n\n<h3>我们如何提供相同水平的支持和服务？</h3>\n\n<p>我们告诉客户，我们的业务方法不同-我们的业务是“软件咨询公司”，并且一次只销售给一家公司。 这样，我们就可以专注于他们及其确切的需求。 当然是真的！ 如果他们为我们的“整体解决方案”系统支付了15万美元，那么每周检查一次，每月飞到他们的站点，真正握住他们的手，免费提供要求的新功能，真正获得他们的反馈应该没问题 一年下来。 他们会喜欢它，并成为我们的下一个客户的推荐人。</p>\n\n<p>询问他们是否正在从当前的提供商那里获取相同的服务。。。可能并不是。还要指出，他们将是我们的主要客户和非常大的项目。 在大型竞争对手中，他们只是众多客户之一。 他们也会喜欢这个主意。至于被公共汽车撞到，我们的竞争对手明天也可能破产。 天知道？ 但是请向他们保证我们已为责任和性能（“错误和遗漏保险”）充分投保，并指出一旦安装并运行软件，它就不会更改。 软件不会耗尽，它将永远以相同的方式运行。 而且，只有在安装，运行并接受它之后，他们才需要付款，因此，如果我们被公交车撞到或者我们的公司离开了，他们仍然会拥有它并且它将继续工作。</p>\n\n<h3>客户如何知道我们的产品有效？ 我们尚未将其出售给任何人。</h3>\n\n<p>我们只需如实的说，这是一个新产品，坏的一面也许它并不稳定，但是好的事情是，客户可以获得最新最好的技术。 然后，我们再次重申他们在安装并证明运行之前不付款，他们会接受它，因此确实没有风险。 如果它不能像广告中所说的那样工作，他们将不付款。 而且我们有足够的信心，并且我们愿意在他们接受之前，花费时间和金钱进行所有安装，培训和功能演示，因为他们会帮助我们完成测试。</p>\n\n<p>我们还应该指出，肯定会有事情发生，但这也是为什么我们将公司作为“软件咨询公司”来运营。 我们将随时待命，并致力于他们以及他们如何使用该产品。 如果有重大问题，我们可以乘坐下一架飞机，将其放在笔记本电脑上，然后就可以在那里进行更改。 大型竞争对手现在为他们这样做吗？ 很有可能不会。</p>\n\n<p>看到了吗？ 一个人的公司实际上是一件好事！</p>\n\n<p>好吧，无论如何，我的第一批客户对上述情况的反应都非常好。而且我一点也不欺骗，我真的是亲手握住了它们，并献身于它们，因为毕竟我的第一个客户是我唯一的客户！</p>\n\n<p>因此，这是我们可以自己运营大型软件公司的一种方式。实际上，与公司销售额度和有多少大公司在使用相比，许多客户确实更关心支持和快速响应。请记住，我们无需赢得超过100％的市场，仅需赚取2％即可赚钱。我们的目标是针对那2%，那些讨厌当前市场上的产品和公司的人，他们可能会很高兴为我们提供机会。</p>\n\n<p>然后与第一个满意的客户一起，将它们用作参考并从那里开始。或许在更小型小众市场中，他们会向所有人狂热介绍我们，每个人都想知道更多。</p>\n\n<p>我与第一个客户一起，我做了以上所有事情，并且在第一年就飞了10次，在差旅费和一些没有签约的东西上我花费了2万美元。他们需要更多显示器吗？当然，我从戴尔订购了它们，两天后他们免费获得了这些显示器。他们喜欢这些事情。那是一笔14万美元的销售，但是那年我觉得我的净收益只有5万美元左右，就是因为这些零零碎碎的东西，但是他们确实成为了我的一个里程碑，为以后的更多销售铺平了道路。</p>\n\n<h2>政府项目</h2>\n\n<p>关于政府合同我在上一篇文章可能给人的印象是，我以通过某种方式来欺骗采购获得了订单。对于企业或政府部门合作的情况，你不能这样做且无法长时间合作。然而并不是，这是我的产品市场价格，成熟的市场，商业项目运作方式，公平公开，且多家公司参加竞标行为。在公开竞争和公开竞标的情况下，增加数字对谁都没有好处，因为我们的竞争对手会轻易削弱我们的利润。</p>\n\n<p>现在回想，我与当时和我签订合同的那位仁兄的对话，他所理解的是时间和素材的价格，而是实际上这个价格是固定的，并且我对这个合约并不是很了解，因此才产生了一些误会。所以对于批评我的政府人员，我真的不在乎。如果你们认为开放的自由市场上的商品过于昂贵，请不要向私营企业购买。相反，你们完全可以向我的竞争对手购买，但是价格会多出30%或更多？或者是雇佣Mega Contract Corp以三倍的价格为你们构建它，如果它不起作用，然后又花五年时间和一千万美元修复它？</p>\n\n<p>同时，我将继续向私营企业出售产品，这些企业不会像政府类型那样对每一条线和每一美元都斤斤计较。是的，我知道这是为了防止浪费和欺诈，但这仍然很烦人。</p>\n\n<p>（实际上，我很爱政府项目……请继续采购吧！）</p>\n","id":30907083839035640952837452186060843013,"intro":"如何将自己软件卖到2万美元，简单说就是：1. 市场调查一下，找出市面上那种一套卖好几万的软件，比如看你所在的公司在哪些很难用的软件上花了大钱；2. 只实现最核心的功能；3.卖软件+提供咨询服务，先伺候好一个客户。","published":true,"published_at":63739125493,"title":"如何将自己的软件卖到2万美元","topic_id":1},{"content":"<p>原文： <a href=\"https://medium.com/volosoft/asp-net-core-dependency-injection-best-practices-tips-tricks-c6e9c67f9d96?utm_source=ttalk.im&utm_medium=website&utm_campaign=Tech%2520Talk\">ASP.NET Core Dependency Injection Best Practices, Tips &amp; Tricks</a></p>\n\n<p>在本文当中，笔者将分享自己在ASP.NET Core应用中使用依赖注入的经验和建议。这些原则背后的动机是：\n - 有效设计服务及其依赖项。\n - 防止多线程引发的问题。\n - 防止内存泄漏。\n - 防御性编程，防止潜在的Bug。</p>\n\n<p>本文假设读者已经熟悉了依赖注入，同时对ASP.NET Core有了一定的了解。如果读者还未了解这两个技术，请先阅读\n微软的官方文档 <a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.1&utm_source=ttalk.im&utm_medium=website&utm_campaign=Tech%2520Talk\">ASP.NET Core Dependency Injection documentation</a>。</p>\n\n<h2>基础</h2>\n\n<h3>构造函数注入</h3>\n\n<p>构造函数注入主要用于在一个服务构造时，声明和获取对其它服务依赖关系。例如</p>\n\n<pre><code>public class ProductService\n{\n    private readonly IProductRepository _productRepository;    \n    public ProductService(IProductRepository productRepository)\n    {\n        _productRepository = productRepository;\n    }    \n    public void Delete(int id)\n    {\n        _productRepository.Delete(id);\n    }\n}</code></pre>\n\n<p>为了使用<code>IProductRepository</code>中的删除方法，<code>IProductRepository</code>被作为依赖注入到<code>ProductService</code>当中。</p>\n\n<h3>最佳实践：</h3>\n\n<ul>\n<li>在服务构造函数中显式定义所需的依赖项。 因此，如果服务所依赖的依赖项目不存在时，服务就无法被创建</li>\n<li>将被注入的对象设置为只读的域或者属性（从而防止，在其它方法中意外将此值重新赋值）。</li>\n</ul>\n\n<h3>属性注入</h3>\n\n<p>ASP.NET Core 自身所携带的<a href=\"https://www.nuget.org/packages/Microsoft.Extensions.DependencyInjection?utm_source=ttalk.im&utm_medium=website&utm_campaign=Tech%2520Talk\">standard dependency injection container</a>\n并不支持属性注入，但是读者可以使用其它支持输入注入的容器，读者可以参考此处<a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.1&utm_source=ttalk.im&utm_medium=website&utm_campaign=Tech%2520Talk#replacing-the-default-services-container\">Dependency injection in ASP.NET Core</a>。 具体例子如下：</p>\n\n<pre><code>using Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Logging.Abstractions;namespace MyApp\n{\n    public class ProductService\n    {\n        public ILogger&lt;ProductService&gt; Logger { get; set; }        \n        private readonly IProductRepository _productRepository;       \n        public ProductService(IProductRepository productRepository)\n        {\n            _productRepository = productRepository;            \n           Logger = NullLogger&lt;ProductService&gt;.Instance;\n        }      \n        public void Delete(int id)\n        {\n            _productRepository.Delete(id); \n            Logger.LogInformation( $\"Deleted a product with id = {id}\");\n        }\n    }\n}</code></pre>\n\n<p><code>ProductService</code> 声明了带有public setter方法的<code>Logger</code>。如果<code>Logger</code>存在了， 依赖注入容器会自动将<code>Logger</code>设置到类中，\n当然<code>Logger</code>必须要在注入之前就已经在依赖注入的管理器中注册。</p>\n\n<h3>最佳实践：</h3>\n\n<ul>\n<li>仅将属性注入用于可选依赖项。 这意味着服务可以在没有提供这些依赖项的情况下正常运行。</li>\n<li>使用想本例中的<a href=\"https://en.wikipedia.org/wiki/Null_object_pattern?utm_source=ttalk.im&utm_medium=website&utm_campaign=Tech%2520Talk\">Null Object模式</a>，否则的话，每次在使用这个属性前都要检查它是否为Null。</li>\n</ul>\n\n<h3>服务定位器</h3>\n\n<p>服务定位器模式是另一种获得依赖的方案。请看此例：</p>\n\n<pre><code>public class ProductService\n{\n    private readonly IProductRepository _productRepository;\n    private readonly ILogger&lt;ProductService&gt; _logger;   \n    public ProductService(IServiceProvider serviceProvider)\n    {\n        _productRepository = serviceProvider\n          .GetRequiredService&lt;IProductRepository&gt;();        \n        _logger = serviceProvider\n          .GetService&lt;ILogger&lt;ProductService&gt;&gt;() ??\n            NullLogger&lt;ProductService&gt;.Instance;\n    }    \n    public void Delete(int id)\n    {\n        _productRepository.Delete(id);\n        _logger.LogInformation($\"Deleted a product with id = {id}\");\n    }\n}\n</code></pre>\n\n<p><code>IServiceProvider</code>被注入到<code>ProductService</code>用来完成<code>ProductService</code>的依赖获取。如果类所需要的依赖没有被注册，<code>GetRequiredService</code>将会抛出异常。\n但是<code>GetService</code>在此场景下，会返回null。\n当在构造函数中进行服务定位，这些被注入的服务将会类实例释放的时候自动释放。所以，读者无需关心在构造函数中被注入的服务的释放情况（就像构造函数注入和属性注入一样）。</p>\n\n<h3>最佳实践：</h3>\n\n<ul>\n<li>请尽可能不使用服务定位器（如果在开发时已经知道了依赖的类型）。 因为它使依赖隐式转换，\n 这意味着在创建类实例时无法轻易看到依赖关系。在单元测试中，如果读者希望模拟类中某些依赖，这将会有非常大的影响。</li>\n<li>尽量使用构造函数依赖注入。 服务定位器会使应用程序更加复杂且容易出错。 笔者将在下一部分中介绍问题和解决方案。</li>\n</ul>\n\n<h3>服务的生命周期</h3>\n\n<p>在ASP.NET Core的依赖注入中有\n<a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.1&utm_source=ttalk.im&utm_medium=website&utm_campaign=Tech%2520Talk#service-lifetimes-and-registration-options\">三种生命周期</a></p>\n\n<ol>\n<li>Transient，在每次服务被要求注入到类中，都会创建一个新的服务</li>\n<li>Scoped，服务在作用域内只会创建一次。在Web应用中，每个Web请求都会创建一个完全隔离的全新的服务作用域。\n这代表着Scoped的生命周期的服务，会在每个Web请求时创建一个全新的服务。</li>\n<li>Singleton，代表服务只会为每个注入容器创建一次。这代表着，每个应用中该服务只会被创建一次，并在整个应用的生命周期中存活。</li>\n</ol>\n\n<p>依赖注入容器会跟踪所有已经被解析过的服务。服务会在生命周期结束的时候释放。</p>\n\n<ol>\n<li>如果一个服务也有依赖，这些依赖将会自动释放。</li>\n<li>如果服务实现了<code>IDisposable</code>接口，Dispose方法会在服务被释放的时候自动调用。</li>\n</ol>\n\n<h3>最佳实践：</h3>\n\n<ul>\n<li>尽可能将服务注册为Transient服务。 因为知道该服务的寿命很短，所以设计Transient服务很简单，通常不关心多线程和内存泄漏，它们很快就会被回收的。</li>\n<li>请谨慎使用Scoped服务的生命周期，因为如果创建了子服务作用域或从非Web应用程序使用这些服务，可能会很棘手。</li>\n<li>请谨慎使用Singleton生存期，因为这需要处理多线程和潜在的内存泄漏问题。</li>\n<li>不要在Singleton类型的服务中依赖Transient和Scoped这两种生命周期的服务。 因为Transient服务在注入Singleton服务时将成为一个Singleton实例。\n如果该Transient服务并不是为这种场景设计的，那么将会产生很多问题。ASP.NET Core的注入容器对这种情况默认会抛出异常。</li>\n</ul>\n\n<h2>在方法中解析服务</h2>\n\n<p>有时，需要在一个服务的方法中解析并获取另一个服务。这种情况下，需要确保使用完该被注入的服务后，释放该服务。\n最好的方法，就是创建一个子服务作用域，如下面的例子：</p>\n\n<pre><code>public class PriceCalculator\n{\n    private readonly IServiceProvider _serviceProvider;    \n    public PriceCalculator(IServiceProvider serviceProvider)\n    {\n        _serviceProvider = serviceProvider;\n    }    \n    public float Calculate(Product product, int count,\n      Type taxStrategyServiceType)\n    {\n        using (var scope = _serviceProvider.CreateScope())\n        {\n            var taxStrategy = (ITaxStrategy)scope.ServiceProvider\n              .GetRequiredService(taxStrategyServiceType);\n            var price = product.Price * count;\n            return price + taxStrategy.CalculateTax(price);\n        }\n    }\n}\n</code></pre>\n\n<p>在<code>PriceCalculator</code>构造的时候，<code>IServiceProvider</code>作为<code>PriceCalculator</code>的一个域被注入到了<code>PriceCalculator</code>当中。\n<code>PriceCalculator</code>在它的<code>Calculate</code>方法中，使用<code>IServiceProvider</code>创建了一个子服务作用域。\n在<code>Calculate</code>方法中使用了<code>scope.ServiceProvider</code>来代替<code>_serviceProvider</code>实例来完成服务的解析和注入。\n因此所有在此通过<code>scope</code>注入的服务，都会随着<code>using</code>语句释放<code>scope</code>而自动释放。</p>\n\n<h3>最佳实践：</h3>\n\n<ul>\n<li>如果要在方法中解析服务，请始终创建子服务作用域以确保正确释放已解析和注入的服务。</li>\n<li>如果方法以IServiceProvider作为参数，则可以直接从中解析服务，而无需考虑释放。 \n   如果代码中创建服务作用域，那么代码需要自行管理服务作用域。 遵循此原则可使代码更整洁。</li>\n<li>不要保留对已解决服务的引用！ 因为这样，可能会导致内存泄漏，并且稍后在使用对象引用时（除Singleton生命周期），可能会访问一个已被释放的对象。</li>\n</ul>\n\n<h2>单实例</h2>\n\n<p>单例服务通常被用来保持应用程序状态。 缓存就是保存应用程序状态的一个很好的例子。 </p>\n\n<pre><code>public class FileService\n{\n    private readonly ConcurrentDictionary&lt;string, byte[]&gt; _cache;    \n    public FileService()\n    {\n        _cache = new ConcurrentDictionary&lt;string, byte[]&gt;();\n    }    \n    public byte[] GetFileContent(string filePath)\n    {\n        return _cache.GetOrAdd(filePath, _ =&gt;\n        {\n            return File.ReadAllBytes(filePath);\n        });\n    }\n}</code></pre>\n\n<p><code>FileService</code>只是缓存文件内容以减少磁盘读取的服务。 该服务应注册为单例，否则它将不会按我们所想的那样工作。</p>\n\n<h3>最佳实践：</h3>\n\n<ul>\n<li>如果服务保持状态，则应在设计上做到数据读写是线程安全的。 因为所有请求同时使用服务的相同实例。 \n   笔者一般会使用ConcurrentDictionary而不是Dictionary来确保线程安全。</li>\n<li>不要使用单例服务中的Scoped或Transient服务。 因为，Transient服务可能并不是线程安全的。 \n如果必须使用它们，则在使用这些服务时要注意多线程（例如使用锁）。</li>\n<li>内存泄漏通常是由单例服务引起的。 在应用程序结束之前，它们是不会释放的。 因此，如果它们被实例化（或注入）后，直到应用程序结束时，才会被释放。\n确保在适当的时候释放它们。 请参阅前面的在方法中解析服务。</li>\n<li>如果是为了缓存数据（在此示例中为文件内容），则应创建一种机制当原始数据源发生更改时（在此示例中，当磁盘上的缓存文件发生更改时）更新或使缓存的数据无效。</li>\n</ul>\n\n<h2>Scoped类型服务</h2>\n\n<p>Scoped生命周期似乎是存储每个Web请求数据的理想选择。 因为ASP.NET Core会为每个Web请求创建一个服务作用域。\n因此，如果您将服务注册为Scoped类型，则可以在Web请求期间共享该服务。 </p>\n\n<pre><code>public class RequestItemsService\n{\n    private readonly Dictionary&lt;string, object&gt; _items;    \n    public RequestItemsService()\n    {\n        _items = new Dictionary&lt;string, object&gt;();\n    }    \n    public void Set(string name, object value)\n    {\n        _items[name] = value;\n    }    \n    public object Get(string name)\n    {\n        return _items[name];\n    }\n}</code></pre>\n\n<p>如果将<code>RequestItemsService</code>注册为Scoped类型并将其注入到两个不同的服务中，\n则可以从一个服务中获得另一个服务添加的项目，因为它们将共享相同的<code>RequestItemsService</code>实例。\n这就是对Scoped类型服务所具备的特性。</p>\n\n<p>但是事实可能并不总是那样。 如果创建子服务作用域并从子服务作用域解析<code>RequestItemsService</code>，则将获得<code>RequestItemsService</code>的全新实例，\n它也就无法按照设计所想的那样工作了。因此，Scoped类型服务并不意味着每个Web请求都共享同一个实例。</p>\n\n<p>读者可能会认为这种显而易见的错误并不容易发生（在子作用域中解析Scoped类型服务）。但是这并不是一个错误（仅仅是一种常规的用法）。\n通常这种场景发生的时候，所面向的业务并非如同例子中的业务这样简单。如果服务之间有着复杂的依赖关系，没有办法确保有人创建子作用域，\n并在子作用域中进行服务注入，注入那些Scoped类型服务。</p>\n\n<h3>最佳实践：</h3>\n\n<ul>\n<li>Scoped类型服务可以被认为是一种优化，它是在一个Web请求中需要多次注入的服务。 \n  因此，所有依赖Scoped类型服务的服务将在同一Web请求期间使用该Scoped类型服务的单个实例。</li>\n<li>Scoped类型服务不必设计为线程安全的。 因为，它们通常应由单个Web请求/线程使用。因此，如果不使用线程安全，就不应该在不同线程中使用同一个Scoped类型服务的实例。</li>\n<li>如果使用Scoped类型服务是为了在Web请求中让所有服务之间共享数据，请小心（如上所述的原因）。 因为我们完全可以将每个Web请求的数据存储在<code>HttpContext</code>内（注入<code>IHttpContextAccessor</code>进行访问），这是更安全的方法。 <code>HttpContext</code>的生存期不受限制。 实际上，它根本没有注册到依赖注入中（这就是为什么不注入它，而是注入<code>IHttpContextAccessor</code>的原因）。 <code>HttpContextAccessor</code>通过使用<code>AsyncLocal</code>在Web请求期间共享相同的<code>HttpContext</code>。</li>\n</ul>\n\n<h2>总结</h2>\n\n<p>依赖注入一开始似乎很容易使用，但是如果读者不严格的遵循某些原则，则可能存在多线程和内存泄漏的问题。 \n在这里分享的最佳实践，都是笔者在开发<a href=\"https://aspnetboilerplate.com?utm_source=ttalk.im&utm_medium=website&utm_campaign=Tech%2520Talk\">ASP.NET Boilerplate框架</a>这以过程中积累的经验。\n希望内给各位读者带来一些帮助。</p>\n","id":311452018925831259450027800212970645562,"intro":"近期学习了一些ASP.NET Core，准备使用ASP.NET Core开发一些小工具，发现ASP.NET Core也支持依赖注入，但是作为.NET Core新手，还是需要积极的像老前辈们学习，因此翻译此篇文章。","published":true,"published_at":63738853143,"title":"ASP.NET Core中的依赖注入的最佳实践，小贴士和技巧","topic_id":1},{"content":"<h2>Erlang的集群</h2>\n\n<p>Erlang语言本身定义的时候就支持了分布式特性。其中在Erlang虚拟机中，通过定义数据的编码方式，Erlang进程的表示方法和大量的基础组件来完成Erlang的分布式。</p>\n\n<h3>Erlang集群的特性</h3>\n\n<p>每个节点在使用非隐藏模式（在启动的时候没有使用-hidden）加入集群，那么这个节点和集群中所有的节点都会有一个TCP连接，就是大家所知道的无中心和全互联。\nErlang中的Erlang进程位置透明，不管Erlang进程在集群中任何一个节点上，其它节点的进程均可以向它发送消息，就如同该进程和发送消息的进程在同一个节点上一样。</p>\n\n<p>Erlang节点直接使用简单的Cookie机制进行验证，防止错误的接入和非法接入。\nErlang节点间的数据传输使用普通TCP传输，也可以使用TLS进行传输，从而防止被窃听。</p>\n\n<h3>Erlang集群是如何创建的</h3>\n\n<p>一般情况下，节点都是会被命名成nodename@ip或nodename@hostname这种模式。可以通过net_adm:ping(&lsquo;nodename@ip&rsquo;)或net_adm:ping(&lsquo;nodename@hostname&rsquo;)来完成节点的加入工作。但是真正进行节点建立的是net_kernel，因此本篇将重点分析net_kernel都进行了什么样的动作。</p>\n\n<p>另一种情况，就是Erlang集群中使用了mnesia集群，当mnesia启动的时候，mnesia会要求Erlang虚拟机连接其它节点加入集群。</p>\n\n<h3>Erlang是如何发现别的节点的</h3>\n\n<p>每个Erlang虚拟机在启动的时候都会尝试启动自带的epmd。epmd就如同大家所知到的DNS一样，它运行在一个约定的端口上，Erlang虚拟机启动后会在epmd上注册一个自己的节点名字和监听的端口号。当节点A想连接节点B的时候，节点A首先会从nodename@ip中取出ip部分，之后去连接这个ip上的epmd，当能成功连接epmd后节点A就会去查询节点B的端口，并进行连接。</p>\n\n<h2>代码分析</h2>\n\n<h3>net_kernel</h3>\n\n<p>net_kernel是Erlang集群构建中最关键的部分之一，它高屋建瓴的控制Erlang虚拟机和OTP库中其它模块成集群的建立和维护。net_kernel是一个gen_server，它在启动后，会完成下面这些功能：</p>\n\n<p>1.会建立一个定时器进程用来和别的节点进行心跳，检测其它节点是否离开集群。\n2.创建连接管理表\n3.启动可以连接的端口，用来接收别的节点的连接。</p>\n\n<h4>net_kernel:connect</h4>\n\n<p>当一个节点需要连接另一个节点的时候，就需要使用该函数了。</p>\n\n<pre><code><span class=\"code\">\nhandle_call<span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">connect, <span class=\"variable\">_</span>, <span class=\"variable\">Node</span></span>}</span>, <span class=\"variable\">From</span>, <span class=\"variable\">State</span></span>)</span> <span class=\"symbol\">when</span> <span class=\"variable\">Node</span> =:= <span class=\"symbol\">node</span><span class=\"paren1\">(<span class=\"code\"></span>)</span> -&gt;\n    async_reply<span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">reply, true, <span class=\"variable\">State</span></span>}</span>, <span class=\"variable\">From</span></span>)</span>;\n<span class=\"function\">handle_call</span><span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">connect, <span class=\"variable\">Type</span>, <span class=\"variable\">Node</span></span>}</span>, <span class=\"variable\">From</span>, <span class=\"variable\">State</span></span>)</span> -&gt;\n    verbose<span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">connect, <span class=\"variable\">Type</span>, <span class=\"variable\">Node</span></span>}</span>, 1, <span class=\"variable\">State</span></span>)</span>,\n    <span class=\"symbol\">case</span> ets:lookup<span class=\"paren1\">(<span class=\"code\">sys_dist, <span class=\"variable\">Node</span></span>)</span> <span class=\"symbol\">of</span>\n    <span class=\"paren1\">[<span class=\"code\"><span class=\"variable\">Conn</span></span>]</span> <span class=\"symbol\">when</span> <span class=\"variable\">Conn#connection</span>.state =:= up -&gt;\n        async_reply<span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">reply, true, <span class=\"variable\">State</span></span>}</span>, <span class=\"variable\">From</span></span>)</span>;\n    <span class=\"paren1\">[<span class=\"code\"><span class=\"variable\">Conn</span></span>]</span> <span class=\"symbol\">when</span> <span class=\"variable\">Conn#connection</span>.state =:= pending -&gt;\n        <span class=\"variable\">Waiting</span> = <span class=\"variable\">Conn#connection</span>.waiting,\n        ets:insert<span class=\"paren1\">(<span class=\"code\">sys_dist, <span class=\"variable\">Conn#connection</span><span class=\"paren2\">{<span class=\"code\">waiting = <span class=\"paren3\">[<span class=\"code\"><span class=\"variable\">From|Waiting</span></span>]</span></span>}</span></span>)</span>,\n        <span class=\"paren1\">{<span class=\"code\">noreply, <span class=\"variable\">State</span></span>}</span>;\n    <span class=\"paren1\">[<span class=\"code\"><span class=\"variable\">Conn</span></span>]</span> <span class=\"symbol\">when</span> <span class=\"variable\">Conn#connection</span>.state =:= up_pending -&gt;\n        <span class=\"variable\">Waiting</span> = <span class=\"variable\">Conn#connection</span>.waiting,\n        ets:insert<span class=\"paren1\">(<span class=\"code\">sys_dist, <span class=\"variable\">Conn#connection</span><span class=\"paren2\">{<span class=\"code\">waiting = <span class=\"paren3\">[<span class=\"code\"><span class=\"variable\">From|Waiting</span></span>]</span></span>}</span></span>)</span>,\n        <span class=\"paren1\">{<span class=\"code\">noreply, <span class=\"variable\">State</span></span>}</span>;\n    <span class=\"variable\">_</span> -&gt;\n        <span class=\"symbol\">case</span> setup<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Node</span>,<span class=\"variable\">Type</span>,<span class=\"variable\">From</span>,<span class=\"variable\">State</span></span>)</span> <span class=\"symbol\">of</span>\n        <span class=\"paren1\">{<span class=\"code\">ok, <span class=\"variable\">SetupPid</span></span>}</span> -&gt;\n            <span class=\"variable\">Owners</span> = <span class=\"paren1\">[<span class=\"code\"><span class=\"paren2\">{<span class=\"code\"><span class=\"variable\">SetupPid</span>, <span class=\"variable\">Node</span></span>}</span> | <span class=\"variable\">State#state</span>.conn_owners</span>]</span>,\n            <span class=\"paren1\">{<span class=\"code\">noreply,<span class=\"variable\">State#state</span><span class=\"paren2\">{<span class=\"code\">conn_owners=Owners</span>}</span></span>}</span>;\n        <span class=\"variable\">_</span>  -&gt;\n            <span class=\"macro\">?connect_failure(</span><span class=\"variable\">Node</span>, <span class=\"paren1\">{<span class=\"code\">setup_call, failed</span>}</span>),\n            async_reply<span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">reply, false, <span class=\"variable\">State</span></span>}</span>, <span class=\"variable\">From</span></span>)</span>\n        <span class=\"symbol\">end</span>\n    <span class=\"symbol\">end</span>;</span></code></pre>\n\n<p>从中可以看出，如果目标节点是自身，那么直接就忽略掉，返回成功。</p>\n\n<p>如果目标节点不是自身，先看一下ets中是否有向远程节点连接的进程。当这进行连接的进程状态是up，则直接返回true，否则将请求进程加入连接等待队列中。如果我们没有向远程节点进行连接的进程，则调用setup函数来建立一个。在setup函数中，会先找出连接远程节点所使用的模块名称，一般情况下是inet_tcp_dist这个模块。下面先假定是使用inet_tcp_dist这个模块，这个时候net_kernel会调用inet_tcp_dist:setup，并将成功后的Erlang进程PID放入sys_dist这个ets中。</p>\n\n<h4>net_kernel的心跳</h4>\n\n<p>创建的ticker进程，它专门负责发心跳给net_kernel进程，然后net_kernel进程会遍历所有远程连接的进程，让其进行一次心跳。当需要改变节点的心跳时间的时候，net_kernel会开启一个aux_ticker进程帮助我们进行过度，直到所有其它节点都知道了该节点改变了心跳周期为止，当所有其它节点都知道了这个节点的心跳周期发生了变化，这个aux_ticker进程也就结束了它的历史性任务，安静的退出了。</p>\n\n<p>当节点之间心跳发生异常了，就会发生TCP数据传输故障。当TCP传输发生异常的时候，Ports会按照约定好的规则进行清理，这个可参见dist.c中的erts_do_net_exits。</p>\n\n<h3>inet_tcp_dist</h3>\n\n<p>inet_tcp_dist模块在整个集群建立当中，提供了协议的支持和连接接入这些细节操作。</p>\n\n<h4>inet_tcp_dist:setup</h4>\n\n<pre><code><span class=\"code\"><span class=\"function\">setup</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Node</span>, <span class=\"variable\">Type</span>, <span class=\"variable\">MyNode</span>, <span class=\"variable\">LongOrShortNames</span>,<span class=\"variable\">SetupTime</span></span>)</span> -&gt;\n    spawn_opt<span class=\"paren1\">(<span class=\"code\"><span class=\"macro\">?MODULE,</span> do_setup, \n          <span class=\"paren2\">[<span class=\"code\"><span class=\"symbol\">self</span><span class=\"paren3\">(<span class=\"code\"></span>)</span>, <span class=\"variable\">Node</span>, <span class=\"variable\">Type</span>, <span class=\"variable\">MyNode</span>, <span class=\"variable\">LongOrShortNames</span>, <span class=\"variable\">SetupTime</span></span>]</span>,\n          <span class=\"paren2\">[<span class=\"code\"><span class=\"symbol\">link</span>, <span class=\"paren3\">{<span class=\"code\">priority, max</span>}</span></span>]</span></span>)</span>.\n \n<span class=\"function\">do_setup</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Kernel</span>, <span class=\"variable\">Node</span>, <span class=\"variable\">Type</span>, <span class=\"variable\">MyNode</span>, <span class=\"variable\">LongOrShortNames</span>,<span class=\"variable\">SetupTime</span></span>)</span> -&gt;\n    <span class=\"macro\">?trace(</span><span class=\"string\">\"~p~n\"</span>,<span class=\"paren1\">[<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">inet_tcp_dist,<span class=\"symbol\">self</span><span class=\"paren3\">(<span class=\"code\"></span>)</span>,setup,<span class=\"variable\">Node</span></span>}</span></span>]</span>),\n    <span class=\"paren1\">[<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"variable\">Address</span></span>]</span> = splitnode<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Node</span>, <span class=\"variable\">LongOrShortNames</span></span>)</span>,\n    <span class=\"symbol\">case</span> inet:getaddr<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Address</span>, inet</span>)</span> <span class=\"symbol\">of</span>\n    <span class=\"paren1\">{<span class=\"code\">ok, <span class=\"variable\">Ip</span></span>}</span> -&gt;\n        <span class=\"variable\">Timer</span> = dist_util:start_timer<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">SetupTime</span></span>)</span>,\n        <span class=\"comment\">%用epmd协议获得远程节点的端口\n</span>        <span class=\"symbol\">case</span> erl_epmd:port_please<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"variable\">Ip</span></span>)</span> <span class=\"symbol\">of</span>\n        <span class=\"paren1\">{<span class=\"code\">port, <span class=\"variable\">TcpPort</span>, <span class=\"variable\">Version</span></span>}</span> -&gt;\n            <span class=\"macro\">?trace(</span><span class=\"string\">\"port_please(~p) -&gt; version ~p~n\"</span>, \n               <span class=\"paren1\">[<span class=\"code\"><span class=\"variable\">Node</span>,<span class=\"variable\">Version</span></span>]</span>),\n            dist_util:reset_timer<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Timer</span></span>)</span>,\n                <span class=\"comment\">%连接远程节点\n</span>            <span class=\"symbol\">case</span> inet_tcp:connect<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Ip</span>, <span class=\"variable\">TcpPort</span>, \n                      <span class=\"paren2\">[<span class=\"code\"><span class=\"paren3\">{<span class=\"code\">active, false</span>}</span>, \n                       <span class=\"paren3\">{<span class=\"code\">packet,2</span>}</span></span>]</span></span>)</span> <span class=\"symbol\">of</span>\n            <span class=\"comment\">%拿到Socket之后，定义各种回调函数，状态以及状态机函数\n</span>            <span class=\"paren1\">{<span class=\"code\">ok, <span class=\"variable\">Socket</span></span>}</span> -&gt;\n                <span class=\"variable\">HSData</span> = #hs_data<span class=\"paren1\">{<span class=\"code\">\n                  kernel_pid = <span class=\"variable\">Kernel</span>,\n                  other_node = <span class=\"variable\">Node</span>,\n                  this_node = <span class=\"variable\">MyNode</span>,\n                  socket = <span class=\"variable\">Socket</span>,\n                  timer = <span class=\"variable\">Timer</span>,\n                  this_flags = 0,\n                  other_version = <span class=\"variable\">Version</span>,\n                  f_send = <span class=\"symbol\">fun</span> inet_tcp:send/2,\n                  f_recv = <span class=\"symbol\">fun</span> inet_tcp:recv/3,\n                  f_setopts_pre_nodeup = \n                  <span class=\"symbol\">fun</span><span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">S</span></span>)</span> -&gt;\n                      inet:setopts\n                    <span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">S</span>, \n                     <span class=\"paren3\">[<span class=\"code\"><span class=\"paren4\">{<span class=\"code\">active, false</span>}</span>,\n                      <span class=\"paren4\">{<span class=\"code\">packet, 4</span>}</span>,\n                      nodelay<span class=\"paren4\">(<span class=\"code\"></span>)</span></span>]</span></span>)</span>\n                  <span class=\"symbol\">end</span>,\n                  f_setopts_post_nodeup = \n                  <span class=\"symbol\">fun</span><span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">S</span></span>)</span> -&gt;\n                      inet:setopts\n                    <span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">S</span>, \n                     <span class=\"paren3\">[<span class=\"code\"><span class=\"paren4\">{<span class=\"code\">active, true</span>}</span>,\n                      <span class=\"paren4\">{<span class=\"code\">deliver, port</span>}</span>,\n                      <span class=\"paren4\">{<span class=\"code\">packet, 4</span>}</span>,\n                      nodelay<span class=\"paren4\">(<span class=\"code\"></span>)</span></span>]</span></span>)</span>\n                  <span class=\"symbol\">end</span>,\n                  f_getll = <span class=\"symbol\">fun</span> inet:getll/1,\n                  f_address = \n                  <span class=\"symbol\">fun</span><span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">_</span>,<span class=\"variable\">_</span></span>)</span> -&gt;\n                      #net_address<span class=\"paren2\">{<span class=\"code\">\n                   address = <span class=\"paren3\">{<span class=\"code\"><span class=\"variable\">Ip</span>,<span class=\"variable\">TcpPort</span></span>}</span>,\n                   host = <span class=\"variable\">Address</span>,\n                   protocol = tcp,\n                   family = inet</span>}</span>\n                  <span class=\"symbol\">end</span>,\n                  mf_tick = <span class=\"symbol\">fun</span> <span class=\"macro\">?MODULE:tick/</span>1,\n                  mf_getstat = <span class=\"symbol\">fun</span> <span class=\"macro\">?MODULE:getstat/</span>1,\n                  request_type = <span class=\"variable\">Type</span>\n                 </span>}</span>,\n                <span class=\"comment\">%进行握手\n</span>                dist_util:handshake_we_started<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">HSData</span></span>)</span>;\n            <span class=\"variable\">_</span> -&gt;\n                <span class=\"comment\">%% Other Node may have closed since \n</span>                <span class=\"comment\">%% port_please !\n</span>                <span class=\"macro\">?trace(</span><span class=\"string\">\"other node (~p) \"</span>\n                   <span class=\"string\">\"closed since port_please.~n\"</span>, \n                   <span class=\"paren1\">[<span class=\"code\"><span class=\"variable\">Node</span></span>]</span>),\n                <span class=\"macro\">?shutdown(</span><span class=\"variable\">Node</span>)\n            <span class=\"symbol\">end</span>;\n        <span class=\"variable\">_</span> -&gt;\n            <span class=\"macro\">?trace(</span><span class=\"string\">\"port_please (~p) \"</span>\n               <span class=\"string\">\"failed.~n\"</span>, <span class=\"paren1\">[<span class=\"code\"><span class=\"variable\">Node</span></span>]</span>),\n            <span class=\"macro\">?shutdown(</span><span class=\"variable\">Node</span>)\n        <span class=\"symbol\">end</span>;\n    <span class=\"variable\">_Other</span> -&gt;\n        <span class=\"macro\">?trace(</span><span class=\"string\">\"inet_getaddr(~p) \"</span>\n           <span class=\"string\">\"failed (~p).~n\"</span>, <span class=\"paren1\">[<span class=\"code\"><span class=\"variable\">Node</span>,<span class=\"variable\">_Other</span></span>]</span>),\n        <span class=\"macro\">?shutdown(</span><span class=\"variable\">Node</span>)\n    <span class=\"symbol\">end</span>.</span></code></pre>\n\n<p>在这函数当中，可以看到，Erlang每次对外建立连接的时候都需要去对方的epmd上进行查询。inet_tcp_dist主要注重流程和协议，将TCP传输细节交给了inet这个模块来进行，这样大大的减少了相应的代码量。在handshake_we_started和远程节点进行一次验证。这个验证过程非常简单，步骤如下：</p>\n\n<ol>\n<li>远程节点生成一个随机数，然后将这个随机数发给当前节点。</li>\n<li>当前节点用它所知道的远程节点的cookie加上这个随机数生成一个MD5，并将这个MD5返回给远程节点。</li>\n</ol>\n\n<p>当完成了验证，会使用do_setnode,告诉Erlang虚拟机该节点已经和目标节点的连接上了。同时通知net_kernel已经完成远程节点的连接，需要它改变sys_dist的ets状态和进行后续的操作。</p>\n\n<h3>dist.c</h3>\n\n<p>Erlang虚拟机中，负责管理节点互联的部分，是用纯C实现的。</p>\n\n<pre><code><span class=\"code\">\nBIF_RETTYPE setnode_3<span class=\"paren1\">(<span class=\"code\">BIF_ALIST_3</span>)</span>\n<span class=\"paren1\">{<span class=\"code\">\n    BIF_RETTYPE ret;\n    Uint flags;\n    <span class=\"symbol\">unsigned</span> <span class=\"symbol\">long</span> version;\n    Eterm ic, oc;\n    Eterm *tp;\n    DistEntry *dep = NULL;\n    Port *pp = NULL;\n\n    <span class=\"comment\">/* Prepare for success */</span>\n    ERTS_BIF_PREP_RET<span class=\"paren2\">(<span class=\"code\">ret, am_true</span>)</span>;\n\n    <span class=\"comment\">/*\n     * Check and pick out arguments\n     */</span>\n\n    <span class=\"symbol\">if</span> <span class=\"paren2\">(<span class=\"code\">!is_node_name_atom<span class=\"paren3\">(<span class=\"code\">BIF_ARG_1</span>)</span> ||\n        is_not_internal_port<span class=\"paren3\">(<span class=\"code\">BIF_ARG_2</span>)</span> ||\n        <span class=\"paren3\">(<span class=\"code\">erts_this_node-&gt;sysname == am_Noname</span>)</span></span>)</span> <span class=\"paren2\">{<span class=\"code\">\n         <span class=\"symbol\">goto</span> badarg;\n    </span>}</span>\n\n    <span class=\"symbol\">if</span> <span class=\"paren2\">(<span class=\"code\">!is_tuple<span class=\"paren3\">(<span class=\"code\">BIF_ARG_3</span>)</span></span>)</span>\n         <span class=\"symbol\">goto</span> badarg;\n    tp = tuple_val<span class=\"paren2\">(<span class=\"code\">BIF_ARG_3</span>)</span>;\n    <span class=\"symbol\">if</span> <span class=\"paren2\">(<span class=\"code\">*tp++ != make_arityval<span class=\"paren3\">(<span class=\"code\">4</span>)</span></span>)</span>\n         <span class=\"symbol\">goto</span> badarg;\n    <span class=\"symbol\">if</span> <span class=\"paren2\">(<span class=\"code\">!is_small<span class=\"paren3\">(<span class=\"code\">*tp</span>)</span></span>)</span>\n         <span class=\"symbol\">goto</span> badarg;\n    flags = unsigned_val<span class=\"paren2\">(<span class=\"code\">*tp++</span>)</span>;\n    <span class=\"symbol\">if</span> <span class=\"paren2\">(<span class=\"code\">!is_small<span class=\"paren3\">(<span class=\"code\">*tp</span>)</span> || <span class=\"paren3\">(<span class=\"code\">version = unsigned_val<span class=\"paren4\">(<span class=\"code\">*tp</span>)</span></span>)</span> == 0</span>)</span>\n         <span class=\"symbol\">goto</span> badarg;\n    ic = *<span class=\"paren2\">(<span class=\"code\">++tp</span>)</span>;\n    oc = *<span class=\"paren2\">(<span class=\"code\">++tp</span>)</span>;\n    <span class=\"symbol\">if</span> <span class=\"paren2\">(<span class=\"code\">!is_atom<span class=\"paren3\">(<span class=\"code\">ic</span>)</span> || !is_atom<span class=\"paren3\">(<span class=\"code\">oc</span>)</span></span>)</span>\n         <span class=\"symbol\">goto</span> badarg;\n\n    <span class=\"comment\">/* DFLAG_EXTENDED_REFERENCES is compulsory from R9 and forward */</span>\n    <span class=\"symbol\">if</span> <span class=\"paren2\">(<span class=\"code\">!<span class=\"paren3\">(<span class=\"code\">DFLAG_EXTENDED_REFERENCES &amp; flags</span>)</span></span>)</span> <span class=\"paren2\">{<span class=\"code\">\n         erts_dsprintf_buf_t *dsbufp = erts_create_logger_dsbuf<span class=\"paren3\">(<span class=\"code\"></span>)</span>;\n         erts_dsprintf<span class=\"paren3\">(<span class=\"code\">dsbufp, <span class=\"string\">\"%T\"</span>, BIF_P-&gt;common.id</span>)</span>;\n         <span class=\"symbol\">if</span> <span class=\"paren3\">(<span class=\"code\">BIF_P-&gt;common.u.alive.reg</span>)</span>\n              erts_dsprintf<span class=\"paren3\">(<span class=\"code\">dsbufp, <span class=\"string\">\" (%T)\"</span>, BIF_P-&gt;common.u.alive.reg-&gt;name</span>)</span>;\n         erts_dsprintf<span class=\"paren3\">(<span class=\"code\">dsbufp,\n                       <span class=\"string\">\" attempted to enable connection to node %T \"</span>\n                       <span class=\"string\">\"which is not able to handle extended references.</span><span class=\"string\">\\n</span><span class=\"string\">\"</span>,\n                       BIF_ARG_1</span>)</span>;\n         erts_send_error_to_logger<span class=\"paren3\">(<span class=\"code\">BIF_P-&gt;group_leader, dsbufp</span>)</span>;\n         <span class=\"symbol\">goto</span> badarg;\n    </span>}</span>\n\n    <span class=\"comment\">/*\n     * Arguments seem to be in order.\n     */</span>\n\n    <span class=\"comment\">/* get dist_entry */</span>\n    dep = erts_find_or_insert_dist_entry<span class=\"paren2\">(<span class=\"code\">BIF_ARG_1</span>)</span>;\n    <span class=\"symbol\">if</span> <span class=\"paren2\">(<span class=\"code\">dep == erts_this_dist_entry</span>)</span>\n         <span class=\"symbol\">goto</span> badarg;\n    <span class=\"symbol\">else</span> <span class=\"symbol\">if</span> <span class=\"paren2\">(<span class=\"code\">!dep</span>)</span>\n         <span class=\"symbol\">goto</span> system_limit; <span class=\"comment\">/* Should never happen!!! */</span>\n<span class=\"comment\">//通过Port的ID获取Port的结构\n</span>    pp = erts_id2port_sflgs<span class=\"paren2\">(<span class=\"code\">BIF_ARG_2,\n                BIF_P,\n                ERTS_PROC_LOCK_MAIN,\n                ERTS_PORT_SFLGS_INVALID_LOOKUP</span>)</span>;\n    erts_smp_de_rwlock<span class=\"paren2\">(<span class=\"code\">dep</span>)</span>;\n\n    <span class=\"symbol\">if</span> <span class=\"paren2\">(<span class=\"code\">!pp || <span class=\"paren3\">(<span class=\"code\">erts_atomic32_read_nob<span class=\"paren4\">(<span class=\"code\">&amp;pp-&gt;state</span>)</span>\n        &amp; ERTS_PORT_SFLG_EXITING</span>)</span></span>)</span>\n         <span class=\"symbol\">goto</span> badarg;\n\n    <span class=\"symbol\">if</span> <span class=\"paren2\">(<span class=\"code\"><span class=\"paren3\">(<span class=\"code\">pp-&gt;drv_ptr-&gt;flags &amp; ERL_DRV_FLAG_SOFT_BUSY</span>)</span> == 0</span>)</span>\n         <span class=\"symbol\">goto</span> badarg;\n<span class=\"comment\">//如果当前cid和传入的Port的ID相同，且port的sist_entry和找到的dep相同\n</span><span class=\"comment\">//那么直接进入结束阶段\n</span>    <span class=\"symbol\">if</span> <span class=\"paren2\">(<span class=\"code\">dep-&gt;cid == BIF_ARG_2 &amp;&amp; pp-&gt;dist_entry == dep</span>)</span>\n         <span class=\"symbol\">goto</span> done; <span class=\"comment\">/* Already set */</span>\n\n    <span class=\"symbol\">if</span> <span class=\"paren2\">(<span class=\"code\">dep-&gt;status &amp; ERTS_DE_SFLG_EXITING</span>)</span> <span class=\"paren2\">{<span class=\"code\">\n         <span class=\"comment\">/* Suspend on dist entry waiting for the exit to finish */</span>\n         ErtsProcList *plp = erts_proclist_create<span class=\"paren3\">(<span class=\"code\">BIF_P</span>)</span>;\n         plp-&gt;next = NULL;\n         erts_suspend<span class=\"paren3\">(<span class=\"code\">BIF_P, ERTS_PROC_LOCK_MAIN, NULL</span>)</span>;\n         erts_smp_mtx_lock<span class=\"paren3\">(<span class=\"code\">&amp;dep-&gt;qlock</span>)</span>;\n         erts_proclist_store_last<span class=\"paren3\">(<span class=\"code\">&amp;dep-&gt;suspended, plp</span>)</span>;\n         erts_smp_mtx_unlock<span class=\"paren3\">(<span class=\"code\">&amp;dep-&gt;qlock</span>)</span>;\n         <span class=\"symbol\">goto</span> yield;\n    </span>}</span>\n\n    ASSERT<span class=\"paren2\">(<span class=\"code\">!<span class=\"paren3\">(<span class=\"code\">dep-&gt;status &amp; ERTS_DE_SFLG_EXITING</span>)</span></span>)</span>;\n\n    <span class=\"symbol\">if</span> <span class=\"paren2\">(<span class=\"code\">pp-&gt;dist_entry || is_not_nil<span class=\"paren3\">(<span class=\"code\">dep-&gt;cid</span>)</span></span>)</span>\n         <span class=\"symbol\">goto</span> badarg;\n\n    erts_atomic32_read_bor_nob<span class=\"paren2\">(<span class=\"code\">&amp;pp-&gt;state, ERTS_PORT_SFLG_DISTRIBUTION</span>)</span>;\n\n    <span class=\"comment\">/*\n     * Dist-ports do not use the \"busy port message queue\" functionality, but\n     * instead use \"busy dist entry\" functionality.\n     */</span>\n    <span class=\"paren2\">{<span class=\"code\">\n         ErlDrvSizeT disable = ERL_DRV_BUSY_MSGQ_DISABLED;\n         erl_drv_busy_msgq_limits<span class=\"paren3\">(<span class=\"code\">ERTS_Port2ErlDrvPort<span class=\"paren4\">(<span class=\"code\">pp</span>)</span>, &amp;disable, NULL</span>)</span>;\n    </span>}</span>\n<span class=\"comment\">//更新Port所关联的dist\n</span>    pp-&gt;dist_entry = dep;\n\n    dep-&gt;version = version;\n    dep-&gt;creation = 0;\n\n    ASSERT<span class=\"paren2\">(<span class=\"code\">pp-&gt;drv_ptr-&gt;outputv || pp-&gt;drv_ptr-&gt;output</span>)</span>;\n\n<span class=\"special\">#if 1\n</span>    dep-&gt;send = <span class=\"paren2\">(<span class=\"code\">pp-&gt;drv_ptr-&gt;outputv\n         ? dist_port_commandv\n         : dist_port_command</span>)</span>;\n<span class=\"special\">#else\n</span>    dep-&gt;send = dist_port_command;\n<span class=\"special\">#endif\n</span>    ASSERT<span class=\"paren2\">(<span class=\"code\">dep-&gt;send</span>)</span>;\n\n<span class=\"special\">#ifdef DEBUG\n</span>    erts_smp_mtx_lock<span class=\"paren2\">(<span class=\"code\">&amp;dep-&gt;qlock</span>)</span>;\n    ASSERT<span class=\"paren2\">(<span class=\"code\">dep-&gt;qsize == 0</span>)</span>;\n    erts_smp_mtx_unlock<span class=\"paren2\">(<span class=\"code\">&amp;dep-&gt;qlock</span>)</span>;\n<span class=\"special\">#endif\n</span><span class=\"comment\">//更新dist_entry的cid\n</span>    erts_set_dist_entry_connected<span class=\"paren2\">(<span class=\"code\">dep, BIF_ARG_2, flags</span>)</span>;\n\n    <span class=\"symbol\">if</span> <span class=\"paren2\">(<span class=\"code\">flags &amp; DFLAG_DIST_HDR_ATOM_CACHE</span>)</span>\n         create_cache<span class=\"paren2\">(<span class=\"code\">dep</span>)</span>;\n\n    erts_smp_de_rwunlock<span class=\"paren2\">(<span class=\"code\">dep</span>)</span>;\n    dep = NULL; <span class=\"comment\">/* inc of refc transferred to port (dist_entry field) */</span>\n<span class=\"comment\">//增加远程节点的数量\n</span>    inc_no_nodes<span class=\"paren2\">(<span class=\"code\"></span>)</span>;\n<span class=\"comment\">//发送监控信息到调用的进程\n</span>    send_nodes_mon_msgs<span class=\"paren2\">(<span class=\"code\">BIF_P,\n            am_nodeup,\n            BIF_ARG_1,\n            flags &amp; DFLAG_PUBLISHED ? am_visible : am_hidden,\n            NIL</span>)</span>;\n done:\n\n    <span class=\"symbol\">if</span> <span class=\"paren2\">(<span class=\"code\">dep &amp;&amp; dep != erts_this_dist_entry</span>)</span> <span class=\"paren2\">{<span class=\"code\">\n         erts_smp_de_rwunlock<span class=\"paren3\">(<span class=\"code\">dep</span>)</span>;\n         erts_deref_dist_entry<span class=\"paren3\">(<span class=\"code\">dep</span>)</span>;\n    </span>}</span>\n\n    <span class=\"symbol\">if</span> <span class=\"paren2\">(<span class=\"code\">pp</span>)</span>\n         erts_port_release<span class=\"paren2\">(<span class=\"code\">pp</span>)</span>;\n\n    <span class=\"symbol\">return</span> ret;\n\n yield:\n    ERTS_BIF_PREP_YIELD3<span class=\"paren2\">(<span class=\"code\">ret, bif_export<span class=\"paren3\">[<span class=\"code\">BIF_setnode_3</span>]</span>, BIF_P,\n             BIF_ARG_1, BIF_ARG_2, BIF_ARG_3</span>)</span>;\n    <span class=\"symbol\">goto</span> done;\n\n badarg:\n    ERTS_BIF_PREP_ERROR<span class=\"paren2\">(<span class=\"code\">ret, BIF_P, BADARG</span>)</span>;\n    <span class=\"symbol\">goto</span> done;\n\n system_limit:\n    ERTS_BIF_PREP_ERROR<span class=\"paren2\">(<span class=\"code\">ret, BIF_P, SYSTEM_LIMIT</span>)</span>;\n    <span class=\"symbol\">goto</span> done;\n</span>}</span>\n</span></code></pre>\n\n<p>setnode函数主要完成下面这几个操作：</p>\n\n<ol>\n<li>将得到的远程节点的名字放入dist的hash表中，并且将这个表项和连接到远程节点的Port（TCP连接）进行了关联。</li>\n<li>将和远程节点进行连接的Port标记为ERTS_PORT_SFLG_DISTRIBUTION。</li>\n<li>在Erlang虚拟机内广告nodeup消息。</li>\n</ol>\n\n<p>其中给Port设置ERTS_PORT_SFLG_DISTRIBUTION标记是为了下面几个事情：</p>\n\n<ol>\n<li>让Port出现Busy的时候我们能区分出是普通的Port还是远程连接的Port。</li>\n<li>当Port被销毁的时候，确定是否要调用dist.c中的erts_do_net_exits来告诉Erlang虚拟机某个节点掉线。</li>\n</ol>\n\n<h3>如何提高集群稳定性</h3>\n\n<h4>epmd</h4>\n\n<p>当独立进程epmd发现自己和本地节点的连接断了，那么直接将这个node注册的名字和端口从自身缓存中删除掉，但是这个删除是有一定延迟的。</p>\n\n<p>但是当empd被不小杀掉了，当empd被再次启动的时候，数据将会全部清除。而且，本地节点不会自动向epmd重新注册自己的端口等。</p>\n\n<h4>dist_port</h4>\n\n<p>dist_port负责所有Erlang进程透明调用的数据发送和传输，同时也负责着节点之间存活检测的任务。由于Erlang的节点检测都是以本节点是否能和对应节点有心跳为视角，如果使用使用dist_port传输大量的数据，很容易引起dist_port_busy，从而引起节点离线的误判或性能下降。</p>\n\n<p>Erlang默认会为dist_port设置一个1M的缓存，但是如果在节点之间传输大量的数据很容易就不够用。如果在设计的时候就意识到自己要传输大量数据，可以使用+zdbbl这个参数来改变dist_port的缓存。Erlang提供了erlang:system_info函数来查询dist_piort的缓存大小，同时Erlang还提供erlang:system_monitor函数来监控dist_port_busy。</p>\n\n<p>并且在实际使用中，可以参考Spil Games的架构，对Erlang的集群进行分层, 参考 <a href=\" https://www.slideshare.net/InfoQ/scaling-distributed-systems?utm_source=ttalk.im&utm_medium=website&utm_campaign=Tech%2520Talk\">Scaling Distributed Systems </a>。</p>\n\n<p>同时需要注意的是，Erlang的集群虽然可以跨越IDC，但是在实际的使用中，并不推荐这样做，原因如下：</p>\n\n<ol>\n<li>IDC间网络延迟偏高，Erlang集群本身对网络延迟敏感。</li>\n<li>IDC间网络吞吐有限</li>\n<li>net_kernel并未对高并发连接做优化，很容易被攻击者攻击</li>\n<li>Erlang集群之间的连接对HA不友好，不如Restful。而IDC之间链路很多时候并不稳定，需要进行冗余，这对Erlang集群并不友好。</li>\n</ol>\n\n<h4>节点重启</h4>\n\n<p>这个是非常需要注意的，Erlang节点之间确认存活是需要心跳时间的。Erlang在进行跨节点操作的时候，都会监控远程节点的状态，尤其是Mnesia数据库很多操作对Erlang节点存活性是非常敏感的。当一个节点掉线后，不应该立刻重启，一般需要等待该节点心跳事件 * 1.5的时间。为什么要这样做呢？因为这样做是为了让节点彻底“死掉”，集群中所有的节点都知道该节点死掉了，这样才不会出现远程操作被锁死的情况（顺便说一句，这个简单问题，在国内某个著名的通讯SaaS中多次出现，该云的架构师曾经多次提出Erlang不是开箱即用，因为他根本没搞清楚Erlang的底层原理，甚至可以说分布式系统中的基础原理）。</p>\n","id":139630341863077693775204603462452304430,"intro":"通过对Erlang/OTP和Erts中的代码进行相应的分析，让读者可以清晰的看到，Erlang是如何进行节点发现和构建集群的。以及在构建Erlang集群中，怎么样构建集群才能更加稳定。","published":true,"published_at":63737757433,"title":"Erlang是如何构建集群的","topic_id":1},{"content":"<h2>什么是MQTT</h2>\n\n<p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）是基于二进制消息的发布/订阅编程模式的消息协议，最早由IBM提出的，如今已经成为OASIS规范。由于规范很简单，非常适合需要低功耗和网络带宽有限的IoT场景。</p>\n\n<h2>MQTT特点</h2>\n\n<ol>\n<li>精简，不添加可有可无的功能。</li>\n<li>发布/订阅（Pub/Sub）模式，方便消息在传感器之间传递。</li>\n<li>允许用户动态创建主题，零运维成本。</li>\n<li>把传输量降到最低以提高传输效率。</li>\n<li>把低带宽、高延迟、不稳定的网络等因素考虑在内。</li>\n<li>支持连续的会话控制。</li>\n<li>理解客户端计算能力可能很低。</li>\n<li>提供服务质量管理。</li>\n<li>假设数据不可知，不强求传输数据的类型与格式，保持灵活性。</li>\n</ol>\n\n<p>为了满足不同的场景，MQTT支持三种不同级别的服务质量（Quality of Service，QoS）为不同场景提供消息可靠性：</p>\n\n<ol>\n<li>级别0：尽力而为。消息发送者会想尽办法发送消息，但是遇到意外并不会重试。</li>\n<li>级别1：至少一次。消息接收者如果没有知会或者知会本身丢失，消息发送者会再次发送以保证消息接收者至少会收到一次，当然可能造成重复消息。</li>\n<li>级别2：恰好一次。保证这种语义肯待会减少并发或者增加延时，不过丢失或者重复消息是不可接受的时候，级别2是最合适的。</li>\n</ol>\n\n<h2>和XMPP相比优缺点</h2>\n\n<h3>MQTT</h3>\n\n<p>如其名称所述，其主要目的是遥测或远程监控。其目标是从许多设备收集数据并将该数据传输到IT基础架构。它面向需要从云监控或控制的小型设备的大型网络。消息队列遥测传输（MQTT）实现了一个中心辐射系统。 MQTT很少尝试启用设备到设备的传输，也不会将数据“扇出”给许多收件人。</p>\n\n<p>由于它具有清晰，引人注目的单一应用，因此MQTT很简单，提供了很少的控制选项，它也不需要特别快，在这种情况下，“实时”通常以秒为单位。MQTT是一种中心辐射架构。所有设备都连接到数据集中器服务器，如IBM新的MessageSight设备。MQTT使应用程序能够监视巨大的石油管道泄漏或破坏，几千个传感器的数据都被集中在一个单独的位置进行分析。当系统发现问题时，可以采取行动来纠正该问题。 MQTT的其他应用包括电力使用监控，照明控制，甚至智能园艺。</p>\n\n<h3>XMPP</h3>\n\n<p>如<a href=\"https://www.ttalk.im/pages/111/%5B%E6%9D%82%E8%B0%88%5D%E4%BB%80%E4%B9%88%E6%98%AF%20XMPP.html\" >本篇</a>中对XMPP的介绍，XMPP（可扩展消息处理现场协议）是基于可扩展标记语言（XML）的协议，它用于即时消息（IM）以及在线通讯的相关场景。<br/>\n应用XMPP的核心XML流传输协议的定义使得XMPP能够在一个比以往网络通信协议更规范的平台上。借助于XML易于解析和阅读的特性，使得XMPP的协议能够非常容易被理解和调试。XMPP的即时通讯扩展应用部分是根据IETF在这之前对即时通讯的一个抽象定义的，与其他业已得到广泛使用的即时通讯协议，诸如AIM，QQ等相比，XMPP更加开放，更容易扩展并且天生就具有分布式特性。</p>\n\n<h3>比较</h3>\n\n<p>MQTT的优势：\n1. 协议简单且轻量级\n1. QoS管理\n1. 客户端不需要强大的计算力\n1. 数据可以自行定义，无强制要求\n1. 高带宽利用率，考虑慢速网络，连接速度快</p>\n\n<p>MQTT的劣势：\n1. 不擅长处理将数据交付给多个收件人的场景\n1. 不擅长处理复杂的业务控制，可扩展性取决于顶层机制\n1. 不擅长高速大队列的数据传输</p>\n","id":87917329756803558340787875971018994062,"intro":"介绍MQTT协议，并对MQTT协议和XMPP协议进行简单的对比，分析MQTT适用的场景。","published":true,"published_at":63737375502,"title":"什么是 MQTT","topic_id":1},{"content":"<h2>Linux历史背景</h2>\n\n<h3>什么是Linux</h3>\n\n<p>Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>\n\n<p>但是，事实上Linux只是GNU/Linux的内核部分，不过由于GNU的内核（详细可以参见GNU Hurd）迟迟无法推出，并且人们已经习惯将GNU/Linux简称为Linux。</p>\n\n<h3>Linux怎么来的</h3>\n\n<p>一个名叫Linus Torvalds的芬兰大学生想在他的Intel 80386上使用类似Unix的系统，最开始他使用了Minx这个类Unix的变种（因为Minix是微内核，而Unix当时主要为宏内核）。但是Minx当时对于80386 的支持是非常脆弱的，因此他决定要开发出一个全功能的、支持POSIX标准的、类Unix的操作系统内核，该系统吸收了BSD和System V的优点，同时摒弃了它们的缺点。</p>\n\n<h3>什么是Unix</h3>\n\n<p>UNIX也是一个操作系统，该操作系统是美国贝尔实验室的Ken.Thompson和Dennis Ritchie 于1969 年夏在DEC PDP-7 小型计算机上开发的一个分时操作系统。Ken Thompson 为了能在闲置不用的PDP-7 计算机上运行他非常喜欢的星际旅行（Space travel）游戏，于是在1969 年夏天乘他夫人回家乡加利福尼亚渡假期间，在一个月内开发出了UNIX 操作系统的原型。当时使用的是BCPL语言（基本组合编程语言），后经Dennis Ritchie 于1972 年用移植性很强的C语言进行了改写，使得UNIX 系统在大专院校得到了推广。现在所说的Unix一般指代的是Unix商标和符合该规范并得到授权的系统，现在还可以称为的Unix系统的有，IBM的AIX，Orcale的Solaris和Apple的MacOS X。</p>\n\n<h3>什么是GNU</h3>\n\n<p>GNU代表<code>GNU not Unix</code>，GNU是自由软件之父Richard Stallman在1984年组织开发的一个完全基于自由软件的软件体系，与此相应的有一分通用公共许可证（General Public License，简称GPL）。Linux以及与他有关的大量软件是在GPL的推动下开发和发布的。该组织为GNU/Linux外围软件做出了巨大的贡献，例如说编译器GCC，常用的Bash等。</p>\n\n<h3>什么是POSIX标准</h3>\n\n<p>这个概念非常重要。POSIX（Portable Operating System Interface for Computing System）是由IEEE 和ISO/IEC 开发的一簇标准。 该标准是基于现有的UNIX实践和经验，描述了操作系统的调用服务接口，用于保证编制的应用程序可以在源代码一级上在多种操作系统上移植运行。</p>\n\n<h3>为什么Linux得到了发展</h3>\n\n<p>在当时有Unix了和很多Unix的变种，为什么发展到今天，只有Linux得到了更广泛的发展呢？</p>\n\n<h4>版权之争的Unix</h4>\n\n<p>当时Unix的两个主流版本是AT&amp;T的System V和加州伯克利分校开发的BSD。</p>\n\n<p>和AT&amp;T的System V分支不同，BSD由大学发布，主要是用于学术研究，希望可以开源和免费软件的形式发布。但是，4.3版本以及之前的BSD中都包括了AT&amp;T的源代码，毫无疑问，这些源代码应该服从AT&amp;T的License。因此Unix版权的拥有者和相关公司，为了这些代码和版权问题，打的不可开交，这大大的影响了Unix的两个发行版的开发和发展。</p>\n\n<h4>过于学术的Minx</h4>\n\n<p>MINIX 系统是由Andrew S. Tanenbaum（AST）开发的。因为AT&amp;T的政策改变，在Version 7 Unix推出之后，发布新的使用许可协议，将UNIX源代码私有化，在大学中不再能使用UNIX源代码Andrew S. Tanenbaum为了能在课堂上教授学生操作系统运作的实务细节，决定在不使用任何AT&amp;T的源代码前提下，自行开发与UNIX兼容的操作系统，以避免版权上的争议。他以小型UNIX（mini-UNIX）之意，将它称为MINIX。到1991 年时版本是1.5，到2017年Minx的版本是3.0。Minix在核心设计上采用微核心，即将操作系统分成微核心和其上的提供文件系统、存储器管理、驱动程序等服务的服务程序，但是正如人们后来所知的微内核过于复杂以及效率问题，在开发和实用上困难很多。</p>\n\n<h4>Linus的推广</h4>\n\n<p>Linus在互联网和GNU发展的初期，就很有远见的看到了互联网会推动软件的发展。充分的善用了人和（在comp.os.minix推广Linux，以及和Andrew的对喷，可见英文写作和嘴炮能力多重要），天时（Unix的版权之争，让BSD足足晚了好多年才被人们认知）和地利（GNU/Hurd难产，Linux又使用GPL，Linux和GNU一拍即合）。抓住了互联网和免费的的大潮。</p>\n\n<h2>Linux的发行版</h2>\n\n<h3>什么是Linux的发行版</h3>\n\n<p>就Linux的本质来说，它只是操作系统的核心，负责控制硬件、管理文件系统、程序进程等，并不给用户提供各种工具和应用软件。所谓工欲善其事，被必先利其器，一套在优秀的操作系统核心，若没有强大的应用软件可以使用，如C/C++编译器、C/C++库、系统管理工具、网络工具、办公软件、多媒体软件、绘图软件等，也无法发挥它强大的功能，用户也无法仅仅使用这个系统核心进行工作，因此人们以Linux内核为中心，再集成搭配各种各样的系统管理软件或应用工具软件组成一套完整的操作系统，如此的组合便称为Linux发行版。</p>\n\n<h3>知名的发型版</h3>\n\n<p>因为GNU/Linux本身是开源的，所以任何人，任何厂商只要在遵循社区游戏规则的前提下构建自己的发行版本，目前已知大约有300个Linux的发行版（看着头就疼，还是BSD系列好，OpenBSD和FreeBSD主打，DragonFlyBSD和NetBSD玩票）。所以这里只介绍一些比较知名的发行版本。</p>\n\n<h4>Slackware</h4>\n\n<p>Slackware可以说是历史悠久，与很多其他的发行版不同，它坚持KISS（Keep It Simple Stupid）的原则。配置系统会有一些困难，但是更有经验的用户会喜欢这种方式的透明性和灵活性。Slackware 很多特性体现出了KISS原则，最为有名的一些例子就是不依赖图形界面的文本化系统配置、传统的服务管理方式和不解决依赖的包管理方式。它的最大特点就是安装灵活，目录结构严谨，版本力求稳定而非追新。Slackware的软件包都是通常的tgz(tar/gzip) 或者txz(xz) 格式文件再加上安装脚本。Tgz/Txz 对于有经验的用户来说，比RPM更为灵活，并避免了APT 之类管理器可能带来的的依赖地狱。</p>\n\n<h4>Fedora</h4>\n\n<p>Fedora是一套从Red Hat Linux发展出来的免费Linux系统。Fedora的前身就是Red Hat Linux。Fedora由一个强大的社群开发，这个社群的成员以自己的不懈努力，提供并维护自由、开放源码的软件和开放的标准。Fedora项目由 Fedora 基金会管理和控制，得到了Red Hat, Inc. 的支持。Red Hat会将一些先行技术放入Fedora进行试验（我会告诉你，你是Red Hat的小白鼠嘛），它尤其可以为在Red Hat和CentOS环境下工作的那些人带来便利。它使用RPM包来安装软件，并且提供repo这种包管理器来简化软件包的安装流程和进行软件包升级。</p>\n\n<h4>Debian</h4>\n\n<p>Debian的目标是提供一个稳定容错的Linux版本。支持Debian的不是某家公司，而是许多在其改进过程中投入了大量时间的开发人员，这种改进吸取了早期Linux的经验。Debian以其稳定性著称（我会告诉你，这个版本的软件万年不更新嘛），是很多服务器和程序员所喜爱的版本之一。Debian的创始人自杀了，实在是让人惋惜。Debian作为一个服务器专用发行版是非常稳定的，基本上都不需要折腾。</p>\n\n<h4>Red Hat</h4>\n\n<p>可能这是最著名的Linux版本了，Red Hat Linux已经创造了自己的品牌，越来越多的人听说过它。Red Hat在1994年创业，当时聘用了全世界500多名员工，他们都致力于开放的源代码体系。它拥有自己的公司，能向用户提供一套完整的服务，这使得它特别适合在公共网络中使用。这个版本的Linux也使用最新的内核，还拥有大多数人都需要使用的主体软件包。\nRed Hat Linux的安装过程也十分简单明了。它的图形安装过程提供简易设置服务器的全部信息。磁盘分区过程可以自动完成，还可以选择GUI工具完成，即使对于Linux新手来说这些都非常简单。选择软件包的过程也与其他版本类似；用户可以选择软件包种类或特殊的软件包。系统运行起来后，用户可以从Web站点和 Red Hat那里得到充分的技术支持。Red Hat是一个符合大众需求的最优版本（我会告诉你，你只要拿钱就行了嘛）。在服务器和桌面系统中它都工作得很好。Red Hat的唯一缺陷是带有一些不标准的内核补丁，这使得它难于按用户的需求进行定制。 Red Hat通过论坛和邮件列表提供广泛的技术支持，它还有自己公司的电话技术支持，后者对要求更高技术支持水平的集团客户更有吸引力。</p>\n\n<h4>SuSE</h4>\n\n<p>SuSE的总部设立在德国，已经奋斗了多年。SuSE一直致力于创建一个连接数据库的最佳Linux版本。为了实现这一目的，SuSE与Oracle 和IBM合作，以使他们的产品能稳定地工作。SuSE还开发了SuSE Linux eMail Server III，一个非常稳定的电子邮件群组应用。在SuSE发行版，可以非常方便地访问Windows磁盘，这使得两种平台之间的切换，以及使用双系统启动变得更容易。SuSE的硬件检测非常优秀，该版本在服务器和工作站上都用得很好。SuSE拥有界面友好的安装过程，还有图形管理工具，可方便地访问Windows磁盘，对于终端用户和管理员来说使用它同样方便，这使它成为了一个强大的服务器平台。</p>\n\n<h4>CentOS</h4>\n\n<p>CentOS（Community ENTerprise Operating System）是来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用（我会告诉你，以为企业想省钱，运维要靠这个东西来赚钱嘛，国内运维主流是CentOS剩下版本很少）。两者的不同，在于CentOS并不包含封闭源代码软件，CentOS 是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本。每个版本的CentOS都会获得十年的支持（通过安全更新方式）。新版本的 CentOS 大约每两年发行一次，而每个版本的 CentOS 会定期（大概每六个月）更新一次，以便支持新的硬件。这样，建立一个安全、低维护、稳定、高预测性、高重复性的 Linux 环境。</p>\n\n<h4>Ubuntu</h4>\n\n<p>Ubuntu是一个基于Debian的发型版本，但是软件更新频度相对较高。它提供两个主要版本，一个是桌面版本，一个是服务器版本，但是Ubuntu比较注重桌面版本。Ubuntu在发布版本的时候，会发布一个LTS版本，这个版本会提供长达三年的升级支持。</p>\n\n<h4>Gentoo</h4>\n\n<p>Gentoo它能为几乎任何应用程序或需求自动地作出优化和定制。追求极限的配置、性能，以及顶尖的用户和开发者社区，都是Gentoo体验的标志特点。 Gentoo的哲学是自由和选择，得益于一种称为Portage的技术，Gentoo能成为理想的安全服务器、开发工作站、专业桌面、游戏系统、嵌入式解决方案或者别的东西。Gentoo Linux是滚动升级的发行版，所以在上游软件发布很短时间后，其上就会有软件包可用。Gentoo的基础系统和软件包都是根据用户指定的USE标识直接从源代码构建（我会告诉你，这玩意难用死了嘛，至少不要用Python写好不好）。</p>\n\n<h4>Arch</h4>\n\n<p>Arch Linux是一个 “以用户为中心”的发行版。此发行版是为了满足贡献者的需求，而不是为了吸引尽可能多的用户。Arch 适用于乐于自己动手的用户，他们愿意花时间阅读文档，解决自己的问题。\n报告问题、完善 Wiki 社区文档、为其它用户提供技术支持。Arch 用户仓库 收集用户贡献的软件包，Arch的最大优势就是滚动升级。</p>\n\n<h2>Linux发行版选择</h2>\n\n<h3>新手</h3>\n\n<p>作为Linux的新手，简单易用的Ubuntu桌面的LTS或者Debian是非常不错的选择，因为这两个版本的包管理系统非常成熟，桌面也非常简洁。</p>\n\n<h3>动手能力强的</h3>\n\n<p>可选发型版本就比较多了，例如说Gentoo，Arch和Slackware，包括这里没有列举的LFS（我会告诉你，用了之后你会怀疑，这也算发行版嘛）。</p>\n\n<h3>研发或运维</h3>\n\n<p>根据公司实际使用情况选吧，但是绝大部分国内公司都会选CentOS（我会告诉你，运维圈内不会CentOS会被鄙视嘛）。所以好好的用Fedora，CentOS和Red Hat才是正道。</p>\n","id":298071021252817739534056192575116440167,"intro":"为读者介绍下Linux，以及Linux的一些比较常见的发型版本。","published":true,"published_at":63734916122,"title":"Linux和它的发行版","topic_id":1},{"content":"<p><a href=\"https://nearsoft.com/blog/functional-programming-concepts-applied-using-c/?utm_source=ttalk.im&utm_medium=website&utm_campaign=Tech%2520Talk\">原文-Functional Programming Concepts Applied Using C#</a></p>\n\n<p>近年来函数式编程得到了很大的发展。读者也许对函数式编程很感兴趣，但是依然无法在日常工作中应用函数式编程。本篇文章旨在能为读者提供一个将函数式编程理念和技术应用到.NET Framework的指南。</p>\n\n<h2>箭头符号</h2>\n\n<p>在函数式语言中箭头符号主要是作为函数签名语法的首选语法，并且箭头函数具备右结合联属性（right associative）。如下面的例子</p>\n\n<pre><code>(int) -&gt; ((int) -&gt; (int)) EQUALS int -&gt; int -&gt; int\n</code></pre>\n\n<p>这可以被理解为，该函数使用两个整形数值作为参数并返回整形数值作为结果。在C#中，有3种方式可以创建该函数</p>\n\n<p><code>Delegates = private delegate int ExampleDelegate(int left, int right)</code> 其中left和right是函数签名中的前两个整形值，返回类型是函数签名中的第三个值。</p>\n\n<pre><code>using System;\n \ninternal class TestDelegates\n{\n    // int -&gt; int -&gt; int\n    private delegate int MyFirstSumDelegate(int x, int y);\n \n    // int -&gt; int -&gt; int -&gt; ()\n    private delegate void MySecondSumDelegate(int x, int y, int z);\n \n    internal static void Run()\n    {\n        MyFirstSumDelegate myFirstSumDelegate = SumTwo;\n \n        var delegateResult = myFirstSumDelegate(1, 2);\n \n        Console.WriteLine(delegateResult);\n \n        MySecondSumDelegate mySecondSumDelegate = SumThreeWithLog;\n        mySecondSumDelegate(1, 2, 3);\n    }\n \n    private static int SumTwo(int a, int b) =&gt; a + b;\n \n    private static void SumThreeWithLog(int a, int b, int c)\n    {\n        var result = a + b + c;\n        Console.WriteLine(result);\n    }\n}\n</code></pre>\n\n<p><code>Funcs = private Func &lt;int, int, int&gt; ExampleFunc</code> 在这个例子中，前两个整形是参数，最后一个整形值是返回类型。</p>\n\n<pre><code>using System;\n \ninternal class TestFuncs\n{\n    // int -&gt; int -&gt; int\n    private delegate int MySumDelegate(int x, int y);\n \n    internal static void Run()\n    {\n        MySumDelegate mySumDelegate = Sum;\n        // int -&gt; int -&gt; int\n        Func&lt;int, int, int&gt; mySumFunc = Sum;\n \n        var delegateResult = mySumDelegate(1, 2);\n        var funcResult = mySumFunc(1, 2);\n \n        Console.WriteLine(delegateResult);\n        Console.WriteLine(funcResult);\n    }\n \n    private static int Sum(int a, int b) =&gt; a + b\n}\n</code></pre>\n\n<p><code>Actions = private Action&lt;int, int, int&gt; ExampleAction</code> 这是一个非常特殊的情况，它们被认为是函数，\n但是这个函数的返回值永远都是void，在这个函数中它接受3个整形参数并且返回void。</p>\n\n<pre><code>using System;\n \ninternal class TestActions\n{\n    // int -&gt; int -&gt; int -&gt; ()\n    private delegate void MySumDelegate(int x, int y, int z);\n \n    internal static void Run()\n    {\n        MySumDelegate mySumDelegate = SumWithLog;\n        // int -&gt; int -&gt; int -&gt; ()\n        Action&lt;int, int, int&gt; mySumAction = SumWithLog;\n \n        mySumDelegate(1, 2, 3);\n        mySumAction(1, 2, 3);\n    }\n \n    private static void SumWithLog(int a, int b, int c)\n    {\n        var result = a + b + c;\n        Console.WriteLine(result);\n    }\n}</code></pre>\n\n<h2>函数作为一等公民</h2>\n\n<p>当函数成为语言中的一等公民的时候，这就意味这函数具备下面的特性</p>\n\n<ul>\n<li>可以作为其它函数的参数值</li>\n<li>可以作为一个函数的返回值</li>\n<li>可以被赋值给变量</li>\n<li>可以存储到集合中</li>\n</ul>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing static System.Console;\n// you could use an alias to simplify types\n// int -&gt; int -&gt; int\nusing Adder = System.Func&lt;int, int, int&gt;;\n \ninternal class TestFirstClassFunctions\n{\n    // Assigned to a variable\n    private readonly static Adder adder = (x, y) =&gt; x + y;\n \n    internal static void Run()\n    {\n        // Stored in a collection\n        var functions = new Dictionary&lt;string, Adder&gt;\n        {\n            { \"One\", adder },\n            { \"Two\", Generator(adder) },\n        };\n \n        var index = 1;\n \n        foreach (var f in functions)\n            WriteLine($\"{f.Key} =&gt; {f.Value.Invoke(index, ++index)}\");\n    }\n \n    // As return type and as parameter\n    private static Adder Generator(Adder adder) =&gt; adder;\n}</code></pre>\n\n<h2>高阶函数</h2>\n\n<p>高阶函数就是可以被认为是一个函数接受一个参数做参数或返回一个函数做结果，或者同时接受一个函数做参数且返回一个函数做结果</p>\n\n<pre><code>using System;\nusing static System.Console;\nusing Subtractor = System.Func&lt;int, int, int&gt;;\n \ninternal class TestHigherOrderFunctions\n{\n    private readonly static Subtractor subtractor = (x, y) =&gt; x - y;\n \n    internal static void Run() =&gt;\n        WriteLine(Generator(subtractor)(44, 2));\n \n    // This is a HOF\n    // takes a functions as argument\n    // and returns a function\n    private static Subtractor Generator(Subtractor subtractor)\n        =&gt; subtractor;\n}</code></pre>\n\n<h2>纯函数</h2>\n\n<p>如果一个函数的返回结果，完全依赖于传入的参数，就可以认为这个函数是一个纯函数。因为不产生任何副作用，\n因此使用纯函数可以在下面几点上得到提高：</p>\n\n<ul>\n<li>易于测试</li>\n<li>正确性</li>\n<li>可读性</li>\n</ul>\n\n<p>因为不存在副作用，所以就不会产生意外的情况，因此我们编写的代码就如我们所预期的那样工作。同时，我们的代码\n不会带来过多的认知负担，因此这些代码将简单易懂，易于维护。</p>\n\n<pre><code>using static System.Console;\n \ninternal class TestPureFunctions\n{\n    private const string A = \"a\";\n    private const string B = \"b\";\n    private const string AB = \"ab\";\n    private const string ABAB = \"ab\";\n \n    internal static void Run()\n    {\n        var ab = Join(A, B);\n        // We can expect the same result always\n        // if we pass the same parameters\n        WriteLine(ab == AB);\n        WriteLine(Join(A, B) == AB);\n \n        var abab = Join(AB, AB);\n        // This also has an impact\n        // on Referential Transparency\n        WriteLine(abab == ABAB);\n        WriteLine(Join(AB, AB) == ABAB);\n    }\n \n    private static string Join(string lhs, string rhs)\n        =&gt; $\"{lhs}{rhs}\";\n}</code></pre>\n\n<h2>副作用</h2>\n\n<p>为了能让副作用这个定义更加清晰，就需要明确的定义什么是副作用，如果一个函数产生了副作用，那么它的行为将会符合下面任意一项：</p>\n\n<ul>\n<li>更改了全局的状态，在这里“全局”代表任何该函数作用域以外的状态。例如一个实例的私有数据域就被认为是全局的，因为它可以被该实例类的所有函数进行修改。</li>\n<li>更改了传入参数，这经常发生在参数为对象的时候，函数修改了对象中的数据域</li>\n<li>抛出了异常</li>\n<li>进行了IO操作，包括任何应用和外部世界进行交互的行为，对console，文件系统或者数据库的读写操作，以及和其它进程进行交互。</li>\n</ul>\n\n<pre><code>using static System.Console;\n \ninternal class TestSideEffects\n{\n    internal static void Run()\n    {\n        var ab = JoinWithLogs(\"a\", \"b\");\n        var abab = JoinWithLogs(ab, ab);\n \n        WriteLine(ab);\n        WriteLine(abab);\n    }\n \n    private static string JoinWithLogs(string lhs, string rhs)\n    {\n        // Here we have the side effect of writing to console\n        // but it could be any I/O operation.\n        WriteLine($\"lhs before: {lhs}\");\n        WriteLine($\"rhs before: {rhs}\");\n \n        var result = $\"{lhs}{rhs}\";\n \n        WriteLine($\"result: {result}\");\n        return result;\n    }\n}</code></pre>\n\n<h2>不可变性</h2>\n\n<p>在OOP或者FP中，不可以变对象（不改变的对象）是一种从对象被创建后就不会再发生改变的一种对象。\n在C#中，我们可以使用<code>Nuget</code>中的包去强化这个特性。并且我们可以使用下面这些做法来完成不可变。</p>\n\n<pre><code>using System.Collections.Generic;\nusing System.Collections.Immutable; // Nuget package\nusing System.Linq;\nusing static System.Console;\n \ninternal static class TestImmutability\n{\n    // readonly fields are immutable\n    // once they are initialized. at run-time\n    private static readonly string dashes = new string('-', 50);\n    private static readonly IEnumerable&lt;int&gt; numbers = Enumerable.Range(1, int.MaxValue);\n \n    // const fields are immutable as well. at compile-time\n    private const int Ten = 10;\n    private const int Six = 6;\n    private const int Three = 3;\n \n    internal static void Run()\n    {\n        List();\n        Stack();\n        Queue();\n    }\n \n    private static void List()\n    {\n        Separator(\"Immutable List\");\n \n        var list = ImmutableList&lt;int&gt;.Empty;\n        Action&lt;int&gt; listAdder = number =&gt; list = list.Add(number * Ten);\n \n        numbers\n            .Skip(100)\n            .Take(10)\n            .AddTo(listAdder);\n \n        list.PrintToConsole();\n    }\n \n    private static void Stack()\n    {\n        Separator(\"Immutable Stack\");\n \n        var stack = ImmutableStack&lt;int&gt;.Empty;\n        Action&lt;int&gt; stackAdder = number =&gt; stack = stack.Push(number * Six);\n \n        numbers\n            .SkipWhile(n =&gt; n &lt; 200)\n            .TakeWhile(n =&gt; n &lt; 220)\n            .Where(n =&gt; n % 3 == 0)\n            .AddTo(stackAdder);\n \n        stack.PrintToConsole();\n    }\n \n    private static void Queue()\n    {\n        Separator(\"Immutable Queue\");\n \n        var queue = ImmutableQueue&lt;int&gt;.Empty;\n        Action&lt;int&gt; queueAdder = number =&gt; queue = queue.Enqueue(number * Three);\n \n        numbers\n            .SkipWhile(n =&gt; n &lt; 1000)\n            .TakeWhile(n =&gt; n &lt; 1011)\n            .Where(n =&gt; n % 2 == 0)\n            .AddTo(queueAdder);\n \n        queue.PrintToConsole();\n    }\n \n    private static void AddTo&lt;T&gt;(this IEnumerable&lt;T&gt; items, Action&lt;T&gt; addToOtherCollection)\n    {\n        foreach (var item in items)\n            addToOtherCollection(item);\n    }\n \n    private static void PrintToConsole&lt;T&gt;(this IEnumerable&lt;T&gt; items)\n    {\n        foreach (var item in items)\n            WriteLine(item);\n    }\n \n    private static void Separator(this string text)\n    {\n        WriteLine(dashes);\n        WriteLine(text);\n        WriteLine(dashes);\n    }\n}</code></pre>\n\n<h2>函数的元</h2>\n\n<p>从逻辑，数学和计算机科学的角度来说，函数的元就是函数的可以接受的参数的个数。</p>\n\n<ul>\n<li>Nullary 不使用参数</li>\n<li>Unary 使用单参数</li>\n<li>Binary 使用两个参数</li>\n<li>Ternary 使用三个参数</li>\n<li>n-ary 使用n个参数</li>\n</ul>\n\n<pre><code>\nusing System.Linq;\nusing static System.Console;\n \ninternal class TestArity\n{\n    internal static void Run()\n    {\n        WriteLine(Nullary());\n        WriteLine(Unary(1));\n        WriteLine(Binary(1, 2));\n        WriteLine(Ternary(1, 2, 3));\n        WriteLine(N_Ary(1, 2, 3, 4));\n        WriteLine(N_Ary(Enumerable.Range(1, 16).ToArray()));\n        WriteLine(N_Ary(Enumerable.Range(1, 100).ToArray()));\n    }\n \n    private static string Nullary()\n        =&gt; \"No arguments\";\n \n    private static string Unary(int one)\n        =&gt; $\"One argument: {one}\";\n \n    private static string Binary(int one, int two)\n        =&gt; $\"Two arguments: {one} and {two}\";\n \n    private static string Ternary(int one, int two, int three)\n        =&gt; $\"Three arguments: {one}, {two} and {three}\";\n \n    private static string N_Ary(params int[] arguments)\n        =&gt; $\"N arguments: {arguments.Length}\";\n}\n</code></pre>\n\n<h2>引用透明</h2>\n\n<p>在函数编程语言中，引用透明一般定义为程序中的一个表达式，可以被它的值（或任何具备相同值的表达式或者值）取代，而不改变程序的结果。\n这就代表着，程序中的方法，在给定的参数下，不会产生额外的作用，总会返回相同的值。\n这些函数式编程的理念，同样可以应用到过程式编程语言中，这些理念会使代码更加的清晰。</p>\n\n<pre><code>using static System.Console;\n \ninternal class TestReferentialTransparency\n{\n    private const int Two = 2;\n    private const int Nine = 9;\n    private const int Sixteen = 16;\n    private const int Eighteen = 18;\n \n    internal static void Run()\n    {\n        OperationsWithReferentialTransparency();\n        OperationsWithoutReferentialTransparency();\n    }\n \n    private static void OperationsWithReferentialTransparency()\n    {\n        // YES - Sum(16, 2) == 18 and Mul(9, 2) == 18\n        // and the result of the program will be the same\n        var sum = Sum(Sixteen, Two) == Eighteen;\n        var mul = Mul(Nine, Two) == Eighteen;\n    }\n \n    private static void OperationsWithoutReferentialTransparency()\n    {\n        // NO - Sum(16, 2) == 18 and Mul(9, 2) == 18\n        // but WE ARE NOT logging to the console the result\n        var sum = SumLog(Sixteen, Two) == Eighteen;\n        var mul = MulLog(Nine, Two) == Eighteen;\n    }\n \n    private static int Sum(int a, int b) =&gt; a + b;\n \n    private static int Mul(int a, int b) =&gt; a * b;\n \n    private static int SumLog(int a, int b)\n    {\n        var result = a + b;\n        WriteLine($\"Returning {result}\");\n        return result;\n    }\n \n    private static int MulLog(int a, int b)\n    {\n        var result = a * b;\n        WriteLine($\"Returning {result}\");\n        return result;\n    }\n}</code></pre>\n\n<h2>Delegates</h2>\n\n<p>Delegates是C#中最常见的第一等公民，非常常见，也非常常用。</p>\n\n<pre><code>using System;\nusing System.Diagnostics;\n\ninternal static class TestDelegates\n{\n    // string -&gt; ()\n    private delegate void LoggerDelegate(string message);\n    // string -&gt; string\n    private delegate string LoggerWithResponseDelegate(string message);\n\n    internal static void Run()\n    {\n        RunVoidDelegates();\n        RunResponseDelegates();\n    }\n\n    private static void RunVoidDelegates()\n    {\n        LoggerDelegate consoleLoggerHandler = ConsoleLogger;\n        LoggerDelegate debugLoggerHandler = DebugLogger;\n        LoggerDelegate allConsoleHandlers = consoleLoggerHandler + debugLoggerHandler;\n\n        consoleLoggerHandler(\"This goes to the console\");\n        debugLoggerHandler(\"This goes to the debug\");\n        allConsoleHandlers(\"this goes to all\");\n    }\n\n    private static void RunResponseDelegates()\n    {\n        LoggerWithResponseDelegate consoleLoggerHandler = ConsoleLoggerWithResponse;\n        LoggerWithResponseDelegate debugLoggerHandler = DebugLoggerWithResponse;\n        LoggerWithResponseDelegate allConsoleHandlers = consoleLoggerHandler + debugLoggerHandler;\n\n        var consoleResponse = consoleLoggerHandler(\"This goes to the console\");\n        var debugResponse = debugLoggerHandler(\"This goes to the debug\");\n        var lastResponse = allConsoleHandlers(\"this goes to all\");\n    }\n\n    private static void ConsoleLogger(string message) =&gt; Console.WriteLine(message);\n\n    private static void DebugLogger(string message) =&gt; Debug.WriteLine(message);\n\n    private static string ConsoleLoggerWithResponse(string message)\n    {\n        Console.WriteLine(message);\n        return \"Logged to console\";\n    }\n\n    private static string DebugLoggerWithResponse(string message)\n    {\n        Debug.WriteLine(message);\n        return \"Logged to debug\";\n    }\n}</code></pre>\n\n<h2>Actions</h2>\n\n<p>Actions是.NET Framework 为我们提供创建delegates的语法糖。Actions从来都不会返回值，因为Actions总是返回void，并且Actions最多可以接受16个值作为参数。\n需要注意以下两点</p>\n\n<ul>\n<li>在FP中void返回类型被称为unit</li>\n<li>在箭头符号中unit被解释为()</li>\n</ul>\n\n<pre><code>using System;\nusing System.Diagnostics;\n\ninternal static class TestActions\n{\n    internal static void Run()\n    {\n        // string -&gt; ()\n        Action&lt;string&gt; consoleLoggerHandler = ConsoleLogger;\n        Action&lt;string&gt; debugLoggerHandler = DebugLogger;\n        Action&lt;string&gt; allConsoleHandlers = consoleLoggerHandler + debugLoggerHandler;\n\n        consoleLoggerHandler(\"This goes to the console\");\n        debugLoggerHandler(\"This goes to the debug\");\n        allConsoleHandlers(\"this goes to all\");\n    }\n\n    private static void ConsoleLogger(string message) =&gt; Console.WriteLine(message);\n\n    private static void DebugLogger(string message) =&gt; Debug.WriteLine(message);\n}\n</code></pre>\n\n<h2>Funcs</h2>\n\n<p>Funcs是.NET Framework 为我们提供创建delegates的另一个语法糖。但是Funcs并没有固定返回类型，同样Funcs也可以接受16个值作为参数。\nFuncs和Actions之间最大的不同，Funcs的最后一个参数代表这函数的返回类型。</p>\n\n<pre><code>using System;\nusing System.Diagnostics;\n\ninternal static class TestFuncs\n{\n    internal static void Run()\n    {\n        // string -&gt; string\n        Func&lt;string, string&gt; consoleLoggerHandler = ConsoleLogger;\n        Func&lt;string, string&gt; debugLoggerHandler = DebugLogger;\n        Func&lt;string, string&gt; allConsoleHandlers = consoleLoggerHandler + debugLoggerHandler;\n\n        var consoleResponse = consoleLoggerHandler(\"This goes to the console\");\n        var debugResponse = debugLoggerHandler(\"This goes to the debug\");\n        var lastResponse = allConsoleHandlers(\"this goes to all\");\n    }\n\n    private static string ConsoleLogger(string message)\n    {\n        Console.WriteLine(message);\n        return \"Logged to console\";\n    }\n\n    private static string DebugLogger(string message)\n    {\n        Debug.WriteLine(message);\n        return \"Logged to debug\";\n    }\n}</code></pre>\n\n<h2>科里化函数</h2>\n\n<p>科里化函数是以伟大数学家Haskell Curry命名的。科里化过程，是将一个接收t1，t2，&hellip;&hellip;，为参数的n元函数f转化成一个接收t1作为参数并返回一个接收t2作为参数的1元函数，一直到n-1个参数为止。\n只要所有的参数都被传入，最终返回的结果和函数f的结果是相同的。换句化说，一个具有下面签名的n元函数</p>\n\n<p><code>(T1, T2, …, Tn) → R</code></p>\n\n<p>进行科里化之后，可以得到下面的函数签名</p>\n\n<p><code>(T1) (T2) … (Tn) → R</code></p>\n\n<p>就这个技术自身而言，并没有什么实际的意义，但是科里化是偏函数应用的基础。</p>\n\n<pre><code>using System;\nusing static System.Console;\n\ninternal class TestCurriedFunctions\n{\n    internal static void Run()\n    {\n        WriteLine(Greeter(\"Hello\")(\"World\"));\n        WriteLine(Sum(5)(18));\n    }\n\n    private static Func&lt;string, Func&lt;string, string&gt;&gt; Greeter =&gt;\n        (firstName) =&gt; (lastName) =&gt; $\"{firstName} {lastName}\";\n\n    private static Func&lt;int, Func&lt;int, int&gt;&gt; Sum =&gt;\n        (lhs) =&gt; (rhs) =&gt; lhs + rhs;\n}</code></pre>\n\n<h2>偏函数应用</h2>\n\n<p>为函数提供少于它所需要的参数的数量时，我们称之为偏函数应用。为了能让函数更加抽象从而能更好的重用，就需要一种机制去给函数预置一些参数。\n偏函数应用，就是一种高元函数（一个接收多个参数多函数）转化成多个接收少量参数的函数的方法。</p>\n\n<pre><code>using System;\nusing static System.Console;\n\ninternal class TestPartialApplication\n{\n    internal static void Run()\n    {\n        WriteLine(MaleFormalGreeter(\"World\"));\n        WriteLine(FemaleFormalGreeter(\"World\"));\n        WriteLine(PlusFive(5));\n        WriteLine(PlusFive(18));\n    }\n\n    private static Func&lt;string, Func&lt;string, string&gt;&gt; Greeter =&gt;\n        (firstName) =&gt; (lastName) =&gt; $\"{firstName} {lastName}\";\n\n    private static Func&lt;string, string&gt; MaleFormalGreeter =&gt;\n        (lastName) =&gt; Greeter(\"Mr.\")(lastName);\n\n    private static Func&lt;string, string&gt; FemaleFormalGreeter =&gt;\n        (lastName) =&gt; Greeter(\"Ms.\")(lastName);\n\n    private static Func&lt;int, Func&lt;int, int&gt;&gt; Sum =&gt;\n        (lhs) =&gt; (rhs) =&gt; lhs + rhs;\n\n    private static Func&lt;int, int&gt; PlusFive =&gt;\n        (factor) =&gt; Sum(factor)(5);\n}</code></pre>\n\n<h2>惰性计算/延迟执行</h2>\n\n<p>在计算过程中惰性，代表一个表达式会被延迟到需要它的值的时候才会被进行求职。\n它的好处就是，如果一个表达式的代价很大，并且它并不是每次都必须计算的，按需计算就会产生更小的代价。</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\n\ninternal class TestLazyEvaluation\n{\n    private static IEnumerable&lt;int&gt; LazyNumbers\n    {\n        get\n        {\n            yield return 1;\n            yield return 2;\n            yield return 3;\n            yield return 4;\n            yield return 5;\n            yield return 6;\n            yield return 7;\n            yield return 8;\n            yield return 9;\n            yield return 10;\n        }\n    }\n\n    internal static void Run()\n    {\n        LazinessWithFunctions();\n        LazinessWithEnumerators();\n    }\n\n    private static void LazinessWithFunctions()\n    {\n        var random = new Random();\n        Func&lt;bool&gt; isLessThanZeroPointFive = () =&gt; random.NextDouble() &lt; 0.5;\n        Func&lt;int&gt; left = () =&gt; 23;\n        Func&lt;int&gt; right = () =&gt; 42;\n        Func&lt;int&gt; lazyExecuted = () =&gt; isLessThanZeroPointFive()\n            ? left()\n            : right();\n\n        // all the previous code is evaluated\n        // until we call lazyExecuted function\n        WriteLine(lazyExecuted());\n    }\n\n    private static void LazinessWithEnumerators()\n    {\n        var skipFour = LazyNumbers.Skip(4);\n        var takeFour = skipFour.Take(4);\n\n        // all the previous code is evaluated\n        // until we enumerate the collection in a foreach\n        foreach (var number in takeFour)\n            WriteLine(number);\n    }\n}\n</code></pre>\n\n<h2>Extension Methods</h2>\n\n<p>扩展方法，可以让我们用新方法来扩展原有类型，但是无需派生新的类型，重新编译或者修改原有类型。</p>\n\n<ul>\n<li>它们只是静态类中的静态方法</li>\n<li>使用开放封闭原则</li>\n<li>可以使用方法链</li>\n</ul>\n\n<pre><code>using System;\nusing static System.Console;\n\ninternal class TestExtensionMethods\n{\n    internal static void Run()\n    {\n        var person = new Person(\"George\", 30);\n        WriteLine(person);\n        WriteLine($\"Days lived from person object {person.DaysLived()}\");\n        WriteLine($\"Days lived from Age property {person.Age.DaysLived()}\");\n    }\n}\n\ninternal class Person\n{\n    internal string Name { get; }\n    internal int Age { get; }\n\n    internal Person(string name, int age)\n    {\n        Name = name;\n        Age = age;\n    }\n\n    public override string ToString() =&gt; $\"My name is {Name} and I am {Age} years old\";\n}\n\ninternal static class PersonExtensions\n{\n    internal static int DaysLived(this Person person) =&gt;\n        person.Age * 365;\n\n    internal static int DaysLived(this int age) =&gt; age * 365;\n}</code></pre>\n\n<h2>智能构造函数</h2>\n\n<p>智能构造函数是只生成所需类型的值的函数。 但是，在构造值时，它会执行一些额外的检查。 \n在这种情况下，实用的方案是将引用类型的构造函数设置为私有化，同时公开一个实例化的函数。</p>\n\n<pre><code>using System;\nusing static System.Console;\n\ninternal class TestSmartConstructors\n{\n    internal static void Run()\n    {\n        HappyPath();\n        InvalidName();\n        InvalidAge();\n    }\n\n    private static void HappyPath()\n    {\n        var person = SmartPerson.Create(\"George\", 30);\n        WriteLine($\"Valid person data so all goes well and we can print {person}\");\n    }\n\n    private static void InvalidName()\n    {\n        try\n        {\n            var person = SmartPerson.Create(null, 30);\n        }\n        catch (ArgumentNullException ex)\n        {\n            WriteLine($\"{ex.Message}\");\n        }\n    }\n\n    private static void InvalidAge()\n    {\n        try\n        {\n            var person = SmartPerson.Create(\"George\", -1);\n        }\n        catch (ArgumentOutOfRangeException ex)\n        {\n            WriteLine($\"{ex.Message}\");\n        }\n    }\n}\n\ninternal class SmartPerson\n{\n    internal string Name { get; }\n    internal int Age { get; }\n\n    private SmartPerson(string name, int age) =&gt;\n        (Name, Age) = (name, age);\n\n    internal static SmartPerson Create(string name, int age)\n    {\n        GuardName(name);\n        GuardAge(age);\n\n        return new SmartPerson(name, age);\n    }\n\n    private static void GuardName(string name)\n    {\n        if (string.IsNullOrWhiteSpace(name))\n            throw new ArgumentNullException(nameof(name), \"Name can't be null, empty or white spaces\");\n    }\n\n    private static void GuardAge(int age)\n    {\n        if (age &lt; 0 || age &gt; 120)\n            throw new ArgumentOutOfRangeException(nameof(age), \"Age is not in valid range\");\n    }\n\n    public override string ToString() =&gt; $\"My name is {Name} and I am {Age} years old\";\n}</code></pre>\n\n<h2>避免过度使用原始数据类型</h2>\n\n<p>过度使用的原始数据类型包括：string，int，bool，double和datetime等来表示复杂的类型，例如一个人的年龄，姓名和邮件等。\n为了避免这些，我们应该创建更小的对象去表示它们，从而我们可以得到下面这些好处。</p>\n\n<ul>\n<li>所有的验证都在一处，带有智能构造函数的小类</li>\n<li>不可变</li>\n<li>自我检查</li>\n<li>深度值比较</li>\n</ul>\n\n<pre><code>using System;\nusing System.Text.RegularExpressions;\nusing static System.Console;\n\ninternal static class TestAvoidPrimitiveObsession\n{\n    internal static void Run()\n    {\n        HappyPathEmail();\n        InvalidEmail();\n        NullEmail();\n\n        HappyPathAge(); \n        InvalidAge();\n    }\n\n    internal static void HappyPathEmail()\n    {\n        var emailOne = Email.Create(\"test1@test.com\");\n        var emailTwo = Email.Create(\"test2@test.com\");\n        var emailThree = Email.Create(\"test1@test.com\");\n\n        // Implicit conversion using operators\n        string fromEmail = Email.Create(\"test3@test.com\");\n        Email fromString = \"test4@test.com\";\n\n        WriteLine($\"{emailOne} == {emailTwo} ? {(emailOne.Equals(emailTwo))}\");\n        WriteLine($\"{emailOne} == {emailThree} ? {(emailOne.Equals(emailThree))}\");\n    }\n\n    private static void InvalidEmail()\n    {\n        try\n        {\n            var email = Email.Create(\"test1@test\");\n        }\n        catch (ArgumentException ex)\n        {\n            WriteLine(ex.Message);\n        }\n    }\n\n    private static void NullEmail()\n    {\n        try\n        {\n            var email = Email.Create(null);\n        }\n        catch (ArgumentNullException ex)\n        {\n            WriteLine(ex.Message);\n        }\n    }\n\n    private static void HappyPathAge()\n    {\n        var ageOne = Age.Create(30);\n        var ageTwo =  Age.Create(25);\n        var ageThree = Age.Create(30);\n\n        // Implicit conversion using operators\n        int fromAge = Age.Create(20);\n        Age fromInt = 30;\n\n        WriteLine($\"{ageOne} == {ageTwo} ? {(ageOne.Equals(ageTwo))}\");\n        WriteLine($\"{ageOne} == {ageThree} ? {(ageOne.Equals(ageThree))}\");\n    }\n\n    private static void InvalidAge()\n    {\n        try\n        {\n            var age = Age.Create(130);\n        }\n        catch (ArgumentOutOfRangeException ex)\n        {\n            WriteLine(ex.Message);\n        }\n    }\n\n    private class Email\n    {\n        private readonly string value;\n\n        private Email(string value) =&gt; this.value = value;\n\n        internal static Email Create(string email)\n        {\n            GuardEmail(email);\n            return new Email(email);\n        }\n\n        private static void GuardEmail(string email)\n        {\n            if (email is null)\n                throw new ArgumentNullException(nameof(email), \"Email address cannot be null\");\n\n            var match = Regex.Match(\n                email,\n                Constants.EmailPattern,\n                RegexOptions.Compiled | RegexOptions.IgnoreCase);\n\n            if (!match.Success)\n                throw new ArgumentException(\"Invalid Email address format\", nameof(email));\n        }\n\n        public static implicit operator string(Email email) =&gt; email.value;\n\n        public static implicit operator Email(string email) =&gt; Create(email);\n\n        public override bool Equals(object obj)\n        {\n            var email = obj as Email;\n\n            if (ReferenceEquals(email, null))\n                return false;\n\n            return this.value == email.value;\n        }\n\n        public override int GetHashCode() =&gt; value.GetHashCode();\n\n        public override string ToString() =&gt; value;\n    }\n\n    private class Age\n    {\n        private readonly int value;\n\n        private Age(int value) =&gt; this.value = value;\n\n        internal static Age Create(int age)\n        {\n            GuardAge(age);\n            return new Age(age);\n        }\n\n        private static void GuardAge(int age)\n        {\n            if (age &lt; 0 || age &gt; 120)\n                throw new ArgumentOutOfRangeException(nameof(age), \"Age is not in valid range\");\n        }\n\n        public static implicit operator int(Age age) =&gt; age.value;\n\n        public static implicit operator Age(int age) =&gt; Create(age);\n\n        public override bool Equals(object obj)\n        {\n            var age = obj as Age;\n\n            if (ReferenceEquals(age, null))\n                return false;\n\n            return this.value == age.value;\n        }\n\n        public override int GetHashCode() =&gt; value.GetHashCode();\n\n        public override string ToString() =&gt; $\"{value}\";\n    }\n\n    private static class Constants\n    {\n        internal static string EmailPattern =&gt; @\"^\\w+([-+.']\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\";\n    }\n}</code></pre>\n\n<h2>范化</h2>\n\n<p>范型可以让我们使用占位符去定义一个类，这些占位符可以是类的域，方法参数等。\n在编译的时候，范化会用特定的类型代替这些占位符。</p>\n\n<ul>\n<li>让代码重用度更高，具备类型安全和提升性能</li>\n<li>它通常被用来创建集合类型的类</li>\n<li>通过约束条件来限制类型的范围</li>\n</ul>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing static System.Console;\n\ninternal static class TestGenerics\n{\n    internal static void Run()\n    {\n         CreateGenerics();\n         CreateGenericsWithConstraints();\n    }\n\n    private static void CreateGenerics()\n    {\n        new List&lt;object&gt;\n        {\n            Generic&lt;int&gt;.Create(42),\n            Generic&lt;long&gt;.Create(42L),\n            Generic&lt;float&gt;.Create(42.5F),\n            Generic&lt;double&gt;.Create(42D),\n            Generic&lt;decimal&gt;.Create(42.5M),\n            Generic&lt;bool&gt;.Create(false),\n            Generic&lt;DateTime&gt;.Create(DateTime.Now),\n            Generic&lt;byte&gt;.Create(0x0042),\n            Generic&lt;char&gt;.Create('A'),\n            Generic&lt;string&gt;.Create(\"George\"),\n            Generic&lt;Func&lt;int, int&gt;&gt;.Create(x =&gt; x + x),\n            Generic&lt;Action&lt;int, int&gt;&gt;.Create((x, y) =&gt; WriteLine(x + y)),\n            Generic&lt;dynamic&gt;.Create(7.5F + 35L),\n            Generic&lt;object&gt;.Create(new { a = 42 })\n        }\n        .ForEach(WriteLine);\n    }\n\n    private static void CreateGenericsWithConstraints()\n    {\n        new List&lt;object&gt;\n        {\n            GenericWithConstraints&lt;int, object&gt;.Create(42, new { A = 42 }),\n            GenericWithConstraints&lt;long, object&gt;.Create(42L, new { B = 42L }),\n            GenericWithConstraints&lt;float, object&gt;.Create(42F, new { C = 42F }),\n            GenericWithConstraints&lt;double, object&gt;.Create(42D, new { D = 42D }),\n            GenericWithConstraints&lt;decimal, object&gt;.Create(42M, new { E = 42M }),\n            GenericWithConstraints&lt;bool, object&gt;.Create(true, new { F = true }),\n            GenericWithConstraints&lt;DateTime, object&gt;.Create(DateTime.Now, new { G = DateTime.Now }),\n            GenericWithConstraints&lt;byte, object&gt;.Create(0x0042, new { H = 0x0042 }),\n            GenericWithConstraints&lt;char, object&gt;.Create('J', new { I = 'J' })\n        }\n        .ForEach(WriteLine);\n    }\n\n    private class Generic&lt;T&gt;\n    {\n        private T GenericReadOnlyProperty { get; }\n\n        private Generic(T genericArgument) =&gt; GenericReadOnlyProperty = genericArgument;\n\n        internal static Generic&lt;T&gt; Create(T genericValue) =&gt; new Generic&lt;T&gt;(genericValue);\n\n        public override string ToString() =&gt; $\"{GenericReadOnlyProperty} - {typeof(T)}\";\n    }\n\n    private class GenericWithConstraints&lt;T, U&gt;\n        where T : struct\n        where U : new()\n    {\n        private T @Struct { get; }\n\n        private U @Object { get; }\n\n        private GenericWithConstraints(T @struct, U @object) =&gt;\n            (@Struct, @Object) = (@struct, @object);\n\n        internal static GenericWithConstraints&lt;T, U&gt; Create(T @struct, U @object) =&gt;\n            new GenericWithConstraints&lt;T, U&gt;(@struct, @object);\n\n        public override string ToString() =&gt;\n            $\"{@Struct} - {typeof(T)} && {@Object} - {typeof(U)} \";\n    }\n}</code></pre>\n\n<h2>LINQ</h2>\n\n<p>LINQ代表着Language INtegrated Query。它是一个功能强大的函数库，提供了很多lists或者说更泛化“序列”类型的常见操作。\n只要是<code>IEnumerable</code>类型的实例，它们都可以作为LINQ的使用对象。在LINQ中最常用的操作是mapping, sorting,和 filtering。</p>\n\n<ul>\n<li>使用高阶函数作为它的参数，让LINQ具备了更强的扩展性</li>\n<li>LINQ中可以使用方法语法或者查询语法</li>\n</ul>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\n\ninternal static class TestLINQ\n{\n    private static readonly string Dashes = new string('-', 40);\n\n    private static readonly IEnumerable&lt;char&gt; Alphabet = Enumerable\n        .Range('a', 'z' - 'a' + 1)\n        .Select(i =&gt; (Char)i);\n\n    private static readonly IEnumerable&lt;int&gt; LazyNumbers = Enumerable.Range(0, 50);\n\n    private static IEnumerable&lt;IEnumerable&lt;int&gt;&gt; NestedLazyNumbers\n    {\n        get\n        {\n            yield return LazyNumbers;\n            yield return LazyNumbers;\n        }\n    }\n\n    internal static void Run()\n    {\n        Map();\n        Filter();\n        Zip();\n        Take();\n        Skip();\n        TakeWhile();\n        SkipWhile();\n        OrderBy();\n        OrderByDescending();\n        FoldRight();\n        FoldLeft();\n        Bind();\n    }\n\n    private static void Map()\n    {\n        LazyNumbers\n            .Select(number =&gt; number * 10)\n            .Print(nameof(Map));\n    }\n\n    private static void Filter()\n    {\n        LazyNumbers\n            .Where(number =&gt; number &gt; 5)\n            .Print(nameof(Filter));\n    }\n\n    private static void Zip()\n    {\n        LazyNumbers\n            .Zip(Alphabet, (number, letter) =&gt; $\"{number} --&gt; {letter}\")\n            .Print(nameof(Zip));\n    }\n\n    private static void Take()\n    {\n        LazyNumbers\n            .Take(10)\n            .Print(nameof(Take));\n    }\n\n    private static void Skip()\n    {\n        LazyNumbers\n            .Skip(40)\n            .Print(nameof(Skip));\n    }\n\n    private static void TakeWhile()\n    {\n        LazyNumbers\n            .TakeWhile(number =&gt; number &lt; 10)\n            .Print(nameof(TakeWhile));\n    }\n\n    private static void SkipWhile()\n    {\n        LazyNumbers\n            .SkipWhile(number =&gt; number &lt; 40)\n            .Print(nameof(SkipWhile));\n    }\n\n    private static void OrderBy()\n    {\n        LazyNumbers\n            .OrderBy(number =&gt; number)\n            .Print(nameof(OrderBy));\n    }\n\n    private static void OrderByDescending()\n    {\n        LazyNumbers\n            .OrderByDescending(number =&gt; number)\n            .Print(nameof(OrderByDescending));\n    }\n\n    private static void FoldRight()\n    {\n        LazyNumbers\n            .Take(10)\n            .Aggregate((accumulator, next) =&gt; accumulator + next)\n            .ToEnumerable()\n            .Print(nameof(FoldRight));\n    }\n\n    private static void FoldLeft()\n    {\n        LazyNumbers\n            .Skip(40)\n            .Reverse()\n            .Aggregate((accumulator, next) =&gt; accumulator - next)\n            .ToEnumerable()\n            .Print(nameof(FoldLeft));\n    }\n\n    private static void Bind()\n    {\n        NestedLazyNumbers\n            .SelectMany(innerEnumerable =&gt; innerEnumerable)\n            .OrderBy(number =&gt; number)\n            .Take(20)\n            .Print(nameof(Bind));\n    }\n\n    private static void Print&lt;TItem&gt;(this IEnumerable&lt;TItem&gt; items, string message)\n    {\n        var spaces = new string(' ', 31 - message.Length);\n        WriteLine($\"{Dashes} {message}{spaces}{Dashes}\");\n\n        foreach (var item in items)\n            WriteLine(item);\n    }\n\n    private static IEnumerable&lt;TItem&gt; ToEnumerable&lt;TItem&gt;(this TItem item)\n    {\n        yield return item;\n    }\n}\n</code></pre>\n\n<h2>总结</h2>\n\n<p>我希望这片文章能帮助读者理解一些FP方面的知识，并可以将它们应用到自己的项目中。从而提高项目的可读性，可测试性和软件的稳定性。请记住FP和OOP从来都不是对立的，它们是正交的，我们可以同时使用它们来完善我们的项目。</p>\n","id":170259199962965534790105709951745455855,"intro":"介绍如何在C#中应用函数式的编程，并通过多个代码实例来阐述我们应该如何将函数编程的理念应用到实际项目中。","published":true,"published_at":63738435150,"title":"在C#中应用的函数式编程概念","topic_id":1},{"content":"<h2>什么是XMPP</h2>\n\n<p>XMPP（可扩展消息处理现场协议）是基于可扩展标记语言（XML）的协议，它用于即时消息（IM）以及在线通讯的相关场景。XMPP已被IETF国际标准组织完成了标准化工作。标准化的核心结果分为两部分； 核心的XML流传输协议和基于XML流传输的即时通讯扩展。应用XMPP的核心XML流传输协议的定义使得XMPP能够在一个比以往网络通信协议更规范的平台上。借助于XML易于解析和阅读的特性，使得XMPP的协议能够非常容易被理解和调试。XMPP的即时通讯扩展应用部分是根据IETF在这之前对即时通讯的一个抽象定义的，与其他业已得到广泛使用的即时通讯协议，诸如AIM，QQ等相比，XMPP更加开放，更容易扩展并且天生就具有分布式特性。</p>\n\n<p>由于XMPP协议是一个开源形式组织产生的网络即时通信协议，它的协议内容是开放的，任何人和组织都可以实现该协议，同时XMPP协议还非常强调各不同组织之间的服务器通信和互操作性，这让各个组织之间的消息互通不再是难题了。</p>\n\n<h2>XMPP的历史</h2>\n\n<p>1999年1月，Jeremie Miller发布了Jabber协议，这是一个开放的且基于实时XML流的传输协议。同年，Jeremie Miller向Jabber社区提交了一个声明，承诺Jabber社区会支持IEEE的标准化，其中包含了Jabber项目的目标：支持开放的协议并且支持即时通信的互操作性。\n2000年与2001年，IEEE在推进IMPP，而Jabber社区则不断的在实现开放标准，并编写文档和完善协议。\n2002年，XMPP工作组成立，并开始完善协议。\n2003年及以后，就是我们所知道的，XMPP不断的发展壮大。</p>\n\n<p>我们可以从这里看出，XMPP是一个非常有历史的协议，并且XMPP也经过了大量的实战检验。当然，在XMPP的发展中，不单单有Jeremie Miller全身心投入，更有Google的大量推广。我们所周知的GTalk和GMail中的实时聊天都是基于XMPP协议的。</p>\n\n<h2>XMPP能做什么</h2>\n\n<p>虽然我们因为即时通信（IM）对XMPP有了了解，但是XMPP协议不局限于即时通音（IM）。因为XMPP在协议制定支出着眼点很高，我们可以在XMPP的协议上大量扩展功能。其中包括，但不限于：</p>\n\n<ol>\n<li>Jabber-RPC</li>\n<li>VPN</li>\n<li>IOT</li>\n</ol>\n\n<h2>XMPP服务器</h2>\n\n<ol>\n<li>eJabberd Erlang开发的高性能服务器。</li>\n<li>MongooseIM 在eJabberd的基础上进行二次开发，提供很多方便使用且非常高性能的服务器。</li>\n<li>Openfire Java开发的也比较常用的一款服务器，但是性能一般般。</li>\n<li>Prosody IM Lua开发的，不是很常见，据说非常轻量级。</li>\n</ol>\n","id":238401758728233480049775933748814459752,"intro":"什么是XMPP，XMPP的历史，以及XMPP常见服务器和能做什么","published":true,"published_at":63734916122,"title":"什么是 XMPP","topic_id":1},{"content":"<h2>Jabber组件协议</h2>\n\n<p>前面关于<a href=\"https://www.ttalk.im/topics/49\" >IQ处理</a>的文章中，提到过，可以通过增加IQ处理器来扩展eJabberd。但是这对很多不懂Erlang的同学造成了很大困扰。但是XMPP已经充分考虑到eJabberd作为总线的可能性，因此设计了Jabber组件协议。</p>\n\n<h3>简介</h3>\n\n<p>传统上有两种完全不同的服务器端组件类型：内部组件（ 利用服务器的内部API提供服务）和外部组件（组件在一个协议框架上与服务器联系，因此不依赖任何特定的服务器实现）。<br/>\n目前使用的组件协议框架使得一个外部组件能够连接到一个服务器（通过适当的配置和验证）并能通过服务器发送和接收XML节。有两种连接方法：“accept”和“connect”。使用“accept”方法时，服务器等待并接受被组件初始化的连接。使用“connect”方法时，由服务器初始化到组件的连接。在实际的使用中，“accept”方法更为常用。</p>\n\n<h2>eJabberd中外部组件处理</h2>\n\n<h3>接入处理</h3>\n\n<p>eJabberd是通过ejabberd_service来实现的Jabberd组件协议。在eJabberd启动的时候，会启动一个有别于ejabberd_c2s所监听的XML流端口进行监听，因为jabber组件的XML流处理和eJabberd_c2s的流处理方式完全不同。</p>\n\n<p>组件为了将自己注册到XMPP服务器上，需要和XMPP服务器进行下面交互\r\n``` XML\r\n组件向服务器发送消息\r\n<stream:stream\r\n    xmlns='jabber:component:accept'\r\n    xmlns:stream='http://etherx.jabber.org/streams'\r\n    to='plays.shakespeare.lit'></p>\n\n<p>服务器会回应下面的消息\r\n<stream:stream\r\n    xmlns:stream='http://etherx.jabber.org/streams'\r\n    xmlns='jabber:component:accept'\r\n    from='plays.shakespeare.lit'\r\n    id='3BF96D32'></p>\n\n<p>接着组件要给服务器发送handshake</p>\n\n<p><handshake>aaee83c26aeeafcbabeabfcbcd50df997e0a2a1e</handshake></p>\n\n<p>服务器需要给组件回复一个空的handshake来表示确认\r\n<handshake/>\r\n```</p>\n\n<h3>ejabberd_service模块</h3>\n\n<p>ejabberd_service的基本流程和ejabebrd_c2s进程是相似的，其中重点是wait_for_handshake的处理，这个函数内会验证handshake中的hash，并将自己注册到路由表的组件相关的表。在注册的过程，会默认注册本地和全集群路由。</p>\n\n<pre><code><span class=\"code\">\r\n<span class=\"function\">wait_for_handshake</span><span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">xmlstreamelement, <span class=\"variable\">El</span></span>}</span>, <span class=\"variable\">StateData</span></span>)</span> -&gt;\r\n    #xmlel<span class=\"paren1\">{<span class=\"code\">name = <span class=\"variable\">Name</span>, children = <span class=\"variable\">Els</span></span>}</span> = <span class=\"variable\">El</span>,\r\n    <span class=\"symbol\">case</span> <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Name</span>, xml:get_cdata<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">Els</span></span>)</span></span>}</span> <span class=\"symbol\">of</span>\r\n        <span class=\"paren1\">{<span class=\"code\">&lt;&lt;<span class=\"string\">\"handshake\"</span>&gt;&gt;, <span class=\"variable\">Digest</span></span>}</span> -&gt;\r\n            <span class=\"symbol\">case</span> sha:sha1_hex<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">StateData#state</span>.streamid ++\r\n                         <span class=\"variable\">StateData#state</span>.password</span>)</span> <span class=\"symbol\">of</span>\r\n                <span class=\"variable\">Digest</span> -&gt;\r\n                    <span class=\"comment\">%% 如果handleshake的认证成功了\r\n</span>                    <span class=\"comment\">%% 就注册路由信息\r\n</span>                    <span class=\"comment\">%% 这里面注册的路由和普通的路由是不同的\r\n</span>                    <span class=\"symbol\">case</span> register_routes<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">StateData</span></span>)</span> <span class=\"symbol\">of</span>\r\n                        ok -&gt;\r\n                            send_text<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">StateData</span>, &lt;&lt;<span class=\"string\">\"&lt;handshake/&gt;\"</span>&gt;&gt;</span>)</span>,\r\n                            <span class=\"paren1\">{<span class=\"code\">next_state, stream_established, <span class=\"variable\">StateData</span></span>}</span>;\r\n                        <span class=\"paren1\">{<span class=\"code\">error, <span class=\"variable\">Reason</span></span>}</span> -&gt;\r\n                            <span class=\"macro\">?ERROR_MSG(</span><span class=\"string\">\"Error in component handshake: ~p\"</span>, <span class=\"paren1\">[<span class=\"code\"><span class=\"variable\">Reason</span></span>]</span>),\r\n                            send_text<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">StateData</span>, <span class=\"macro\">?CONFLICT_ERR)</span>,\r\n                            <span class=\"paren2\">{<span class=\"code\">stop, normal, <span class=\"variable\">StateData</span></span>}</span>\r\n                    <span class=\"symbol\">end</span>;\r\n                <span class=\"variable\">_</span> -&gt;\r\n                    send_text<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">StateData</span>, <span class=\"macro\">?INVALID_HANDSHAKE_ERR)</span>,\r\n                    <span class=\"paren3\">{<span class=\"code\">stop, normal, <span class=\"variable\">StateData</span></span>}</span>\r\n            <span class=\"symbol\">end</span>;\r\n        <span class=\"variable\">_</span> -&gt;\r\n            <span class=\"paren3\">{<span class=\"code\">next_state, wait_for_handshake, <span class=\"variable\">StateData</span></span>}</span>\r\n    <span class=\"symbol\">end</span>;\r\n</span></span></span></span></span></code></pre>\n\n<h3>处理业务</h3>\n\n<p>ejabberd_service是外部组件在服务器的代表，如同ejabberd_c2s一样自身并不处理相关业务，只是将数据转发给相应的外部组件。</p>\n\n<p>需要注意的是，由于ejabberd_service在路由中注册本节点内外部服务的时候，是使用mneisa的set，换句话一个外部服务同时只有一个可用，但是注册全集群的时候是使用mnesia的bag，也就是说如果本节点没相应的服务，会向全集群中任何一个有该该外部服务的节点转发消息。</p>\n\n<h2>总结</h2>\n\n<p>Jabber组件协议，已经将XMPP协议带离一个聊天服务器的范畴了，可以让研发人员不需要改动XMPP服务器就可以轻松扩展。尤其是eJabberd的优良实现，更是将这一特性发挥的非常好。在很多时候，eJabberd完全可以当作一个强大的消息总线来使用，再上面挂接各种服务。</p>\n","id":218327670550334463741373718888698002538,"intro":"XMPP","published":false,"published_at":63734916124,"title":"超级总线 eJabberd","topic_id":1},{"content":"<h2>Erlang函数</h2>\n\n<p>在上一篇教程中，我们介绍了Erlang的递归和模式匹配，其中就可以看到Erlang的函数是如何定义的。Erlang的函数有两类，一类是命名函数，另一类是匿名函数（高阶函数）。本篇将介绍命名函数，匿名函数（高阶函数）将会放在下一篇介绍。为了定义函数就需要先理解Erlang的一个基础类型原子。</p>\n\n<h2>Erlang的原子类型</h2>\n\n<p>Erlang虽然是一个动态类型的语言，但是Erlang中还是有类型定义的。原子类型就会Erlang的基础数据类型之一，Erlang的原子可以被认为是非常特殊的变量，它的字面含义就是它的值。Erlang原子语法要求是，小写字母开头的标识或者是使用单引号括（‘’）括起的子串。例如，atom，atom1，atom_n和‘This is an atom’都是合法的原子。</p>\n\n<p>虽然可以将原子认为是特殊的变量，但是原子毕竟不是变量。Erlang中原子的数量是有限的，一个原子一旦被定义直到Erlang虚拟机退出为止都不会被销毁。虽然这个数量是有限制的，但是可以在Erlang虚拟机启动的时候，通过+t这个参数去修改Erlang虚拟机中原子数量的上限。同时，需要注意的是，模块名称和函数名称都是原子。</p>\n\n<h2>命名函数语法</h2>\n\n<p>Erlang中定义命名函数的规则是这样的：原子类型的函数名，后面跟随着小括号，小括号内可以放置任意多个（不能多于255个）的变量或常量，这些变量和常量之间用逗号隔开，在括号后面放置&rarr;，在函数体的最后一个语句以句号结尾。下面就是一个最简答的例子：\r\n<code>erlang\r\ngreet(_, Name) -&gt;\r\n  io:format(&quot;Hello, ~s!&quot;, [Name]).\r\n</code>\r\n在上一篇的例子中，可以看到以分号尾的函数，这就是Erlang函数特点之一。Erlang可以使用以分号结束但具有相同名字和相同数量参数函数作为Erlang函数的分句，但是这些分句必须放在最终以句号结尾的函数前面，中间不能有任何不同名字和不同数量参数的函数分句或函数存在。如下面的例子：\r\n<code>erlang\r\ngreet(male, Name) -&gt;\r\n  io:format(&quot;Hello, Mr. ~s!&quot;, [Name]);\r\ngreet(female, Name) -&gt;\r\n  io:format(&quot;Hello, Mrs. ~s!&quot;, [Name]);\r\ngreet(_, Name) -&gt;\r\n  io:format(&quot;Hello, ~s!&quot;, [Name]).\r\n</code>\r\nErlang的函数的特点之二，同名函数只要参数数量不同，Erlang会认为是两个完全不同的函数。如下面的例子：\r\n<code>erlang\r\nfactorial(N) -&gt; factorial(N,1).\r\nfactorial(0,Acc) -&gt; Acc;\r\nfactorial(N,Acc) when N &gt; 0 -&gt; factorial(N-1,N*Acc).\r\n</code>\r\nErlang的函数的特点之三，函数哨位，可以在函数后面跟随一个逻辑判断语句，在函数执行函数体之前对传入的参数进行判断看是否符合函数体执行的条件。如下面的例子：\r\n<code>erlang\r\nage_can_drive(X) when X &gt;= 16, X =&lt; 104 -&gt;\r\n  true;\r\nage_can_drive(_) -&gt;\r\n  false.\r\n</code>\r\n但是需要注意的是，函数的哨位不但可以只用逻辑判断，还可以使用数学操作符和类型函数。但是可以使用的函数是有限制的，哨位中使用的函数是无法使用用户自定义的函数。</p>\n","id":140641247478381121593299137327199447206,"intro":"Erlang","published":false,"published_at":63734916126,"title":"Erlang 入门-命名函数","topic_id":1},{"content":"<h2>什么是CMS</h2>\n\n<p>CMS是&ldquo;Content Management System&rdquo;的缩写，意为&ldquo;内容管理系统&rdquo;，从字面的意思上就可以看出来，这套系统系统主要是用来管理内容的，同时将内容进行发布。内容管理系统是企业信息化建设，电子政务和自媒体所不可或缺的一套Web系统。</p>\n\n<h3>为什么会有CMS</h3>\n\n<p>随着网络内容的丰富和发展，很多时候在短时间内会发布大量的内容，常常需要花费许多时间、人力和物力来处理信息更新和维护工作，甚至会需要专业的程序员来完成整合。\r\n当遇到网站扩充的时候，整合内外网及分支网站的工作就变得更加复杂，甚至还需重新建设网站，这样大大的加重了网站的运营成本。\r\n因此人们希望从每个内容都需要复杂的设置才能发布的情况中解脱出来，从而产生了CMS。</p>\n\n<h3>CMS的特点</h3>\n\n<ul>\n<li>页面有序，网站风格统一</li>\n<li>信息分类明确，容易查找，容易管理</li>\n<li>上手容易，职责明确，程序员专注于系统设计，编辑专注于内容，运营人员专注于引流和SEO</li>\n<li>改版容易，只要改变内容模版，整站都统一发生百变。</li>\n<li>权限明确，可以针对会员和非会员开放不同页面</li>\n</ul>\n\n<h3>主流CMS</h3>\n\n<ul>\n<li>Wordpress</li>\n<li>Drupal</li>\n<li>Joomla</li>\n</ul>\n\n<h2>CMS特性分析</h2>\n\n<h3>Wordpress</h3>\n\n<ul>\n<li><p>优点\r\n整体设计思路为blog模式，非常容易安装和使用，有大量的站点主题，二次开发也较简单。</p></li>\n<li><p>缺点\r\n由于核心设计的局限，扩展到复杂的网站功能需要非常多的代码量，而同样的功能也许在drupal和joomla中已经由现成的模块了。</p></li>\n</ul>\n\n<h4>适用范围</h4>\n\n<ul>\n<li>无开发团队或小开发团队</li>\n<li>搭建个人网站</li>\n<li>个人blog</li>\n<li>小企业网站</li>\n<li>展示型网站</li>\n<li>中小型新闻类网站</li>\n</ul>\n\n<h3>Drupal</h3>\n\n<ul>\n<li><p>优点\r\n程序设计思路有别于大多数CMS，免费模块多，扩展灵活。</p></li>\n<li><p>缺点\r\n很多常用功能需要自己选择安装模块来实现，中文资料较少，开发难度比较大。</p></li>\n</ul>\n\n<h4>适用范围</h4>\n\n<ul>\n<li>有自己的开发小组或团队，团队中有前端工程师</li>\n<li>项目要求有很高的扩展性，未来的需求不明了</li>\n<li>高性能的要求站点</li>\n<li>大型新闻类网站</li>\n<li>大型展示类网站</li>\n</ul>\n\n<h3>Joomla</h3>\n\n<ul>\n<li><p>优点\r\n设计思路比较传统，容易理解，容易使用，容易安装，模块多，主题多并且很美观，中文资料多。</p></li>\n<li><p>缺点\r\n很多好主题和模块都是收费的，模块开发灵活度不高。</p></li>\n</ul>\n\n<h4>适用范围</h4>\n\n<ul>\n<li>网站目标明确</li>\n<li>快速搭建网站，有一定的预备投入资金</li>\n<li>不希望维持研发团队，但还想在可扩展的时候能得到商业支持</li>\n<li>传统企业中规模企业网站</li>\n<li>传统企业中规模展示网站</li>\n</ul>\n\n<h2>总结</h2>\n\n<p>Drupal更接近一个通用的Web应用程序框架，通过扩展开发可以实现几乎所有的网站需求，但是需要投入开发人员，适合有研发和编辑混合的小团队的自媒体使用。</p>\n\n<p>Joomla很成熟，虽然本身是开源免费，但是其模块和主题已经很商业化，使用这些商业模板和主题可以满足绝大部分企业网站或者电子商务网站的需求，适合大部分企业用户或非技术自媒体团队使用。</p>\n\n<p>Wordpress轻巧简约，能够满足常见的内容发布功能，搭建blog，展示型网站很敏捷，适合个人自媒体或研发人员个人搭建blog使用。</p>\n\n<p>当然如果你想选择Hard模式挑战以下，可以使用本博主开发的<a href=\"https://github.com/DavidAlphaFox/sblog\" >sblog</a>(深坑警告，自行跨越)。</p>\n","id":178840285734035869915032482527819270567,"intro":"前端技术","published":false,"published_at":63734916123,"title":"自媒体 CMS 选型","topic_id":1},{"content":"<h2>什么是秒杀</h2>\n\n<p>网络商家在某一预定的营销活动时间里，大幅度降低活动商品的价格，买家只要在这个时间里成功拍得此商品，便可以用超低的价格买到原本很昂贵的物品。由于在这个活动中商品的价格调整幅度很大，几千元商品可以用几十元拍到，或者几百元的商品用1元钱拍到，所以同时参与活动的人数会很多，这样商家就达到了营销的目的。当然正是由于同时参与人数过多的原因，甚至在活动正式开始后的一秒钟之内，所有的活动商品就已经被抢购完毕，所以此活动被称谓秒杀活动。\r\n简单的说，秒杀是网络商家为了提高人气吸引买家而采取的区别于竞拍方式的一种营销手段。</p>\n\n<h2>为什么秒杀那么难</h2>\n\n<p>从定义上来看，秒杀看起来并不是很难，它也就是普通的销售商品的过程，并且从定义上看业务流程甚至要比普通的商品销售要简单。但是秒杀却成了广大产品经理和程序员的心病。\r\n因为秒杀具有以下几个特点：</p>\n\n<ol>\n<li>定时性</li>\n<li>并发量巨大</li>\n<li>购买数量有限制</li>\n</ol>\n\n<p>因此会引发下面这些问题：</p>\n\n<ol>\n<li>库存管理\n\n<ul>\n<li>售出商品总量不能超出投放量</li>\n<li>一个用户不能够买多个商品</li>\n<li>未及时付款的商品重新投放</li>\n</ul></li>\n<li>并发量大\n\n<ul>\n<li>短时间内大量用户涌入</li>\n<li>秒杀软件的刷单</li>\n</ul></li>\n<li>数据库压力大\n\n<ul>\n<li>大量的数据查询</li>\n<li>库存减少和付费事务</li>\n</ul></li>\n</ol>\n\n<h2>如何解决</h2>\n\n<h3>大方向</h3>\n\n<ol>\n<li>削峰，不管是随机丢弃，还是多层筛选，尽可能减少进入核心业务的用户数</li>\n<li>排队，在秒杀场景下，排队不单单可以减少系统压力，还能保证正确性</li>\n<li>分区，使用分区可以降低一个节点当机带来整体性的损害或者雪崩性的系统不可用</li>\n<li>最终一致，很多时候，不一定要强一致性，只要能保证最后数据的正确，哪怕是手工修复，都能带来大规模的性能提升</li>\n</ol>\n\n<h3>削峰</h3>\n\n<ol>\n<li>产品层面\n\n<ul>\n<li>通过设置秒杀的码，例如说小米的F券等</li>\n</ul></li>\n<li>技术层面\n\n<ul>\n<li>设置验证码，防止机器人</li>\n<li>随机丢弃部分用户，保护核心秒杀系统</li>\n<li>使用CDN，将静态资源等提前推送到离用户较近的地方，不占用核心机房的带宽</li>\n<li>使用流量保护，限制一个IP在一定时间内对系统的访问</li>\n</ul></li>\n</ol>\n\n<h3>排队</h3>\n\n<p>使用消息队列，如RabbitMQ。将可以延后处理的事情，推送到队列中，交给后端的工作工作者慢慢消化。\r\n但是这地方需要注意以下几点：</p>\n\n<ol>\n<li>数据的排重，不可以让一件商品卖出去多次</li>\n<li>服务可用性，防止因为单个队列因为压力过大而崩溃导致服务不可能用</li>\n<li>数据安全性，需要队列支持持久化和事务性，防止数据没被处理就被丢弃或因队列崩溃而导致数据丢失</li>\n</ol>\n\n<h3>分区</h3>\n\n<p>在秒杀系统中，不能将用户全部都压在单个节点上，所以在一开始就应该做好分区策略，例如使用根据用户ID进行分区或者随机分区的方法。\r\n当然不单单要做好用户分区，也要做好系统的分区，例如说在排队阶段，需要使用一致性Hash将相同的数据发到同一个数据队列上，便于数据的排重。\r\n同时使用分区策略的时候，就代表系统是可以扩张的，当用户量级进一步扩大的时候，我们可以随时进行扩容。</p>\n\n<h3>最终一致性</h3>\n\n<p>不管系统设计的多么好，最终一致性还是需要做的，因为</p>\n\n<ol>\n<li>在大并发的情况下，很难不出现异常节点（概率问题）</li>\n<li>即便所有节点都正常，我们仍需要进行校验（人为出错的概率）</li>\n<li>验证产品的稳定性和正确性（测试和公司信誉问题）</li>\n</ol>\n\n<p>采用最终一致性一般的做法，就是将关键日志收集起来，如用户秒杀到了产品，用户付费了等信息和最终保存在数据库中的数据进行对比，从而确认系统的正确性。</p>\n","id":48663061192887651021205864307373244906,"intro":"秒杀在以前曾经在电商中是一个非常热门的话题，但是换个角度去看问题，秒杀问题在很多业务中都存在，本文从一个综述的方向，给读者介绍秒杀相关的问题和解决方法。","published":true,"published_at":63738320315,"title":"如何实现高性能的秒杀服务","topic_id":1},{"content":"<p>原文 <a href=\"https://gist.github.com/defunkt/6443?utm_source=ttalk.im&utm_medium=website&utm_campaign=Tech%2520Talk\">关于做开源项目与 side project</a></p>\n\n<p>大家好，我是Chris Wanstrath。</p>\n\n<p>当Jeremy让我来做本次演讲的时候， 我非常爽快的答应了。 当然好了，这绝对没有问题， 然后我花了一些时间来思考，稍等，为什么呢？为什么邀请我？大家期待我去讲什么有趣的话题呢？\n也许大家期待我讲一些关于Ruby的话题，或许是Ruby的未来，至少是未来的事物。这听起来很像是个主题演讲。</p>\n\n<p>因此，为什么我不跳出Ruby未来这个话题，从另一个角度来来看Ruby的未来。在未来，Ruby将会变得非常流行。会有更多的实现方案。同时，也会有更多的程序员去使用它。更多的计算机会默认安装Ruby，更多的人去阅读和Ruby相关的博客。这听起来有点疯狂，但请相信我。 这就是我本次演讲的主题。</p>\n\n<p>在未来的，会有更多的RubyGems，并且会有多RubyGems服务器。目前在撰写的新书，至少有一本，也可能是两本，我们甚至可以想象已经远超过三本。已经出版的书籍，将会发布新的版本，里面会增加更多的内容，更深入的探讨Ruby的新功能和细节。</p>\n\n<p>更年轻的人将会选择Ruby，而当前这些Ruby使用者也随着时间流逝而变老。一些Ruby使用者养着猫或者狗。另外一些则不养任何宠物，一些人已经有了孩子。（这里有个常见的错误认知，在我的经验中，养孩子要比养宠物花费更多的钱和精力）。</p>\n\n<p>很多网站将会使用Ruby，使用更新的Ruby On Rails和Merb。就像3.0和1.0一样的差距。一些有着奇怪名字的全新Web框架将被创建出来，并且被一些从没见过的人维护着。我们逐渐会发现，_why是一个非暴力的Joker，matz是很克制的Two Face，Nic模式是Penguin（他非常喜欢吃鱼），如果DHH是蝙蝠侠，那么我。。。我将是钢铁侠。</p>\n\n<p>新的语言将出现，并且将变得流行。 很多人仍会继续鄙视Ruby，将其命名为“ Python版本的Perl”，或“ 适合书呆子的Java”，甚至上帝就不应该让它存在的“Web版本的Visual Basic”。（然而，从技术上讲，我认为这个角色应该是ASP的版本1到版本3）。</p>\n\n<p>大学里面将会给那些继续获得本科学位的年轻人。绝大部分人会喝的烂醉，或者是经常处在宿醉的状态来上课，但是他们都渴望学的得新的知识。这个社会是行为驱动的，宏观环境不断的重塑我们，好吧，至少我们中的一部分人。</p>\n\n<p>Proc.  Lambda.</p>\n\n<p>将会有更多的会议。 人们将在这些会议上发言，有时是关于Ruby，有时不是关于Ruby。 演讲者将是形形色色的人，大谈特谈Smalltalk的设计理念和光辉岁月。。。但是实际上他们基本上没写过任何Smalltalk/\n一些人会展示他们新实现的Ruby虚拟机的benchmarks，但是它们尚未开源或完全不是开源的，所以你也无法去尝试。</p>\n\n<p>有人会提出全新的2.0版本，但是很快就风平浪静了。我们很快就随波逐流。测试将会被mock化，并且mock将会可测试的，那哪一个才是基础呢？</p>\n\n<p>Ruby将会变快，但是很快它就会被超越，发布的新补丁会破坏兼容性，安全漏洞的处理方式也会很粗暴。但是大型网站依然会引来数十亿的访问者，小博客会如雨后春笋一样，有的会语惊四座然后变得平淡乏味，甚至无影无踪了。</p>\n\n<p>最重要的是，Ruby将保持美丽。 至少，我们希望如此。这就是Ruby的未来。对我的主题是否有些感觉了？ 让我们现在谈论过去。</p>\n\n<p>约翰·冯·诺依曼是20世纪伟大的数学家之一。 他做的贡献有细胞自动机（cellular automata），集合论（set theory），函数分析（functional\nanalysis），量子力学（quantum mechanics），遍历理论（ergodic theory），连续几何（continuous geometry），经济学和博弈论，计算机科学，数值分析，爆破流体力学（explosive hydrodynamics）和统计学（我知道其中的60％）。他还帮助发明了现代计算机。 我们现在正在使用的那些。</p>\n\n<p>在1940年代，冯·诺依曼和一群才华横溢的天才聚在一起建造了计算机。 请注意，这不是第一台计算机。 事实上，“计算机”一词曾经用来描述计算数字。</p>\n\n<p>查尔斯·巴贝奇设计计算机是受到人脑易于犯错的影响，当处理大量数字时，错误是常有的。 例如，威廉·香克斯花了15年的时间计算出707位数的Pi。可悲的是，他在第11年犯了一个错误。接下来的四年是\n的计算完全是徒劳的，只有前527位数字是正确的。</p>\n\n<p>因此，巴贝奇设想了一种可以执行精确指令并传递准确信息的机器。 如果机器可以做体力劳动，为什么不做脑力劳动呢？随着艾伦·图灵这样的人加入了项目，并提出了一些想法，最终生产出诸如ENIAC之类的机器，首台数字计算机。 ENIAC是一个突破，它和冯·诺依曼最初设想的架构在一些方面有很大的禅意：它将程序指令和用户数据都保存在RAM中。 在此之前冯·诺依曼的想法是，指令是可以修改的，指令与数据分开存储。</p>\n\n<p>就像我说的那样，我们今天就是使用的体系（称为冯·诺依曼或存储程序体系结构） 。 当你在自己的系统中使用TextMate编写Ruby时，Ruby和TextMate都一起存储在RAM中。使用指令和数据一同保存到内存中的方案来实现一个简单的循环的例子，所有的分支指令都会修改为循环遍历。在ENIAC或其它早期的实现，这些翻译工作都是程序员手工实现的。（是的，首批程序员，都是女性）。\n不管怎么说，在20世纪40年代下半叶，冯·诺伊曼和他的小团队聚集在高级研究所（IAS）中，并开始基于他的存储程序体系结构研究计算机。 公平地说，这也不完全是他的想法。 他也是站在巨人的肩膀上的结果。但是根据维基百科上的描述，在实现冯式计算机上面击败了冯·诺伊曼。但是谁会在意维基百科呢，因为冯式计算机已经深入到我们每个人身边。</p>\n\n<p>制造冯式计算机的高级研究所（IAS）是由一些慈善家建立起来的，他们为这些科学家提供食宿，以支持他们继续进行研究，并且这个研究所就是一个离普林斯顿非常近的一个公寓，但是它并不隶属于普林斯顿，在那个时代，这个研究所中的首批成员，包括了爱因斯坦，冯·诺依曼等著名的科学家。因此，这个地方容纳了历史学家，科学家和工程师。 工程师们在地下室与冯·诺依曼一起建造冯式计算机，是不是很耳熟，知道今天这个地下室依然设计IAS的服务器中心。</p>\n\n<p>在IAS中，建造冯式计算机作的这些人既是程序员又是工程师。 他们会自己焊接零件，对零件进行编程程序，并修复硬件和软件中的错误。 其实，他们通常很难区分硬件和软件错误。 代码是错误的还是机器是错误的？ 这真的是一个噩梦。</p>\n\n<p>他们使用了大约2300个Radio Shack真空管制作逻辑开关和内存。他们使用的材料是非常易损的，因此他们经常会开夜车到凌晨4，5点，为了保持清醒，他们经常喝大量加了糖的茶。在战争年代，糖是限额配给品，而他们使用了远超他们配给份额的糖，这让IAS中的历史学家和其他人感到非常不满。（听起来，像高中时我和我兄弟在Mountain Dew上的情景）。</p>\n\n<p>当然，所有工程师都保留了笔记。做日志， 他们记录的内容绝大部分都是非常沮丧的失败，仅在后面的日子里面才有很多令人欣喜的巨大突破。他们的笔记被发送给全国各处的研究机构，这样才能让其他人复制他们的成果，使用冯式体系构建自己的计算机。</p>\n\n<p>在最后，他们在1952年6月10日完成了这台计算机的建造，让这台机器可以真正的被投入使用。在其它的地方，也有使用的相似的计算机指令的机器完成了建造（尽管它们有着兼容的指令，但是你不能编写任何可移植的程序）。并且IAS的这台计算机，立刻肩负起了它应有的使命：协助制造氢弹。</p>\n\n<p>第一枚氢弹于1952年11月1日引爆。这枚被称为&quot;Ivy Mike”的氢弹在太平洋的Enewetak环礁上被引爆，它比投掷在长崎上的原子弹的威力要大450倍。</p>\n\n<p>由此可见，数学家们建造了第一台现代计算机，用以帮助他们进行应用数学和流体力学的计算，他们可以说真正的黑客。他们做了一个前所未有的side project，可以说完全是杀鸡用牛刀了。（有趣的是，这也可以解释为什么每个人都认为一个非常棒的程序员需要非常精通数学，但我不能完全认同这个说法）。</p>\n\n<p>时至今日，已经有很多高收益的Ruby项目了，这些项目都是从side projects逐步演化而来的，其中一些，甚至可以说是重量级的项目。当前Rubinius已经有5位全职员工了，但是它完全是由Evan Phoenix在2006年创建的Side Project发展而来的。他当时只是想建立自己的Ruby。Ruby on Rails本身也是一步步从Basecamp中分离出来的，也是37signals的一个Side Projects。那时Basecamp还只是一个设计公司，而David Hansson是一个合同员工。</p>\n\n<p>没有人确切的知道_why是做什么的，但是Shoes会即便没有利益驱动，也会不断的发展。只是为了一件事，就是将GUI放近他们最喜欢的计算机语言中，因为我们都在其中获得了乐趣。Merb最初是一段非常简单的脚本，是Mongrel上的一个封装，为了能并发高效的上传文件。但是现在Engine Yard的开发人员已经将他们发展为一个框架了（我都不确定一个gist是否能容纳它所有内容了）。</p>\n\n<p>我们应当拥有自己的Side Project。Side Project 可以扩宽视野，让我们身心愉悦，探索新的想法，学习新的技术，当然我们也无需为此感到有压力或负责。我们无需担心自己的老板，同事或者那些在Reddit大谈特谈的家伙们。我们只是想找些乐子，让我们放飞自我吧。</p>\n\n<p>大学辍学后，我在一家PHP开发公司，从事卡车运输工作物流应用的开发。我们是独立卡车司机与KMart等大型公司之间的经纪人。 卡车司机会在我们的网站上注册，说他们将在5月3日到达特拉华州，并前往丹佛，然后获取沿其选定路线的货运信息。 然后他们可以通过我们对货物进行投标或承接运输任务。</p>\n\n<p>它是一个非常复杂的应用，但是它缺少两样东西：版本控制和常量。因为这里没有版本控制，所以你可以想象像main2.php和compute_radius_of_from_shipment7.php这种文件四处都是，尽管版本0到版本6是同一个文件，但是它不可避免的出现在我们的项目中，这真的非常非常痛苦。没有常量，也没有配置，因此源代码是充满魔法数字。 如果想调整我们的任何一个算法，就必须找到进行计算的代码，手动更改一些数字，并希望这个数字是对的。</p>\n\n<p>自然，我要做的第一件事就是使用Subversion（显然我一直是源代码管理的拥护者，但是直到把这个故事写到纸上才意识到。）我做的第二件事是开始将魔法数字提取到配置文件。 那时我使用了一个PHP非常常见的PHP解决方案，就是将这些魔法数字，提取到.ini文件中。 我所需要的这些PHP都默认支持，我非常确定的说PHP附带一个可以解析.ini的文件的库（它是全局命名空间中，添加了一些函数）。</p>\n\n<p>它看起来还不错，但是当我看到rails时，我被YAML文件给震惊了。它是那么的清晰和强力，Ruby对YAML的解析使用了_why所编写的C语言扩展Syck，但是我对C扩展一无所知。不知道PHP如何加载C扩展，更不知道如何在我们的服务器上部署C扩展。因此我利用我的业余时间开始为PHP编写一个YAML解析器。为了致敬Syck，我将自己的解析器称为Spyc，意思是简单PHP的YAML类。它是我编写的第一个使用状态机的Parser，为了支持YAML的饮用和指针，我对YAML进行了两遍解析。这个解析器，并没有完全支持YAML的规范，但是它支持YAML中绝大部分东西，包括存储和加载以及一些非常有用的部分。在我们公司成功使用YAML文件之前，我就偷偷的将这个模块签入我们的代码仓库中。当然，我将我的代码放到了SourceForge上，当时在线源代码存储的王者。我的设计师朋友为我做了一个展示页面，在第一个月Spyc就获得了很大的成功，它被下载了70次，70次呀！</p>\n\n<p>这非常重要（译者注：自己也有过同样的感觉，这是一种别人对自己工作的认同，自己真的解决了一些人的实际问题）。</p>\n\n<p>在公司工作了9个月，在我反复思考我自己的未来时，我发现卡车业务并不是我职业规划上的正确选择。毕竟他们只是雇佣了我。因此我辞职了，并重新回到学校学习，这次我选择了计算机科学而非英语，这才是我未来的道路。</p>\n\n<p>在这个夏天即将结束的时候，我的一位朋友，可以说是我的挚友，他长期浸淫在Digg和视频游戏中，但是离成为一个程序员还相差甚远，他问我，“嘿，你知道MySQL吗？”。“该死，” 我想，如果这次对放在现代的\n一天，相当于说朋友问为什么在实施滚动升级时，Ruby网站总是宕机。“是的，我知道MySQL”，我回答道，“那么，你也知道PHP了？”我的挚友追问道。“是的”，回答的同时，我对这次谈话的走向感到了困惑。\n“GameSpot在招聘，你应该去求职”，我的挚友回答了我的所有疑问。</p>\n\n<p>啊，GameSpot。 他和我都喜欢玩电子游戏。 高中，我在当地的GameStop工作过，在大学里时，我在商场中的EBGames工作过。 我拥有所有现代的游戏机，包括Atari，NES，创世纪等等。Gamespot.com是我在高中和大学时经常访问的网站。 顺便说一下，请注意GameSpot和GameStop是不同的名字，这导致我的家人无休止的困惑，以为我已经搬到加利福尼亚去零售了。啊，美好的美国梦。</p>\n\n<p>因此，当你使用Google搜索视频游戏时，GameSpot通常在结果中排名第一或第二。 我很清楚 GameFAQs.com（游戏中FAQs）和GameSpot是同一家公司在运作，也许我经常使用的网站都是这家公司的。 它的内容\n基本上是通关演示，操作方法，指南和作弊条。 非常多的作弊条。</p>\n\n<p>当时我并不知道旧金山在哪里，GameSpot在招聘什么水平的人，但是我申请了。我创建了全新的简历，通宵达旦的写了一份求职信。当我完成这封求职信的时候，它已经非常长了，看起了也非常有说服力。在其中我许诺第二天搬到加利福尼亚，除了吉他和Xbox，我将不带任何东西。 我的家人会想念我，但我已经决定准备离开，我渴望向世界展示我在本科阶段学习到的东西和我的能力。电话面试进行的非常顺利，他们很高兴我使用Mac和Ruby，毋庸置疑我得到了工作，当我一到达加利福尼亚，我就和父亲去找公寓。</p>\n\n<p>我想我的工作经验并不是我得到这份工作的原因。我很确定我得到这份工作和自己的求职信有很大关系。我在货运公司短暂工作经历也聊胜于无。我真正展示给GameSpot最有价值的东西是Spyc，我的代码是开源的，并且在生产环境中使用过。他们可以下载，尝试或在线查看。不管他们是否认为它很好，但是他们已经深思熟虑。或许，只是因为我有一个网站和70个下载量。不管怎么说，我在GameSpot获得了职位，感谢我的开源的Side Project。我从这次就职活动中得到的经验是，我们不需要用代码赚钱，而是靠代码产生收益。 我没做从Spyc赚钱，但是我得益于Spyc。（还有本书中叫这个名字， 但这是一个不同的故事。）</p>\n\n<p>这是不是很酷，我本来以为这次经历是独一无二的，但是它又发生了一次。当我在GameSpot工作的时候，我做了很多Ruby的Side Project。我有一个开源的Rails的tumble博客叫Ozimodo，一个非常简单的FTP服务器叫ftpd.rb（我用它来学习多线程）和一个命令行选项的DSL Parser叫Choice。当我在编写Choice的时候，我添加了完整的测试用例（我写这些东西是为了学习TDD）并且在Rubyforge上使用用RDoc生成一个页面。</p>\n\n<p>当GameSpot的母公司CNET收购Chowhound时，他们决定在Rails中重写该网站。 他们从Wayfaring.com的带来两个Rails程序员，正在寻找另一个。 他们找到我。稍后我发现Wayfaring.com的那些人，看到我Rubyforge上的Gem和测试用例，他们认为我是一个真正的Ruby程序员，他们需要的是一个对这些东西感兴趣且非常有热情的人。因此他们用一大笔钱说服我到Chowhound工作，再次感谢我那些开源的Side Project。这发生在我身上两次，所以并不少见。开源会促使很多不可思议的事情发生，不单单是在经济上，而且在社交上。在Chowhound，我遇到了GitHub的共同创始人PJ Hyett，同时也是博客Err的博主。</p>\n\n<p>所以开始一个Side Project吧，让人们知道在哪能找到你，让人们知道你能做什么。你现在有Side Project吗？如果没有，那是为什么？没有空闲时间？没有想法？我想我在两方面都能帮助你。</p>\n\n<p>首先，时间问题。 我不知道你们中有多少人阅读RSS，但是我给你们的建议是（这是一个主题演讲），一个月内不要再使用它了。只要关掉它，从今天起，停止使用Google Reader或NetNewsWire或现在时下流行的产品。 这不值得浪费你的时间。那么你应该怎么做呢？ 如果你使用Twitter，请尝试遵订阅你最喜欢的博客的作者。 在公共汽车上或者在洗手间阅读他们的推文。 每周检查一次Ruby Inside，并快速浏览下帖子。每个月访问一次像planetrubyonrails.com这类的新闻聚合器。让别人为你过滤内容，用你的时间做其它的事情。你不会做过任何重要的事情，像Googel App这样的运行引擎，或者Rubinius，或者今年Ruby Hoedow上重量级的演讲者。怎么会不呢 ？我愿意打赌你的RSS阅读器中的很多东西都是你已经知道或听说过的东西。以前，我个人每天要检查RSS多次， 单现在我不使用任何阅读器，从2008年1月开始就再也没有使用过。</p>\n\n<p>我发现，程序员之间的另一个很花费时间的地方是阅读理论和过程的书籍。 诸如Smalltalk最佳实践模式之类的书，敏捷开发人员的实践，甚至我敢说Pragmatic Programmer的图书，不值得浪费你的时间。 相反，请听Rein的演讲，和朋友或同事交谈。让其他人帮你提供信息，然后再决定你需要什么。学习模式，惯用法和最佳实践的最佳方法是：阅读开源代码。 查看其他人的做法。 它是了解行业最近发展和最新技术的好方法，而且是完全免费的。（我真的希望有人在我购买并阅读《 Head Start Design Patterns》之前就告诉过我这些事情）</p>\n\n<p>接下来使用Jerry Seinfield GTD方法。 每次在做Side Project的时候，就在日历上把这一天标记一个大X。最终，你会看到X组成了一条很漂亮的线。 缺少一个X会很不开心-因为它是你美丽的线条变得混乱。最终你会发现你的目标是保持连胜，即使你当天没有任何想法，这是克服惰性的最佳方案。好的，现在我们没有任何借口了。现在你有时间开始一个Side Project了，并且只需要坚持不懈，我们就有一本画满X的漂亮的台历了。至少，每个月，我们可以投入一个星期日来做事情。那如果没有任何想法该怎么办呢？</p>\n\n<p>这实际上是简单的部分，因为你不需要一个好主意，只要开始做一些自己感兴趣的事情就好。例如使用Ruby的新框架，我听说Sinatra最近很潮，使用Shoes做一个GUI相关的东西。例如说学习JavaScript。 我还是很喜欢它的，真的。 如果你不知道var，with和delete这些关键字是什么，来本书，然后开始编写一些华丽的效果。或者下载Rhino和Johnson，编写一些服务器端的JS。JS是一种非常实用，但是误解很多的语言。花一些时间来掌握你的编辑器。 拿起TextMate书，然后深入到其中。写一个插件。 如果你已经拥有大量的Vim-fu，请尝试Emacs。 了解人们为什么喜欢它，然后使用其中的信息在Vim和Emacs的圣战中对抗他们。编写一个Web服务器，像 Cheat, Subtlety, Disqus或者TwitPic，或者编写让人方便编写博客，网站或编写代码的工具。做一个只做一件事情的简单网站，并且提供API让人们获取信息。</p>\n\n<p>如果你一直想学习一种新语言，请开始学习它。但是，不要只是看书。 开始编写程序。如果学习Objective-C和Cocoa。 可以编写一个简单有用的Mac应用，然后免费分发出去。将代码发布到GitHub上，添加一个捐赠勋章，并接受捐赠，获取利润。用Lisp编写一个Rake，这是学习元编程的好方法以及使用新语言编写命令行脚本。 写一个RSS解析器或探索Erlang中的基础数据类型， 写一个简单的博客，并了解Haskell的Web框架。 在Io中使用OpenGL来编写拼字游戏，不要在意人们以前是否这么做。实际上，不必担心其他人怎么看待这个东西。 每当我做一个我认为别人真的会喜欢的项目，总会失败。每当我从事自己喜欢的项目时，它都会奏效。如果你坐在这间房间内，我想你和你周边人的品味都不会差。建立自己喜欢和他人也会喜欢的东西 （当然，不是所有人）。另外使用你喜欢的语言尝试一些困难，甚至可以说是不肯能实现的东西。不断探索边界。探索Ruby的边界，安装ImageMagick，重写所有的标准库，写一个Objective-C的绑定。有些东西简直是恶魔，不断折磨你，扩展你的大脑。</p>\n\n<p>在你的小项目花费几个星期日，然后完成它，并不断强化。学习一种全新的语言，并使用新的语言写一些新的玩具。用全新的Web框架，创建新的华丽效果。给Rake添加并发功能。你对这个过程投入的越多，就会涌现更多具有创意的想法。10%的想法，来自于90%的函数，至少，这个过程对我有效。</p>\n\n<p>毕竟，这就是GitHub的启动方式。 Tom和我平日都是全职工作，但我们周六会聚在一起，共进午餐，然后持续开发GitHub。最开始我们只想有一个简单且美观的工具来分享Git仓库，它将是我们更容易分享开源项目。现在我们有三个人都全职开发GitHub，GitHub现在有成千上万付费用户和数以万计的存储库。</p>\n\n<p>但是罗马不是一日建成，它是一个过程。我并非一从高中毕业后，就拿起一本Ruby的书，然后认识Tome和PJ，接着就是开始GitHub的。在GitHub上线之前，按照时间顺序，我开发了Spyc, Ozimodo, my ozmm.org tumblelog, ftpd.rb, Choice, Err博客软件, acts_as_textiled, Cheat!, acts_as_cached, Mofo, Subtlety, cache_fu, Sexy Migrations, Gibberish, nginx_config_generator, fixture，scenarios builder, Sake, Ambition和Facebox。并且这还是我发布出来的。拥有越来越多的开源项目，我也感到维护开源项目的不易。如果你已经拥有自己喜欢的工作，这些事情也不会将你排除在外。也许你每天使用中，就有很多他人的Side Project。你也会在平日的工作中使用自己的Side Project。从Emacs的配置文件到Web服务器，这里有很多事情可以锻炼你的思维。</p>\n\n<p>当我在编写Cheat的时候，我并不是打算离开Chowhound，我只是想要查找不常用命令更容易些。TwitPic和Twictures这类东西，与任何人的工作都没什么关系，只是想让互联网的生活更有趣些。 从经济角度来看Ruby on Rails，可能是赚钱的好想法，但是Shoes就很难说了。我的建议就是，现在就开始自己的Side Project，解决自己问题，要有创造力，分享出去或者敝帚自珍。Side Project比阅读RSS，比MobileMe更有用，比Reddit上的评论更有教育意义，甚至比听主题演讲更加有真实感。</p>\n\n<p>谢谢大家的聆听。</p>\n","id":201411843822376653509116135546950691308,"intro":"这是 GitHub 创始人于 2008 年在一个 Ruby 的会议上的讲话。当时 GitHub 有3个全职员工，几千个付费用户。做 side project，做开源项目，基本上是不能直接赚钱的，但却能间接地给你开启很多机会，结识一些有能力或者有想法的人。","published":true,"published_at":63739313785,"title":"关于做开源项目与 side project","topic_id":1},{"content":"<h2>什么是Port</h2>\n\n<p>Port可以说是Erlang提供的一种和Erts虚拟机以外世界通信的最基本的方式。Ports为Erlang提供了双向字节流，让Erlang可以非常好的和外部程序进行通信。默认情况下，外部程序会在一个全新的OS进程中运行，Erlang通过外部程序的标准输入（文件句柄0）和标准输出（文件句柄1）进行通讯。创建Port的Erlang进程一般我们将它成为，Port的所有者，所有和Port的通信都会通过Port所有者进程进行，当所有者进程停止运行了，外部程序也应该退出。</p>\n\n<h2>什么是Port Drivers</h2>\n\n<p>当然我们也可以用C或者C++编写一个动态链接库文件（.so或者.dll）让Erlang动态的加载到虚拟机内，这个动态链接库不会创建新的OS进程，而是直接使用Erlang的进程。但是，Erlang依然使用和Ports，我们将这种内联的Port称为Port Drivers。</p>\n\n<h2>Port和Port Drivers的差异</h2>\n\n<p>创建方式的不同：Port是通过erlang:open_port直接来创建的，而Port Drivers是先要通过erl_ddll:load_driver加载到虚拟机内后再通过erlang:open_port完成创建的。</p>\n\n<p>运行方式的不同：Port是运行在Erlang虚拟机外的OS进程和Erlang虚拟机不共享进程，不会引起Erlang虚拟机内存泄露和崩溃，而Port Drivers和Erlang的虚拟机共享进程，如果处理不当会引起Erlang虚拟机的崩溃和内存泄露。</p>\n\n<p>性能的差异：Port在创建的时候，beam.smp会使用vfork复制整个进程，这个会导致整个beam.smp进程阻塞，而Port Drivers只是创建一堆数据，所以性能不用说。</p>\n\n<h2>Port Drivers是如何调度的</h2>\n\n<p>在erl_port_task.c中我们可以找到erts_port_task_schedule函数，正式这个函数将Port Driver调度到Erlang虚拟机上的scheduler上的。erts_port_task_schedule函数会在erl_check_io的时候被调用。</p>\n\n<p>从这些代码中我们可以观察到：</p>\n\n<p>1.Port Drivers并不会一直放在ErtsPortTaskSched当中。</p>\n\n<p>2.Erlang的Port Drivers只有在Erlang进程通过erlang:control和erlang:command函数发送命令时，会将Port放入RunQueue。</p>\n\n<p>3.Erlang的Port Drivers向Erlang虚拟机注册IO任务，erlang会在erl_check_io放到RunQueue中。</p>\n\n<h2>Port Drivers为什么这么实现和调度</h2>\n\n<p>1.Erlang的虚拟机的调度器是一个软实时的调度器，它在调度Erlang进程的时候会为Erlang进程分配固定的reduction。Erlang虚拟机规定了每个Erlang的操作的reduction的数量，当Erlang进程的reduction减少到位0的时候，将进行Erlang进程切换。</p>\n\n<p>2.Erlang的虚拟机要保证调度器是无阻塞的，才能达到软实时调度。通过reduction机制，可以保证不执行IO操作的Erlang进程达到无阻塞。为了让IO操作不阻塞调度器，那么就必须让IO操作变成一种任务。</p>\n\n<p>3.Port Drivers很多时候，都是为了完成外部通信操作或者IO操作。因此Erlang将所有的IO操作都和事件驱动进行关联，当不能直接向事件驱动器的注册的IO操作则通过异步线程模拟成IO事件。这样就可以将IO操作变成IO任务，这样就如同无阻塞的操作一样。</p>\n\n<p>4.Port Drivers可以说是Erlang虚拟机对IO操作的高级抽象，这样就将复杂的外部世界和非IO操作尽最大可能的隔离开了。不但可大大减少代码量，同时也提高了平台的兼容性。最终Erlang的虚拟机内，将所有的IO操作和计算抽象成了执行队列上的一个又一个任务，方便运行在多核心上的调度器进行调度和任务密取，提高并发。</p>\n","id":290119348269964318642493076394681113489,"intro":"虽然Erlang已经推出了全新的系统交互方案NIF，但是仍有很多底层系统交互是由Erlang的另一个系统交互方案Port完成的。Port可以被分为普通Port和Port Drivers，这里将会介绍Port Divers以及它是什么。","published":true,"published_at":63734916122,"title":"什么是Erlang 的Port Drivers","topic_id":1},{"content":"<h2>EMQ的session定义</h2>\n\n<p>EMQ是使用链接进程(<code>emqtt_client</code>)和session进程(<code>emqtt_session</code>)分开的策略，其中<code>emqtt_session</code>负责管理EMQ的客户端的会话。<br/>\n因此可以看出<code>emqtt_session</code>做为会话的管理者和网络socket没有任何关系。<br/>\n<code>emqtt_session</code>主要管理客户端离线后的消息，高QoS 2消息的确认管理，管理订阅以及packet identify的管理。</p>\n\n<h2>emqtt_session的创建</h2>\n\n<p>当<code>emqtt_client</code>进程确认客户端的合法性后，会使用<code>emqtt_sm</code>中的函数去创建<code>emqtt_session</code>进程。</p>\n\n<p>从代码中可以清晰的看出，<code>emqtt_client</code>并没有使用<code>spawn_link</code>机制来直接创建<code>emqtt_session</code>，\n而是使用<code>emqttd_session_sup</code>这个监督者来创建session进程。但是在<code>emqtt_session</code>的进程中，\n<code>emqtt_session</code>会主动的去关联<code>emqtt_client</code>进程，同时<code>emqtt_session</code>还会建立一个<code>monitor</code>去监控<code>emqtt_client</code>进程。    </p>\n\n<pre><code><span class=\"code\"><span class=\"function\">create_session</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">CleanSess</span>, <span class=\"paren2\">{<span class=\"code\"><span class=\"variable\">ClientId</span>, <span class=\"variable\">Username</span></span>}</span>, <span class=\"variable\">ClientPid</span></span>)</span> -&gt;                                                                     \n    <span class=\"symbol\">case</span> emqttd_session_sup:start_session<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">CleanSess</span>, <span class=\"paren2\">{<span class=\"code\"><span class=\"variable\">ClientId</span>, <span class=\"variable\">Username</span></span>}</span>, <span class=\"variable\">ClientPid</span></span>)</span> <span class=\"symbol\">of</span>   \n        <span class=\"paren1\">{<span class=\"code\">ok, <span class=\"variable\">SessPid</span></span>}</span> -&gt;       \n            <span class=\"variable\">Session</span> = #mqtt_session<span class=\"paren1\">{<span class=\"code\">\n                      client_id = <span class=\"variable\">ClientId</span>, \n                     sess_pid = <span class=\"variable\">SessPid</span>, \n                     clean_sess = <span class=\"variable\">CleanSess</span></span>}</span>,                            \n            <span class=\"symbol\">case</span> insert_session<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Session</span></span>)</span> <span class=\"symbol\">of</span>                                                                                       \n                <span class=\"paren1\">{<span class=\"code\">aborted, <span class=\"paren2\">{<span class=\"code\">conflict, <span class=\"variable\">ConflictPid</span></span>}</span></span>}</span> -&gt;                                                                             \n                    <span class=\"comment\">%% Conflict with othe node? 同名ID同时上线了                                                                  \n</span>                    lager:error<span class=\"paren1\">(<span class=\"code\"><span class=\"string\">\"SM(~s): Conflict with ~p\"</span>, <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">ClientId</span>, <span class=\"variable\">ConflictPid</span></span>]</span></span>)</span>,                                             \n                    <span class=\"paren1\">{<span class=\"code\">error, mnesia_conflict</span>}</span>;                                                                                     \n                <span class=\"paren1\">{<span class=\"code\">atomic, ok</span>}</span> -&gt;                                                                                                   \n                    <span class=\"paren1\">{<span class=\"code\">ok, <span class=\"variable\">SessPid</span></span>}</span>                                                                                                 \n            <span class=\"symbol\">end</span>;                                                                                                                  \n        <span class=\"paren1\">{<span class=\"code\">error, <span class=\"variable\">Error</span></span>}</span> -&gt;                                                                                                         \n            <span class=\"paren1\">{<span class=\"code\">error, <span class=\"variable\">Error</span></span>}</span>                                                                                                        \n    <span class=\"symbol\">end</span>.\n</span></code></pre>\n\n<p>为什么要这样做呢？是因为以下几点原因：</p>\n\n<ol>\n<li><code>emqtt_session</code>进程退出后，<code>emqtt_client</code>必须跟着退出</li>\n<li><code>emqtt_client</code>进程退出后，根据情况需要保留<code>emqtt_session</code>进程，继续服务</li>\n</ol>\n\n<h2>emqtt_session恢复</h2>\n\n<p>当MQTT客户端在CONNECT包中将，<code>clean session</code>设置为false的时候，<code>emqtt_session</code>进程会在<code>emqtt_session</code>进程退出之后，\n继续接收一段时间消息，这个时间段可以通过<code>mqtt.session.expiry_interval</code>来进行配置。<br/>\n当然，在订阅某主题，并持续有消息广播的情况下，<code>emqtt_session</code>进程在失去<code>emqtt_session</code>进程后维持越久，所消耗的内存将会越多。</p>\n\n<pre><code><span class=\"code\">\nhandle_cast<span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">resume, <span class=\"variable\">ClientId</span>, <span class=\"variable\">ClientPid</span></span>}</span>,      \n            <span class=\"variable\">State</span> = #state<span class=\"paren2\">{<span class=\"code\">client_id       = <span class=\"variable\">ClientId</span>,  \n                           client_pid      = <span class=\"variable\">OldClientPid</span>,    \n                           clean_sess      = <span class=\"variable\">CleanSess</span>,    \n                           retry_timer     = <span class=\"variable\">RetryTimer</span>,     \n                           await_rel_timer = <span class=\"variable\">AwaitTimer</span>,  \n                           expiry_timer    = <span class=\"variable\">ExpireTimer</span></span>}</span></span>)</span> -&gt;                \n    <span class=\"macro\">?LOG(</span>debug, <span class=\"string\">\"Resumed by ~p\"</span>, <span class=\"paren1\">[<span class=\"code\"><span class=\"variable\">ClientPid</span></span>]</span>, <span class=\"variable\">State</span>),           \n    <span class=\"comment\">%% Cancel Timers                                                                                                              \n</span>    lists:foreach<span class=\"paren1\">(<span class=\"code\"><span class=\"symbol\">fun</span> emqttd_misc:cancel_timer/1,         \n                  <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">RetryTimer</span>, <span class=\"variable\">AwaitTimer</span>, <span class=\"variable\">ExpireTimer</span></span>]</span></span>)</span>,                                                                         \n    <span class=\"comment\">%% 踢掉老的客户端                                                                                                             \n</span>    <span class=\"symbol\">case</span> kick<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">ClientId</span>, <span class=\"variable\">OldClientPid</span>, <span class=\"variable\">ClientPid</span></span>)</span> <span class=\"symbol\">of</span>  \n        ok -&gt; <span class=\"macro\">?LOG(</span>warning, <span class=\"string\">\"~p kickout ~p\"</span>, <span class=\"paren1\">[<span class=\"code\"><span class=\"variable\">ClientPid</span>, <span class=\"variable\">OldClientPid</span></span>]</span>, <span class=\"variable\">State</span>);               \n        ignore -&gt; ok                          \n    <span class=\"symbol\">end</span>,    \n    true = <span class=\"symbol\">link</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">ClientPid</span></span>)</span>,                                      \n    <span class=\"variable\">State1</span> = <span class=\"variable\">State#state</span><span class=\"paren1\">{<span class=\"code\">client_pid      = <span class=\"variable\">ClientPid</span>,           \n                         binding         = binding<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">ClientPid</span></span>)</span>,          \n                         old_client_pid  = <span class=\"variable\">OldClientPid</span>,           \n                         clean_sess      = false,                           \n                         retry_timer     = undefined,    \n                         awaiting_rel    = #<span class=\"paren2\">{<span class=\"code\"></span>}</span>,   \n                         await_rel_timer = undefined,      \n                         expiry_timer    = undefined</span>}</span>,   \n    <span class=\"symbol\">if</span>  \n       <span class=\"variable\">CleanSess</span> =:= true -&gt;\n             <span class=\"macro\">?LOG(</span>error, <span class=\"string\">\"CleanSess changed to false.\"</span>, <span class=\"paren1\">[<span class=\"code\"></span>]</span>, <span class=\"variable\">State1</span>),\n              emqttd_sm:register_session<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">ClientId</span>, false, info<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">State1</span></span>)</span></span>)</span>; \n       <span class=\"variable\">CleanSess</span> =:= false -&gt; ok\n    <span class=\"symbol\">end</span>, \n    hibernate<span class=\"paren1\">(<span class=\"code\">emit_stats<span class=\"paren2\">(<span class=\"code\">dequeue<span class=\"paren3\">(<span class=\"code\">retry_delivery<span class=\"paren4\">(<span class=\"code\">true, <span class=\"variable\">State1</span></span>)</span></span>)</span></span>)</span></span>)</span>; \n</span></code></pre>\n\n<p>从这些代码上，不难看出在<code>emqtt_session</code>在恢复过程中，会做下面几件事情：</p>\n\n<ol>\n<li>踢掉老的客户端进程，和新客户端进程建立关联</li>\n<li>检测<code>clean session</code>的变化，并根据情况重新注册session</li>\n<li>重发所有堆积的消息</li>\n</ol>\n\n<h2>总结</h2>\n\n<p>使用链接进程(<code>emqtt_client</code>)和session进程(<code>emqtt_session</code>)分开的策略，充分的利用了Erlang的actor模型，简化了代码的编写同时利用Erlang的调度机制提高了消息的实时性（CPU数量充足）。</p>\n\n<p>但是这个设计并不是无懈可击的，当使用集群和session超时和<code>clean session</code>设置不当的时候，会出内网流量暴增以及某些节点内存暴增。同时因为<code>happens before</code>这种可能性，在下面场景会引起QoS 0的消息丢失。<br/>\n<code>emqtt_session</code>因某些未知原因退出，同时<code>emqtt_client</code>进程的socket已经接收完数据，但未发送给<code>emqtt_client</code>进程，这个时候<code>link</code>机制的退出消息已经推送给<code>emqtt_client</code>进程。接着<code>emqtt_client</code>进程被Erlang调度器调度，这时候，<code>emqtt_client</code>直接进行退出操作，忽略所有已经收到的socket数据。 </p>\n\n<p>当然该会话管理模型还有很多优点和缺点，望读者们自己逐步去发现。</p>\n","id":141700444561528225324283480333889278824,"intro":"分析MQTT服务器EMQ是如何管理连接的用户，就是所谓的Session管理。","published":true,"published_at":63734916126,"title":"EMQ的Session 管理","topic_id":1},{"content":"<h2>什么是粘包</h2>\n\n<p>因为UDP的协议特性，粘包现象并不会出现在UDP当中。因此粘包一般都出现在TCP当中，不过并不是使用TCP进行数据传输就会产生粘包。</p>\n\n<h3>TCP长链接</h3>\n\n<p>客户端和服务器建立起一个TCP连接后，进行多次数据交换而不断开，必要的时候会插入和数据无关的心跳包来保持TCP连接不被中间路由强制断开。</p>\n\n<h3>TCP短链接</h3>\n\n<p>客户端与服务器没进行一次数据交换就建立一次连接，完成数据交换后立刻断开连接。</p>\n\n<h3>粘包的产生</h3>\n\n<p>从上面可以看出，只有是TCP长连接存在的时候，才会发生粘包，因为TCP是流式传输的。在应用层面上虽然可以划分出一个个数据包，但是TCP传输层会将数据包整合一起发送或缓存着被应用一次性取出。简单的说就是：</p>\n\n<p>1.发送方需要等到缓存区被填充满了之后，再发送，因此造成了粘包现象。\r\n2.接收方不能快速的处理缓存区中的包，造成多个包堆积在缓存区中，因此造成了粘包现象。</p>\n\n<h3>如何解决粘包</h3>\n\n<p>最常见的方式就是，在每次发送数据包之前，先定义一个数据包长度。在接收数据包的时候先读取数据包长度，再读取整个数据包。进一步去完成业务操作。</p>\n\n<h2>eJabberd是如何处理粘包的</h2>\n\n<p>作为即时通讯，eJabberd在和普通的客户端进行通讯的时候底层技术也使用的是TCP长连接（Web做客户端还有websocket和BOSH这两个技术）。因此eJabberd也会出现粘包这一现象，这里就介绍下eJabberd是如何处理粘包的。 </p>\n\n<h3>ejabberd_receiver模块</h3>\n\n<p>ejabberd_receiver可以说是eJabberd的XML输入流最主要的部分，它负责管理了socket，输入流的流控和XML的解析器。在每次收到数据后，ejabberd_receiver都会更新流量控制器，防止一个客户端过快的发送数据，而给ejabberd_c2s造成过大的负担。</p>\n\n<p>在ejabberd_receiver进程被创建之后，会立刻初始化一个exml_stream的解析器。因为XMPP是基于TCP长连接的XML流，而XMPP又规定了XML流上传输的数据是通过XML节这种结构化格式封装的，所以这里XML的节就相当于数据包前方的长度字段了。简单的说：读取了一个完整的XML节，就是一个数据包，剩下的数据就是后续的数据包。</p>\n\n<h3>exml项目</h3>\n\n<h4>exml_event</h4>\n\n<p>exml_event是一个对libexpat进行封装的NIF，可以进行高效率的XML解析。exml_event会将xml数据解析成xml_element_start，xml_element_end和xml_cdata这三个标签。如果传入的数据没有被完全被解析，会保存在libexpat的parser的上下文当中。</p>\n\n<h4>exml_stream</h4>\n\n<p>exml_stream会将数据交给exml_event进行解析，会对解析出来的events（上面提到的xml_element_start，xml_element_end和xml_cdata）进行转换。将它们转化成xmlstreamstart,xmlstreamend和xmlel的Erlang的record。在exml_stream的上下文当中，会将没有闭合的xml节保存起来，直到整个XML节闭合后才会交还给ejabberd_receiver。</p>\n\n<h2>总结</h2>\n\n<p>eJabberd使用XML节闭合的特性，作为数据包的边界来解决粘包问题。同时使用libexpat的parser来缓存没有解析完的原始数据，使用exml项目中的exml_stream来缓存解析成功，但是没有闭合的XML节。从而保证了XMPP流中的XMPP节的完整性和TCP长链接的粘包问题。</p>\n","id":319386930848287889298938135878096485605,"intro":"XMPP","published":false,"published_at":63734916124,"title":"eJabberd 粘包处理","topic_id":1},{"content":"<h2>起因</h2>\n\n<p>因为对Erlang的OTP 17.0做了一段时间的代码分析，并且近期看到了大神写的书<a href=\"https://happi.github.io/theBeamBook/?utm_source=ttalk.im&utm_medium=website&utm_campaign=Tech%2520Talk\">The Erlang Runtime System</a>。发现了Erts中的erl_emu.c的process_main有个C语言写法自己从没用过，就查阅了相关资料。</p>\n\n<h2>跳转标签作为值</h2>\n\n<p>参考此处<a href=\"http://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html?utm_source=ttalk.im&utm_medium=website&utm_campaign=Tech%2520Talk\">Labels as Values</a></p>\n\n<p>简单说就是在函数内定义的标签，可以使用操作符‘&amp;&amp;’来进行取值，值的类型是void*，这个值是一个定值，是不可以改变的。然后可以使用goto语句进行跳转。代码如下</p>\n\n<pre><code><span class=\"code\"><span class=\"symbol\">void</span> *ptr;\n<span class=\"comment\">/* … */</span>\nptr = &amp;&amp;foo;\n<span class=\"symbol\">goto</span> *ptr;\n\n<span class=\"symbol\">static</span> <span class=\"symbol\">void</span> *array<span class=\"paren1\">[<span class=\"code\"></span>]</span> = <span class=\"paren1\">{<span class=\"code\"> &amp;&amp;foo, &amp;&amp;bar, &amp;&amp;hack </span>}</span>;\n<span class=\"symbol\">goto</span> *array<span class=\"paren1\">[<span class=\"code\">i</span>]</span>;</span></code></pre>\n\n<p>在Erlang中，这种模式被用来完成Erlang的Beam指令流转，做了一个简单的模拟代码</p>\n\n<pre><code><span class=\"code\">\n<span class=\"special\">#include&lt;string.h&gt;      \n</span><span class=\"special\">#include&lt;stdlib.h&gt;       \n</span><span class=\"special\">#include&lt;stdio.h&gt;                                                                                                      \n</span><span class=\"symbol\">typedef</span> <span class=\"symbol\">unsigned</span> <span class=\"symbol\">long</span> Uint;  \n<span class=\"symbol\">typedef</span> <span class=\"symbol\">unsigned</span> <span class=\"symbol\">long</span>  BeamInstr;   \n<span class=\"symbol\">typedef</span> <span class=\"symbol\">unsigned</span> <span class=\"symbol\">long</span>  UWord;                                                                                          \n                                                                                                                       \n<span class=\"special\">#define OpCase(OpCode)    lb_##OpCode \n</span><span class=\"special\">#define Goto(Rel) goto *((void *)Rel)   \n</span><span class=\"special\">#define OpCode(OpCode)  (&amp;&amp;lb_##OpCode)                                                                             \n</span><span class=\"symbol\">int</span> main<span class=\"paren1\">(<span class=\"code\"></span>)</span><span class=\"paren1\">{<span class=\"code\">                                                \n     BeamInstr* I;                                                                         \n     BeamInstr* next; \n     BeamInstr beam_apply<span class=\"paren2\">[<span class=\"code\">2</span>]</span>;   \n     \n     beam_apply<span class=\"paren2\">[<span class=\"code\">0</span>]</span>             = <span class=\"paren2\">(<span class=\"code\">BeamInstr</span>)</span> OpCode<span class=\"paren2\">(<span class=\"code\">i_apply</span>)</span>;   \n     beam_apply<span class=\"paren2\">[<span class=\"code\">1</span>]</span>             = <span class=\"paren2\">(<span class=\"code\">BeamInstr</span>)</span> OpCode<span class=\"paren2\">(<span class=\"code\">normal_exit</span>)</span>;   \n     \n     printf<span class=\"paren2\">(<span class=\"code\"><span class=\"string\">\"beam_apply %p</span><span class=\"string\">\\r</span><span class=\"string\">\\n</span><span class=\"string\">\"</span>,beam_apply</span>)</span>;    \n     printf<span class=\"paren2\">(<span class=\"code\"><span class=\"string\">\"beam_apply[0] %p</span><span class=\"string\">\\r</span><span class=\"string\">\\n</span><span class=\"string\">\"</span>,beam_apply<span class=\"paren3\">[<span class=\"code\">0</span>]</span></span>)</span>;  \n     printf<span class=\"paren2\">(<span class=\"code\"><span class=\"string\">\"beam_apply[1] %p</span><span class=\"string\">\\r</span><span class=\"string\">\\n</span><span class=\"string\">\"</span>,beam_apply<span class=\"paren3\">[<span class=\"code\">1</span>]</span></span>)</span>;                                                                     \n     I = <span class=\"paren2\">(<span class=\"code\">BeamInstr *</span>)</span> beam_apply;  \n     next = <span class=\"paren2\">(<span class=\"code\">BeamInstr *</span>)</span> *I;   \n     printf<span class=\"paren2\">(<span class=\"code\"><span class=\"string\">\"next: %p</span><span class=\"string\">\\r</span><span class=\"string\">\\n</span><span class=\"string\">\"</span>,next</span>)</span>;   \n     Goto<span class=\"paren2\">(<span class=\"code\">next</span>)</span>;\n     OpCase<span class=\"paren2\">(<span class=\"code\">i_apply</span>)</span>:<span class=\"paren2\">{<span class=\"code\">        \n          printf<span class=\"paren3\">(<span class=\"code\"><span class=\"string\">\"i_apply %p %p </span><span class=\"string\">\\r</span><span class=\"string\">\\n</span><span class=\"string\">\"</span>,I,<span class=\"paren4\">(<span class=\"code\">*I</span>)</span></span>)</span>; \n          I = I + 1;                          \n          Goto<span class=\"paren3\">(<span class=\"code\">*I</span>)</span>;                                                                           \n     </span>}</span>\n     OpCase<span class=\"paren2\">(<span class=\"code\">normal_exit</span>)</span>:<span class=\"paren2\">{<span class=\"code\">   \n          printf<span class=\"paren3\">(<span class=\"code\"><span class=\"string\">\"normal_exit %p %p </span><span class=\"string\">\\r</span><span class=\"string\">\\n</span><span class=\"string\">\"</span>,I,<span class=\"paren4\">(<span class=\"code\">*I</span>)</span></span>)</span>;  \n          <span class=\"symbol\">return</span> 0;     \n     </span>}</span>         \n     <span class=\"symbol\">return</span> 1;          \n</span>}</span>\n</span></code></pre>\n\n<p>beam_apply这个数组中存放的是被转化成整形数值的地址。赋值给next的时候，next类型是指针，并且指向相应lb地址。\n<code>next = (BeamInstr *) *I;</code>\ngcc会吧switch编译成jmp语句，为什么还要使用这种费劲的方式而不使用switch呢？这是因为switch在jmp前需要进行一次判断，而使用这种JUMP TABLE的模式是直接jmp到后面的地址。</p>\n","id":243052639698210697441280317546825205557,"intro":"在对Erlang运行时代码进行分析时，发现了一些C语言不常见的语法应用。","published":true,"published_at":63738488737,"title":"从 Erts 中学的 C 技巧","topic_id":1},{"content":"<p>安装Ocaml的PostgreSQL的绑定</p>\n\n<pre><code>opam install postgresql\n</code></pre>\n\n<p>在PostgreSQL中建立用户</p>\n\n<pre><code>\nCREATE ROLE web;\nALTER ROLE web LOGIN ;\nALTER USER web WITH PASSWORD '123456';\n</code></pre>\n\n<p>在PostgreSQL建立一张表</p>\n\n<pre><code>\nCREATE TABLE compay\n( id INTEGER PRIMARY KEY,\n  name text NOT NULL,\n  age integer\n );\n</code></pre>\n\n<p>让我们打开OCaml的交互编程，输入下面的代码</p>\n\n<pre><code>\n#use \"topfind\";;\n#thread;;\n#require \"postgresql\";;\n\nopen Printf;;\nopen Postgresql;;\n\nlet conn = new connection ~dbname:\"postgres\" ~host:\"localhost\" ~user:\"web\" ~password:\"123456\" ();;\n\nlet query = \"SELECT id, name,age FROM company WHERE id = $1\";;\n\nlet show res =\n  for tuple = 0 to res#ntuples - 1 do\n    for field = 0 to res#nfields - 1 do\n      printf \"%s, \" (res#getvalue tuple field)\n    done;\n    print_newline ()\n  done;;\n\nlet run s = show @@ conn#exec ~expect:[Tuples_ok] ~params:[| s |] query;;\n\n\nassert ((conn#prepare \"query_company\" query)#status = Command_ok);;\n\nlet prepared_run s name =\n  show @@ conn#exec_prepared ~expect:[Tuples_ok] ~params:[|s|] name\n;;\n\nrun \"1\";;\nprepared_run \"2\" \"query_company\";;\n</code></pre>\n","id":169568493076038442020443054177787669853,"intro":"简单记录下如何在OCaml中如何连接PostgreSQL","published":true,"published_at":63738411726,"title":"OCaml 使用 PostgreSQL","topic_id":1},{"content":"<h2>什么是线程</h2>\n\n<p>线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成，每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。</p>\n\n<p>同时线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。</p>\n\n<p>一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。因此线程也有就绪、阻塞和运行三种基本状态。就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；运行状态是指线程占有处理机正在运行；阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。</p>\n\n<h2>什么是信号</h2>\n\n<p>信号是一种IPC通信的形式，一般在Unix，类Unix或POSIX兼容的系统中使用。信号是一种异步通知进程或同进程中某个指定线程的方式。\r\n当信号被发送到进程的时候，操作系统会中断进程的控制流程，并且在执行非原子性的CPU指令时可以中断进程。</p>\n\n<h3>信号使用的风险（新手坑）</h3>\n\n<p>信号处理在存在竞态的，因为信号本身是异步的，在处理一个信号的过程中，令一个信号（甚至肯能是同类型的信号）会被直接发送到进程中请求进程处理。\r\n信号是可以打断系统调用的，不谨慎处理会引起程序自身的混乱，所以进程的信号处理过程，尽量做到没有副作用，也不要使用不可重入的函数。</p>\n\n<h2>Linux的线程</h2>\n\n<h3>LinuxThreads</h3>\n\n<p>在Linux的上古时代，Linux的线程技术和POSIX的标准是不同的，它使用自己的LinuxThreads库。这会为我们带来什么影响呢？</p>\n\n<p>让我们来回顾一下 LinuxThreads 设计细节的一些基本理念：</p>\n\n<ol>\n<li>系统必须能够响应终止信号并杀死整个进程。</li>\n<li>以堆栈形式使用的内存回收必须在线程完成之后进行。因此，线程无法自行完成这个过程。</li>\n<li>终止线程必须进行等待，这样它们才不会进入僵尸状态。</li>\n<li>线程本地数据的回收需要对所有线程进行遍历；这必须由管理线程来进行。</li>\n<li>如果主线程需要调用 pthread_exit()，那么这个线程就无法结束。主线程要进入睡眠状态，而管理线程的工作就是在所有线程都被杀死之后来唤醒这个主线程。</li>\n</ol>\n\n<p>为了维护线程本地数据和内存，LinuxThreads使用了进程地址空间的高位内存（就在堆栈地址之下）。\r\n同步元语是使用信号来实现的。例如，线程会一直阻塞，直到被信号唤醒为止。并且，LinuxThreads将每个线程都是作为一个具有惟一进程ID的进程实现的。LinuxThreads接收到终止信号之后，管理线程就会使用相同的信号杀死所有其他线程（进程）。\r\n由于异步信号是内核以进程为单位分发的，而LinuxThreads的每个线程对内核来说都是一个进程，且没有实现&ldquo;线程组&rdquo;，因此，某些语义不符合POSIX标准，比如没有实现向进程中所有线程发送信号。如果核心不提供实时信号，LinuxThreads将使用SIGUSR1和SIGUSR2作为内部使用的restart和cancel信号，这样应用程序就不能使用这两个原本为用户保留的信号了。在Linux kernel 2.1.60以后的版本都支持扩展的实时信号（从_SIGRTMIN到_SIGRTMAX），因此不存在这个问题。根据 LinuxThreads 的设计，如果一个异步信号被发送了，那么管理线程就会将这个信号发送给一个线程，如果这个线程现在阻塞了这个信号，那么这个信号也就会被挂起，因此某些信号的缺省动作难以在现行体系上实现，比如SIGSTOP和SIGCONT，LinuxThreads只能将一个线程挂起，而无法挂起整个进程。</p>\n\n<h3>LinuxThreads带来了什么问题</h3>\n\n<p>首先我们说下POSIX是如何定义多线程的：POSIX下一个多线程的进程只有一个PID。\r\n根据上面我们对LinuxThreads的描述，我们可以总结出LinuxThreads有下面这些问题：</p>\n\n<ol>\n<li>它使用管理线程来创建线程，并对每个进程所拥有的所有线程进行协调。这增加了创建和销毁线程所需要的开销。</li>\n<li>由于它是围绕一个管理线程来设计的，因此会导致很多的上下文切换的开销，这可能会妨碍系统的可伸缩性和性能。</li>\n<li>由于管理线程只能在一个 CPU 上运行，因此所执行的同步操作在 SMP 或 NUMA 系统上可能会产生可伸缩性的问题。</li>\n<li>由于线程的管理方式，以及每个线程都使用了一个不同的进程 ID，因此 LinuxThreads 与其他与 POSIX 相关的线程库并不兼容。</li>\n<li>信号用来实现同步原语，这会影响操作的响应时间。另外，将信号发送到主进程的概念也并不存在。因此，这并不遵守 POSIX 中处理信号的方法。</li>\n</ol>\n\n<p>我们在这里不关注性能如何只关注POSIX兼容和信号处理问题。</p>\n\n<h3>NPTL</h3>\n\n<p>LinuxThreads的问题，特别是兼容性上的问题，严重阻碍了Linux上的跨平台应用（如Apache）采用多线程设计，从而使得Linux上的线程应用一直保持在比较低的水平。在Linux社区中，已经有很多人在为改进线程性能而努力，其中既包括用户级线程库，也包括核心级和用户级配合改进的线程库。目前最为人看好的有两个项目，一个是RedHat公司牵头研发的NPTL（Native Posix Thread Library），另一个则是IBM投资开发的NGPT（Next Generation Posix Threading），二者都是围绕完全兼容POSIX 1003.1c，同时在核内和核外做工作以而实现多对多线程模型。这两种模型都在一定程度上弥补了LinuxThreads的缺点，且都是重起炉灶全新设计的。\r\nNPTL的设计目标归纳可归纳为以下几点：</p>\n\n<ol>\n<li>POSIX兼容性</li>\n<li>SMP结构的利用</li>\n<li>低启动开销</li>\n<li>低链接开销（即不使用线程的程序不应当受线程库的影响）</li>\n<li>与LinuxThreads应用的二进制兼容性</li>\n<li>软硬件的可扩展能力</li>\n<li>多体系结构支持</li>\n<li>NUMA支持</li>\n</ol>\n\n<p>在技术实现上，NPTL仍然采用1:1的线程模型，并配合glibc和最新的Linux Kernel2.5.x开发版在信号处理、线程同步、存储管理等多方面进行了优化。和LinuxThreads不同，NPTL没有使用管理线程，核心线程的管理直接放在核内进行，这也带了性能的优化。</p>\n\n<h3>Linux线程总结</h3>\n\n<p>比较新的Linux都已经开始使用NPTL了，所以我们可以忽略LinuxThreads的存在了，介绍它主要是为了让诸位读者更深入的了解线程和信号的恩恩怨怨（不要丢鸡蛋）。</p>\n\n<h2>Linux的信号</h2>\n\n<h3>Linux是如何处理信号的</h3>\n\n<p>随着Linux的内核版本不断提升，Linux的信号现在已经可以按照线程级别的触发了，换句话说就是，每个线程可以关注自己的信号了，并且可以区别性对待了。那我们需要注意什么呢？</p>\n\n<p>在多线程应用中，我们应当使用sigaction来代替singal函数，因为按POSIX的说法singal函数并没有明确定义自己在多线程应用中的行为。</p>\n\n<p>可以使用pthread_sigmask来为每个线程设置独立的信号掩码。同时在多线程应用中应当避免使用sigprocmask这个函数，原因也是POSIX中该函数并没有明确定义自己在多线程应用中的行为。</p>\n\n<p>这个时候，有人会产生疑问了，那么多线程下kill发出的进程级别的信号A怎么办？Linux是这样解决的，它会把这个信号交付给任意一个没有屏蔽信号A的线程。如果这信号没有被任何线程设置handler进行处理，就会触发POSIX规定的默认动作。</p>\n\n<p>接着有人就会问，我怎么向某个线程发消息呢，POSIX为我们准备了pthread_kill函数，我们可以直接向特定的线程发送消息。那么如果一个线程收到信号A，但是自己没有安装handler会发生什么？其实和进程级别的信号处理方法一样，直接触发默认动作，同样会结束整个进程。</p>\n\n<h3>如何避免新手坑</h3>\n\n<p>在具有事件循环的应用中，在信号的的handler中，可以将信号直接放入程序的队列中，立刻返回。这样直到线程从程序的队列中取出这个信号为止，整个线程看起来就像没有“中断”。\r\n如果不知道该怎么做，去看看著名的libev吧。</p>\n\n<h3>信号SIGSEGV</h3>\n\n<p>这个信号，也许是大家最不想见到，为什么呢？我们看这个信号的定义：</p>\n\n<p>当当前程序对内存的引用无效时，就会产生当前信号，也就是我们常说的“段违例”。</p>\n\n<p>以下几种情况会产生该信号：</p>\n\n<pre><code>1.进程引用的内存页面不存在（例如，该页面位于堆和栈之间的映射的区域）\r\n2.进程试图更新只读内存页（例如，程序文本段或已经被标记为只读的内存映射区域）\r\n3.进程试图在用户态去访问内核部分的内存\r\n</code></pre>\n\n<p>好了，我们都知道这个信号引发的结果就是进程退出。不过我们都忽视了一个问题，在现代的Linux上，按照POSIX的定义，这个信号是系统产生的线程级别的信号。换句话说，如果某个线程A出现了内存引用无效，那么产生的信号，会投递到线程A的信号队列中，而不是像进程级别的信号无法确定接受者是谁。</p>\n\n<h2>JVM的安全区域</h2>\n\n<p>如果我们想让所有Java线程停下来的时候，在JVM的JavaThread执行到大家所知道的test 特定页面的指令时，就会因为更新不可读页面而触发SIGSEGV信号。那么对于那些正在执行native代码的JavaThread该怎么办，JVM中的注释写的非常清楚，native返回JVM时会检查是否能返回的。</p>\n\n<p>好了再多说一句，JVM是如果将特定内存保护起来的呢？这个需要看操作系统的API了，在Linux中是mprotect。</p>\n\n<h2>总结</h2>\n\n<p>多读读POSIX标准和Intel的CPU体系结构，会让自己在开发变的容易些。</p>\n","id":58411272837521748216207343342766373962,"intro":"因为对JVM内是如何实现让线程暂停并进行GC的方法非常好奇，就对JVM中关于GC进行了下分析。其中对于线程和操作系统中的信号机制的关系进行了相关的总结和记录。","published":true,"published_at":63737378867,"title":"Linux的信号和线程","topic_id":1},{"content":"<h2>什么是Web服务器</h2>\n\n<h3>Web简介</h3>\n\n<p>WEB服务器也称为WWW(WORLD WIDE WEB)服务器，主要功能是提供网上信息浏览服务。世界上第一台Web服务器诞生于1990年，最先被部署在欧洲原子核研究委员会（CERN，European Organization for Nuclear Research）的。起初其被命名为“CERN httpd”，也被称为“W3C httpd”。</p>\n\n<h3>Web发展简史</h3>\n\n<ul>\n<li>1990年，CERN httpd是一台NeXT服务器，运行着NeXTSTEP操作系统。最先展示在世人面前是在美国圣安东尼奥举办的Hypertext 91大会上，而且当时它托管着当时世界上首个Web页面（http://info.cern.ch/hypertext/WWW/TheProject.html）。</li>\n<li>1992年开始，Web服务器开始呈急剧增长态势。1992年全球已经拥有总共26台WWW服务器。</li>\n<li>在1993年的时候，这一数字增长到了200台</li>\n<li>在1994年则为1万台，用户数超过千万人。</li>\n</ul>\n\n<h3>Web服务器</h3>\n\n<p>Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以向浏览器等Web客户端提供文档，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。</p>\n\n<h2>Nginx</h2>\n\n<h3>什么是Nginx</h3>\n\n<p>Nginx是lgor Sysoev为俄罗斯访问量第二的rambler.ru站点设计开发的。从2004年发布至今，凭借开源的力量，已经接近成熟与完善。\r\nNginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。</p>\n\n<h3>Nginx能做什么</h3>\n\n<ol>\n<li>反向代理</li>\n<li>负载均衡</li>\n<li>HTTP服务器</li>\n<li>正向代理</li>\n</ol>\n\n<h4>反向代理</h4>\n\n<h5>定义</h5>\n\n<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。</p>\n\n<h5>nginx实现</h5>\n\n<pre><code>server {\r\n        listen       80;\r\n        server_name  www.ttalk.im;\r\n        location / {\r\n            proxy_pass http://localhost:8080;\r\n            proxy_set_header Host $host:$server_port;\r\n        }\r\n    }</code></pre>\n\n<p>这里面就是将本站的80端口代理到同一台服务器的8080端口上。</p>\n\n<h5>特点</h5>\n\n<p>Nginx在做反向代理时，提供性能稳定，并且能够提供配置灵活的转发功能。Nginx可以根据不同的正则匹配，采取不同的转发策略，比如图片文件结尾的走文件服务器，动态页面走Web应用服务器。并且Nginx对返回结果进行错误页跳转，异常判断等。如果被分发的服务器存在异常，他可以将请求重新转发给另外一台服务器，然后自动去除异常服务器。</p>\n\n<h4>负载均衡</h4>\n\n<h5>定义</h5>\n\n<p>负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web应用服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。</p>\n\n<h5>nginx实现</h5>\n\n<pre><code>  upstream inner {\r\n        server 192.168.1.2:8080;\r\n        server 192.168.1.3:8080;\r\n    }\r\n    server {\r\n        listen       80;\r\n        server_name  www.ttalk.im;\r\n        location / {\r\n            proxy_pass http://inner;\r\n            proxy_set_header Host $host:$server_port;\r\n        }\r\n    }</code></pre>\n\n<p>这里面就是将本站的80端口代理到两台内网服务器的8080端口上，并且均匀分请求。</p>\n\n<h5>特点</h5>\n\n<ul>\n<li>一般配合反向代理使用</li>\n<li>自动剔除异常节点</li>\n<li>多种负载算法\n\n<ol>\n<li>RR（默认），就是Round Robin的缩写，将请求均分到不同的服务器上</li>\n<li>权重，因为被代理的服务器性能不同而采取将不同比例的请求分配到不同的服务上</li>\n<li>ip_hash 根据用户的IP不同将某个用户的请求每次都分配到同一台服务器上</li>\n</ol></li>\n</ul>\n\n<h4>HTTP服务器</h4>\n\n<h5>nginx实现</h5>\n\n<pre><code>    server {\r\n        listen       80;\r\n        server_name  static.ttalk.im;\r\n        location / {\r\n               root  /var/www/ttalk/static;\r\n               index  index.html;\r\n           }\r\n    }\r\n</code></pre>\n\n<p>这段配置，让nginx直接处理本站的所有静态资源文件。</p>\n\n<h5>特点</h5>\n\n<p>Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现。</p>\n\n<h4>正向代理</h4>\n\n<h5>定义</h5>\n\n<p>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。</p>\n\n<h5>nginx实现</h5>\n\n<pre><code>    resolver 8.8.8.8;\r\n    server {\r\n        resolver_timeout 5s;\r\n        listen 80;\r\n        location / {\r\n            proxy_pass http://$host$request_uri;\r\n        }\r\n    }</code></pre>\n\n<h5>特点</h5>\n\n<p>也许是本人没有特别深入用这个功能的关系，感觉nginx这个功能实现的比较弱，并不推荐使用。</p>\n\n<h2>总结</h2>\n\n<p>Nginx和Apache，IIS等相比，是一款较新的Web服务器，但是Nginx凭借着高稳定性、功能强、示例配置文件和低系统资源的消耗让它后来居上。\r\n在我们不需要实现太多复杂的功能，或者有特定需要的场景下，Nginx都是一个非常不错的选择。\r\n当然Nginx也有各种各样的插件和衍生版本，例如著名的OpenResty</p>\n","id":306511850451933380209804978186204100545,"intro":"介绍Web的历史和常见的Web服务器，重点介绍Web服务器Nginx和Nginx中比较常用的功能，为Web开发入门进行科普。","published":true,"published_at":63737806422,"title":"Web 服务器-Nginx","topic_id":1},{"content":"<h2>什么是服务发现</h2>\n\n<p>服务发现在微服务和容器部署的项目中会被经常提到，当我们需要远程的访问REST API或者Thrift API时，我们必须得知道服务的网络地址（IP地址和端口号）。传统的应用程序都是运行在固定的物理机器上，IP地址和端口号都是相对固定的，可以通过配置文件方式来实现不定期更新的IP地址和端口号，最常见的例子就是DNS。</p>\n\n<p>从这里我们可以总结出，服务发现是记录了（大规模）分布式系统中所有服务的信息，人们或者其它服务可以据此找到这些服务。</p>\n\n<h2>服务发现应该具备哪些关键特性</h2>\n\n<p>服务发现是支撑大规模 SOA 的核心服务，它必须是高可用的，提供注册、目录和查找三大关键特性，仅仅提供服务目录是不够的。服务元数据存储是服务发现的关键，因为复杂的服务提供了多种服务接口和端口，部署环境也比较复杂。一旦服务发现组件存储了大量元数据，它就必须提供强大的查询功能，包括服务健康和其它状态的查询。</p>\n\n<h2>eJabberd中的服务发现</h2>\n\n<p>eJabberd的作为实现XMPP协议的高性能，高可用服务器，自然而然会显现XMPP的服务器发现协议<a href=\"https://xmpp.org/extensions/xep-0030.html\" >XEP-0030</a>。从XEP-0030中可以看出，XMPP将服务发现定义为一种目录逐层查找的IQ处理机制。用来发现服务器上更多的IQ功能。在XMPP中，服务发现被简称为disco，是一个被定义在http://jabber.org/protocol/disco 这个XML命名空间内的IQ处理器。</p>\n\n<h3>发现实体上的服务</h3>\n\n<p>一个实体可以提供多种服务和特性，为了得到这些信息，就需要去发现实体上的服务，所以XMPP做了下面这些设计。</p>\n\n<h4>要求</h4>\n\n<p>为了完成服务发现，实体必须提供下面这些信息</p>\n\n<ol>\n<li>实体的身份标识。在disco中，一个实体的身份细分成多个种类(服务器、客户端、网关、目录等等)及其种类中的特殊类型（IM服务器、电话或处理的客户端、MSN网关或AIM网关、用户目录或聊天室目录等等）。这些信息帮助请求实体确定最适合放置实体最服务组或服务“桶”，（例如，可能在GUI中用合适的图标把实体显示出来）。一个实体 可以有多个身份。当提供多个identity元素的时候，每个identity元素的 name 属性应该有相同的值。\r\n1.实体的特性和协议。这个信息帮助请求实体测定对目标实体可以做什么样的动作（注册、搜索、联合等等），实体支持什么样的协议，以及是否有感兴趣的特性类型（例如，为了特性协商的目的）。</li>\n</ol>\n\n<h4>查询和响应</h4>\n\n<p>disco为了让请求实体，发现目标实体，做了这样的规定，必须向特定实体发送一个IQ，其中query的XML命名空间为http://jabber.org/protocol/disco 。</p>\n\n<pre><code>&lt;iq type='get'\r\n    from='romeo@montague.net/orchard'\r\n    to='plays.shakespeare.lit'\r\n    id='info1'&gt;\r\n  &lt;query xmlns='http://jabber.org/protocol/disco#info'/&gt;\r\n&lt;/iq&gt;</code></pre>\n\n<p>收到该IQ 请求之后，disco必须做出下面三种回应中的一种</p>\n\n<p>查询成功，返回实体锁能提供的服务，以及特性\r\n<code>XML\r\n&lt;iq type='result'\r\n    from='plays.shakespeare.lit'\r\n    to='romeo@montague.net/orchard'\r\n    id='info1'&gt;\r\n  &lt;query xmlns='http://jabber.org/protocol/disco#info'&gt;\r\n    &lt;identity\r\n        category='conference'\r\n        type='text'\r\n        name='Play-Specific Chatrooms'/&gt;\r\n    &lt;identity\r\n        category='directory'\r\n        type='chatroom'\r\n        name='Play-Specific Chatrooms'/&gt;\r\n    &lt;feature var='http://jabber.org/protocol/disco#info'/&gt;\r\n    &lt;feature var='http://jabber.org/protocol/disco#items'/&gt;\r\n    &lt;feature var='http://jabber.org/protocol/muc'/&gt;\r\n    &lt;feature var='jabber:iq:register'/&gt;\r\n    &lt;feature var='jabber:iq:search'/&gt;\r\n    &lt;feature var='jabber:iq:time'/&gt;\r\n    &lt;feature var='jabber:iq:version'/&gt;\r\n  &lt;/query&gt;\r\n&lt;/iq&gt;\r\n</code>\r\n发现异常，实体可能不存在的时候，会返回这些信息\r\n<code>XML\r\n&lt;iq type='error'\r\n    from='plays.shakespeare.lit'\r\n    to='romeo@montague.net/orchard'\r\n    id='info1'&gt;\r\n  &lt;query xmlns='http://jabber.org/protocol/disco#info'/&gt;\r\n  &lt;error type='cancel'&gt;\r\n    &lt;item-not-found xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/&gt;\r\n  &lt;/error&gt;\r\n&lt;/iq&gt;\r\n</code>\r\n实体不能正常服务\r\n<code>XML\r\n&lt;iq type='error'\r\n    from='plays.shakespeare.lit'\r\n    to='romeo@montague.net/orchard'\r\n    id='info1'&gt;\r\n  &lt;query xmlns='http://jabber.org/protocol/disco#info'/&gt;\r\n  &lt;error code='503' type='cancel'&gt;\r\n    &lt;service-unavailable xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/&gt;\r\n  &lt;/error&gt;\r\n&lt;/iq&gt;\r\n</code></p>\n\n<h3>发现所有实体</h3>\n\n<p>有时候，客户端需要知道，服务器都支持哪些扩展，就需要查询下，现在有多少可发现实体在服务器上。</p>\n\n<h4>基本要求</h4>\n\n<p>请求实体为了发现一个服务器上的所有实体， 必须向目标实体发送类型为get的IQ请求，其中包含一个空的<query/>元素，其中query的XML命名空间\r\n为 http://jabber.org/protocol/disco#items</p>\n\n<h4>查询和响应</h4>\n\n<p>查询非常简单，唯一的区别就是查询对象直接指向host，查询的命名空间变为 http://jabber.org/protocol/disco#items</p>\n\n<pre><code>&lt;iq type='get'\r\n    from='romeo@montague.net/orchard'\r\n    to='shakespeare.lit'\r\n    id='items1'&gt;\r\n  &lt;query xmlns='http://jabber.org/protocol/disco#items'/&gt;\r\n&lt;/iq&gt;\r\n``` \r\n服务端收到请求，就必须做出下面的回应\r\n``` XML\r\n&lt;iq type='result'\r\n    from='shakespeare.lit'\r\n    to='romeo@montague.net/orchard'\r\n    id='items1'&gt;\r\n  &lt;query xmlns='http://jabber.org/protocol/disco#items'&gt;\r\n    &lt;item jid='people.shakespeare.lit'\r\n          name='Directory of Characters'/&gt;\r\n    &lt;item jid='plays.shakespeare.lit'\r\n          name='Play-Specific Chatrooms'/&gt;\r\n    &lt;item jid='mim.shakespeare.lit'\r\n          name='Gateway to Marlowe IM'/&gt;\r\n    &lt;item jid='words.shakespeare.lit'\r\n          name='Shakespearean Lexicon'/&gt;\r\n    &lt;item jid='globe.shakespeare.lit'\r\n          name='Calendar of Performances'/&gt;\r\n    &lt;item jid='headlines.shakespeare.lit'\r\n          name='Latest Shakespearean News'/&gt;\r\n    &lt;item jid='catalog.shakespeare.lit'\r\n          name='Buy Shakespeare Stuff!'/&gt;\r\n    &lt;item jid='en2fr.shakespeare.lit'\r\n          name='French Translation Service'/&gt;\r\n  &lt;/query&gt;\r\n&lt;/iq&gt;\r\n``` \r\n### eJabberd是如何实现的\r\n\r\neJabberd将[XEP-0030](https://xmpp.org/extensions/xep-0030.html)，作为一个常规的扩展，在mod_disco中进行了实现。\r\n\r\n#### mod_disco模块\r\n\r\nmod_disco会在启动的时候建立一系列的命名，公开且键值有序的ETS，用来保存IQ的特性。同时注册host上最基本的三个IQ特性，iq，presence和presence-invisible。并同时在ejabberd_local和ejabberd_sm中注册IQ处理器，为什么这么做请参考[ eJabberd 的消息路由](https://www.ttalk.im/topics/47)，因为在eJabberd_local中主要处理JID中没有user部分的请求，而eJabberd_sm主要负责JID带有User部分的。\r\n\r\n每当我们在ejabberd_local上注册IQ处理器的时候，会自动注册到mod_disco上\r\n``` Erlang\r\nhandle_info({register_iq_handler, Host, XMLNS, Module, Function}, State) -&gt;\r\n    ets:insert(?IQTABLE, {{XMLNS, Host}, Module, Function}),\r\n    catch mod_disco:register_feature(Host, XMLNS),\r\n    {noreply, State};\r\nhandle_info({register_iq_handler, Host, XMLNS, Module, Function, Opts}, State) -&gt;\r\n    ets:insert(?IQTABLE, {{XMLNS, Host}, Module, Function, Opts}),\r\n    catch mod_disco:register_feature(Host, XMLNS),\r\n    {noreply, State};</code></pre>\n\n<p>当我们收到info和items查询的时候，会自动去调用mod_disco的process_local_iq_<em>和process_sm_iq_</em>这几个函数。</p>\n\n<h2>总结</h2>\n\n<p>XMPP的服务发现机制disco，主要是通过目录查询的方式来完成的。并且这种发现机制是针对IQ处理器而设置的，换句话说，在扩展eJabberd的时候仍然需要编写Erlang代码并编译到eJabberd的服务器中。虽然有很多不便利之处，但是却已经让eJabberd服务器（XMPP协议）具有极强的扩展能力。甚至可以使用eJabberd做一个购物APP的后端，这已经超出了一个通讯服务器的能力范围之外，因此拥有了disco协议之后，eJabberd就可以说是一个超级服务器了。后面将会继续介绍如何使用外部服务来扩展eJabberd。</p>\n\n<p>在这里主要介绍了如何用disco发现服务器上的资源，作为对等实体disco是可以发现客户端上的资源，具体请看<a href=\"https://xmpp.org/extensions/xep-0030.html\" >XEP-0030</a>规范。</p>\n","id":339493742113917954739597540518916481947,"intro":"XMPP","published":false,"published_at":63734916125,"title":"eJabberd 的服务发现","topic_id":1},{"content":"<h2>Mnesia是什么</h2>\n\n<p>Mnesia是一个分布式数据库管理系统（DBMS），适合于电信和其它需要持续运行和具备软实时特性的Erlang应用，是构建电信应用的控制系统平台开放式电信平台(OTP)的一部分。\r\n从这里可以看出Mnesia是Erlang/OTP平台内置的数据库。开发该数据库的原因是电信应用苛刻的容错和高可靠性需求，这些需求如下：</p>\n\n<ol>\n<li>实时快速的键/值检索</li>\n<li>非实时的复杂查询主要在运营和维护时进行</li>\n<li>分布式的应用，从而数据也必须分布</li>\n<li>高容错性</li>\n<li>可动态重新配置</li>\n<li>存储复杂的对象数据</li>\n</ol>\n\n<h2>如何使用Mnesia</h2>\n\n<p>Mnesia作为一个数据库，使用的时候就有一定的要求，相对于其它数据库而言，这些需求是非常简单的。</p>\n\n<p>使用Mnesia需要满足以下需求：\r\n1. 操作系统可以运行Erlang/OTP平台\r\n2. 已经创建Mnesia的schema表</p>\n\n<p>满足这两点Mnesia就可以使用了。本文将介绍Mnesia是如何创建schema表的</p>\n\n<h2>Mnesia的cstruct结构</h2>\n\n<pre><code><span class=\"code\"><span class=\"attribute\">-record</span><span class=\"paren1\">(<span class=\"code\">cstruct, <span class=\"paren2\">{<span class=\"code\">name,                    <span class=\"comment\">% Atom 表名字\r\n</span>          type = set,                      <span class=\"comment\">% set | bag\r\n</span>          ram_copies = <span class=\"paren3\">[<span class=\"code\"></span>]</span>,                 <span class=\"comment\">% [Node]\r\n</span>          disc_copies = <span class=\"paren3\">[<span class=\"code\"></span>]</span>,                <span class=\"comment\">% [Node]\r\n</span>          disc_only_copies = <span class=\"paren3\">[<span class=\"code\"></span>]</span>,           <span class=\"comment\">% [Node]\r\n</span>          load_order = 0,                  <span class=\"comment\">% Integer\r\n</span>          access_mode = read_write,        <span class=\"comment\">% read_write | read_only\r\n</span>          majority = false,                <span class=\"comment\">% true | false\r\n</span>          index = <span class=\"paren3\">[<span class=\"code\"></span>]</span>,                      <span class=\"comment\">% [Integer]\r\n</span>          snmp = <span class=\"paren3\">[<span class=\"code\"></span>]</span>,                       <span class=\"comment\">% Snmp Ustruct\r\n</span>          local_content = false,           <span class=\"comment\">% true | false\r\n</span>          record_name = <span class=\"paren3\">{<span class=\"code\">bad_record_name</span>}</span>, <span class=\"comment\">% Atom (Default = Name) 表中存放的record的名字\r\n</span>          attributes = <span class=\"paren3\">[<span class=\"code\">key, val</span>]</span>,         <span class=\"comment\">% [Atom] record中的属性名字\r\n</span>          user_properties = <span class=\"paren3\">[<span class=\"code\"></span>]</span>,            <span class=\"comment\">% [Record]\r\n</span>          frag_properties = <span class=\"paren3\">[<span class=\"code\"></span>]</span>,            <span class=\"comment\">% [{Key, Val]\r\n</span>          storage_properties = <span class=\"paren3\">[<span class=\"code\"></span>]</span>,         <span class=\"comment\">% [{Key, Val]\r\n</span>                  cookie = <span class=\"macro\">?unique_cookie,</span>         <span class=\"comment\">% Term\r\n</span>                  version = <span class=\"paren3\">{<span class=\"code\"><span class=\"paren4\">{<span class=\"code\">2, 0</span>}</span>, <span class=\"paren4\">[<span class=\"code\"></span>]</span></span>}</span></span>}</span></span>)</span>.        <span class=\"comment\">% {{Integer, Integer}, [Node]}</span></span></code></pre>\n\n<p>Erlang的cstruct非常简明扼要的定义了Mnesia的一张表的属性。对Mnesia来讲，一张表最基本需要包含下面的信息\r\n1. name，表名字\r\n1. type，存储模式\r\n1. access_mode，访问权限\r\n1. record_name，存储字段的record名称\r\n1. attributes，字段名称</p>\n\n<p>剩下的字段，更多是和集群，容错以及分片相关的。因为有分片技术的存在，就不要再说Mnesia存储上限是4G啥的了。</p>\n\n<h2>schema创建</h2>\n\n<h3>确认无schema阶段</h3>\n\n<p>在mnesia_bup的create_schema中会使用mnesia_schema:ensure_no_schema来确认单节点或集群的所有节点上都没有schema相关的数据。\r\n<code>Erlang\r\n%尝试读取远程的schema\r\nensure_no_schema([H|T]) when is_atom(H) -&gt;\r\n    case rpc:call(H, ?MODULE, remote_read_schema, []) of\r\n        {badrpc, Reason} -&gt;\r\n            %% 返回建表失败\r\n            {H, {&quot;All nodes not running&quot;, H, Reason}};\r\n        {ok,Source, _} when Source /= default -&gt;\r\n            %% 返回的source是非default的时候，就代表已经存在了schema表\r\n            {H, {already_exists, H}};\r\n        _ -&gt;\r\n            ensure_no_schema(T)\r\n    end;\r\nensure_no_schema([H|_]) -&gt;\r\n    {error,{badarg, H}};\r\nensure_no_schema([]) -&gt;\r\n    ok.\r\n</code> \r\nensure_no_schema是通过Erlang/OTP平台的rpc模块来尝试读取所有节点是否存在，如果存在了会告诉发起创建请求的进程already_exists，如果某个节点无法链接，就会报错。如果在这阶段出现异常，会立刻终止创建。</p>\n\n<h3>构建临时备份阶段</h3>\n\n<p>mnesia_bup会在mnesia数据目录下创建一个节点名＋时间戳的临时文件，类似 nonode@nohost1513217595933336.TMP 这种形式。之后会通过make_initial_backup来从0构建一个backup文件，用来创建Mnesia的schema。\r\n<code>Erlang\r\nmake_initial_backup(Ns, Opaque, Mod) -&gt;\r\n    %%获取最开始的元数据表\r\n    %%元数据是cstruct的[{key,value}]形式\r\n    Orig = mnesia_schema:get_initial_schema(disc_copies, Ns),\r\n    %% 删除掉storage_properties和majority这两个字段\r\n    Modded = proplists:delete(storage_properties, proplists:delete(majority, Orig)),\r\n    %% 向schema表中写入表名和cstruct\r\n    Schema = [{schema, schema, Modded}],\r\n    O2 = do_apply(Mod, open_write, [Opaque], Opaque),\r\n    %写入日志头\r\n    %% 包括日志版本，日志类型，mnesia版本，节点名称，生成时间\r\n    %% 这里日志版本1.2  类型 backup_log\r\n    O3 = do_apply(Mod, write, [O2, [mnesia_log:backup_log_header()]], O2),\r\n    %写入schema数据\r\n    O4 = do_apply(Mod, write, [O3, Schema], O3),\r\n    %%生成Opaque所代表的文件\r\n    O5 = do_apply(Mod, commit_write, [O4], O4),\r\n    {ok, O5}.\r\n</code>\r\n先通过mnesia_schema:get_initial_schema构建出一个schema的cstruct结构，然后通过mnesia_backup的日志模式，<code>[{schema, schema, Modded}]</code>写入的日志文件中。在写入真实数据前，会先写入一个<code>mnesia_log:backup_log_header()</code>的日志头，用来说明是什么日志和日志的版本。</p>\n\n<h3>安装备份阶段</h3>\n\n<p>mnesia_bup会使用do_install_fallback来将上一个阶段构建出来的临时备份安装到单节点或集群上。\r\n安装过程可以明确为以下几步：\r\n1. 初始化安装进程\r\n1. 初始化安装状态\r\n1. 在集群个节点上创建fallback_receiver\r\n1. 从上阶段临时文件中读取数据，并同步到集群各个节点上</p>\n\n<pre><code><span class=\"code\"><span class=\"function\">install_fallback_master</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">ClientPid</span>, <span class=\"variable\">FA</span></span>)</span> -&gt;\r\n    <span class=\"comment\">%% 捕获退出异常，关联进程崩溃，但是并不真正捕获\r\n</span>    <span class=\"comment\">%% 而是防止崩溃后引起当前进程退出，打断元数据创建\r\n</span>    <span class=\"symbol\">process_flag</span><span class=\"paren1\">(<span class=\"code\">trap_exit, true</span>)</span>,\r\n    <span class=\"comment\">%% 设置状态\r\n</span>    <span class=\"variable\">State</span> = <span class=\"paren1\">{<span class=\"code\">start, <span class=\"variable\">FA</span></span>}</span>,\r\n    <span class=\"comment\">%% 拿出日志文件\r\n</span>    <span class=\"variable\">Opaque</span> = <span class=\"variable\">FA#fallback_args</span>.opaque,\r\n    <span class=\"variable\">Mod</span> = <span class=\"variable\">FA#fallback_args</span>.module,\r\n    <span class=\"variable\">Res</span> = <span class=\"paren1\">(<span class=\"code\"><span class=\"symbol\">catch</span> iterate<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">Mod</span>, <span class=\"symbol\">fun</span> restore_recs/4, <span class=\"variable\">Opaque</span>, <span class=\"variable\">State</span></span>)</span></span>)</span>,\r\n    <span class=\"symbol\">unlink</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">ClientPid</span></span>)</span>,\r\n    <span class=\"variable\">ClientPid</span> ! <span class=\"paren1\">{<span class=\"code\"><span class=\"symbol\">self</span><span class=\"paren2\">(<span class=\"code\"></span>)</span>, <span class=\"variable\">Res</span></span>}</span>,\r\n    <span class=\"symbol\">exit</span><span class=\"paren1\">(<span class=\"code\">shutdown</span>)</span>.</span></code></pre>\n\n<p>安装备份文件的时候，会创建一个进程来进行备份文件安装。该进程为了防止请求进程打断安装过程，会进行退出异常捕获。</p>\n\n<pre><code><span class=\"code\"><span class=\"attribute\">-spec</span> fallback_receiver<span class=\"paren1\">(<span class=\"code\">pid<span class=\"paren2\">(<span class=\"code\"></span>)</span>, fallback_args<span class=\"paren2\">(<span class=\"code\"></span>)</span></span>)</span> -&gt; no_return<span class=\"paren1\">(<span class=\"code\"></span>)</span>.\r\n<span class=\"comment\">%Master,在此处表示，整个mnesia集群在create_schema的时候的发起者\r\n</span><span class=\"function\">fallback_receiver</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Master</span>, <span class=\"variable\">FA</span></span>)</span> -&gt;\r\n    <span class=\"symbol\">process_flag</span><span class=\"paren1\">(<span class=\"code\">trap_exit, true</span>)</span>,\r\n<span class=\"comment\">%将自己注册到本地名字库，防止创建出另一个fallback_receiver进程\r\n</span>    <span class=\"symbol\">case</span> <span class=\"symbol\">catch</span> <span class=\"symbol\">register</span><span class=\"paren1\">(<span class=\"code\">mnesia_fallback, <span class=\"symbol\">self</span><span class=\"paren2\">(<span class=\"code\"></span>)</span></span>)</span> <span class=\"symbol\">of</span>\r\n        <span class=\"paren1\">{<span class=\"code\"><span class=\"atom\">'EXIT'</span>, <span class=\"variable\">_</span></span>}</span> -&gt;\r\n            <span class=\"variable\">Reason</span> = <span class=\"paren1\">{<span class=\"code\">already_exists, <span class=\"symbol\">node</span><span class=\"paren2\">(<span class=\"code\"></span>)</span></span>}</span>,\r\n            local_fallback_error<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Master</span>, <span class=\"variable\">Reason</span></span>)</span>;\r\n        true -&gt;\r\n            <span class=\"variable\">FA2</span> = check_fallback_dir<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Master</span>, <span class=\"variable\">FA</span></span>)</span>,\r\n            <span class=\"variable\">Bup</span> = <span class=\"variable\">FA2#fallback_args</span>.fallback_bup,\r\n            <span class=\"comment\">%检查是否有backup\r\n</span>            <span class=\"symbol\">case</span> mnesia_lib:exists<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Bup</span></span>)</span> <span class=\"symbol\">of</span>\r\n                true -&gt;\r\n                    <span class=\"comment\">%如果有则报错\r\n</span>                    <span class=\"variable\">Reason2</span> = <span class=\"paren1\">{<span class=\"code\">already_exists, <span class=\"symbol\">node</span><span class=\"paren2\">(<span class=\"code\"></span>)</span></span>}</span>,\r\n                    local_fallback_error<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Master</span>, <span class=\"variable\">Reason2</span></span>)</span>;\r\n                false -&gt;\r\n                    <span class=\"comment\">%如果没有，创建新的backup的临时文件\r\n</span>                    <span class=\"variable\">Mod</span> = mnesia_backup,\r\n                    <span class=\"comment\">%% 删除FALLBACK.TMP文件\r\n</span>                    <span class=\"variable\">Tmp</span> = <span class=\"variable\">FA2#fallback_args</span>.fallback_tmp,\r\n                    <span class=\"variable\">R</span> = #restore<span class=\"paren1\">{<span class=\"code\">mode = replace,\r\n                                 bup_module = <span class=\"variable\">Mod</span>,\r\n                                 bup_data = <span class=\"variable\">Tmp</span></span>}</span>,\r\n                    file:delete<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Tmp</span></span>)</span>,\r\n                    <span class=\"comment\">%开始接收fallback信息\r\n</span>                    <span class=\"symbol\">case</span> <span class=\"symbol\">catch</span> fallback_receiver_loop<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Master</span>, <span class=\"variable\">R</span>, <span class=\"variable\">FA2</span>, schema</span>)</span> <span class=\"symbol\">of</span>\r\n                        <span class=\"paren1\">{<span class=\"code\">error, <span class=\"variable\">Reason</span></span>}</span> -&gt;\r\n                            local_fallback_error<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Master</span>, <span class=\"variable\">Reason</span></span>)</span>;\r\n                        <span class=\"variable\">Other</span> -&gt;\r\n                            <span class=\"symbol\">exit</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Other</span></span>)</span>\r\n                    <span class=\"symbol\">end</span>\r\n            <span class=\"symbol\">end</span>\r\n    <span class=\"symbol\">end</span>.</span></code></pre>\n\n<p>fallback_receiver进程会在集群的每个节点上创建一个，其中的Master就是上面所说的install_fallback_master这个函数所在的进程。fallback_receiver只是做一些基本的防止重入和错误检查，真正的业务是在fallback_receiver_loop函数中处理。</p>\n\n<pre><code><span class=\"code\"><span class=\"function\">fallback_receiver_loop</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Master</span>, <span class=\"variable\">R</span>, <span class=\"variable\">FA</span>, <span class=\"variable\">State</span></span>)</span> -&gt;\r\n    <span class=\"symbol\">receive</span>\r\n        <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Master</span>, <span class=\"paren2\">{<span class=\"code\">start, <span class=\"variable\">Header</span>, <span class=\"variable\">Schema</span></span>}</span></span>}</span> <span class=\"symbol\">when</span> <span class=\"variable\">State</span> =:= schema -&gt;\r\n            <span class=\"variable\">Dir</span> = <span class=\"variable\">FA#fallback_args</span>.mnesia_dir,\r\n            throw_bad_res<span class=\"paren1\">(<span class=\"code\">ok, mnesia_schema:opt_create_dir<span class=\"paren2\">(<span class=\"code\">true, <span class=\"variable\">Dir</span></span>)</span></span>)</span>,\r\n            <span class=\"comment\">%% 创建FALLBACK.TMP文件\r\n</span>            <span class=\"variable\">R2</span> = safe_apply<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">R</span>, open_write, <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">R#restore</span>.bup_data</span>]</span></span>)</span>,\r\n            <span class=\"variable\">R3</span> = safe_apply<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">R2</span>, write, <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">R2#restore</span>.bup_data, <span class=\"paren3\">[<span class=\"code\"><span class=\"variable\">Header</span></span>]</span></span>]</span></span>)</span>,\r\n            <span class=\"variable\">BupSchema</span> = <span class=\"paren1\">[<span class=\"code\">schema2bup<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">S</span></span>)</span> || <span class=\"variable\">S</span> &lt;- <span class=\"variable\">Schema</span></span>]</span>,\r\n            <span class=\"variable\">R4</span> = safe_apply<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">R3</span>, write, <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">R3#restore</span>.bup_data, <span class=\"variable\">BupSchema</span></span>]</span></span>)</span>,\r\n            <span class=\"variable\">Master</span> ! <span class=\"paren1\">{<span class=\"code\"><span class=\"symbol\">self</span><span class=\"paren2\">(<span class=\"code\"></span>)</span>, ok</span>}</span>,\r\n            <span class=\"comment\">%% schema的日志已经写入文件了\r\n</span>            <span class=\"comment\">%% 状态切换到接收records\r\n</span>            fallback_receiver_loop<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Master</span>, <span class=\"variable\">R4</span>, <span class=\"variable\">FA</span>, records</span>)</span>;\r\n\r\n        <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Master</span>, <span class=\"paren2\">{<span class=\"code\">records, <span class=\"variable\">Recs</span></span>}</span></span>}</span> <span class=\"symbol\">when</span> <span class=\"variable\">State</span> =:= records -&gt;\r\n            <span class=\"variable\">R2</span> = safe_apply<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">R</span>, write, <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">R#restore</span>.bup_data, <span class=\"variable\">Recs</span></span>]</span></span>)</span>,\r\n            <span class=\"variable\">Master</span> ! <span class=\"paren1\">{<span class=\"code\"><span class=\"symbol\">self</span><span class=\"paren2\">(<span class=\"code\"></span>)</span>, ok</span>}</span>,\r\n            fallback_receiver_loop<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Master</span>, <span class=\"variable\">R2</span>, <span class=\"variable\">FA</span>, records</span>)</span>;\r\n        <span class=\"comment\">%收到swap，进行commit，并将临时文件重命名为backup文件\r\n</span>        <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Master</span>, swap</span>}</span> <span class=\"symbol\">when</span> <span class=\"variable\">State</span> =/= schema -&gt;\r\n            <span class=\"macro\">?eval_debug_fun(</span><span class=\"paren1\">{<span class=\"code\"><span class=\"macro\">?MODULE,</span> fallback_receiver_loop, pre_swap</span>}</span>, <span class=\"paren1\">[<span class=\"code\"></span>]</span>),\r\n            safe_apply<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">R</span>, commit_write, <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">R#restore</span>.bup_data</span>]</span></span>)</span>,\r\n            <span class=\"variable\">Bup</span> = <span class=\"variable\">FA#fallback_args</span>.fallback_bup,\r\n            <span class=\"variable\">Tmp</span> = <span class=\"variable\">FA#fallback_args</span>.fallback_tmp,\r\n            <span class=\"comment\">%% 立刻重命名文件，将FALLBACK.TMP重命名为FALLBACK.BUP\r\n</span>            throw_bad_res<span class=\"paren1\">(<span class=\"code\">ok, file:rename<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">Tmp</span>, <span class=\"variable\">Bup</span></span>)</span></span>)</span>,\r\n            <span class=\"symbol\">catch</span> mnesia_lib:set<span class=\"paren1\">(<span class=\"code\">active_fallback, true</span>)</span>,\r\n            <span class=\"macro\">?eval_debug_fun(</span><span class=\"paren1\">{<span class=\"code\"><span class=\"macro\">?MODULE,</span> fallback_receiver_loop, post_swap</span>}</span>, <span class=\"paren1\">[<span class=\"code\"></span>]</span>),\r\n            <span class=\"variable\">Master</span> ! <span class=\"paren1\">{<span class=\"code\"><span class=\"symbol\">self</span><span class=\"paren2\">(<span class=\"code\"></span>)</span>, ok</span>}</span>,\r\n            fallback_receiver_loop<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Master</span>, <span class=\"variable\">R</span>, <span class=\"variable\">FA</span>, stop</span>)</span>;\r\n\r\n        <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Master</span>, stop</span>}</span> <span class=\"symbol\">when</span> <span class=\"variable\">State</span> =:= stop -&gt;\r\n            stopped;\r\n\r\n        <span class=\"variable\">Msg</span> -&gt;\r\n            safe_apply<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">R</span>, abort_write, <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">R#restore</span>.bup_data</span>]</span></span>)</span>,\r\n            <span class=\"variable\">Tmp</span> = <span class=\"variable\">FA#fallback_args</span>.fallback_tmp,\r\n            file:delete<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Tmp</span></span>)</span>,\r\n            <span class=\"symbol\">throw</span><span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">error, <span class=\"string\">\"Unexpected msg fallback_receiver_loop\"</span>, <span class=\"variable\">Msg</span></span>}</span></span>)</span>\r\n    <span class=\"symbol\">end</span>.</span></code></pre>\n\n<p>fallback_receiver_loop循环State的初始值为{start,FA}，接着不断从发起者出接受schema数据和record数据，并写入FALLBACK.TMP中，当发起者传送完所有数据会要求fallback_receiver进程将FALLBACK.TMP文件重命名为FALLBACK.BUP。</p>\n\n<h2>总结</h2>\n\n<p>至此，schema创建的第一个阶段已经结束，但是发现mnesia数据目录下并没有生成schema.DAT文件，在后续的文章中将会介绍如何生成schema.DAT文件</p>\n","id":105511867854498659616064320119005389003,"intro":"Erlang/Elixir","published":false,"published_at":63734916125,"title":"深入浅出 Mnesia－schema 创建 (1)","topic_id":1},{"content":"<h2>你是我的好友</h2>\n\n<p><a href=\"https://www.ttalk.im/topics/55\" >前篇文章</a>中介绍了，什么是花名册和出席的机制。从数据关系的层面上看，这样已经构成了好友关系。在仔细观察这个流程就会发现，用户A添加用B为好友根本就没有得到用户B的准许，但是实际上并不是这样的，要真正完成好友添加，不单单是在花名册上完成好友关系的添加，还要进行出席订阅。</p>\n\n<h2>什么是出席订阅</h2>\n\n<p>为了保护XMPP用户们的隐私, 出席信息仅向某个用户已经批准的其他实体披露。当某个同意允许其他实体察看其出席信息时, 该实体被称为对该用户的出席信息有一个&ldquo;订阅&rdquo;。 一个对某用户的出席信息有订阅的实体或一个用户对其有出席信息订阅的实体被称为&ldquo;联系人&rdquo; ，这才真正完成XMPP的好友添加。</p>\n\n<p>从此处可以看出，当用A想要添加用B为好友的时候，是需要B用户同意的。从这也不难看出来，真正好友的添加流程都集中在XMPP的出席部分，而不是花名册部分，花名册只是在负责在服务器上保存和管理用户的联系人。换句话说，一个规范的客户端应当先进行出席订阅接着才会进行花名册保存。</p>\n\n<h2>eJabberd是如何处理出席的</h2>\n\n<h3>mod_roster 如何处理出席订阅</h3>\n\n<p>eJabberd 对出席订阅和相关操作并没有重新定义，而是直接复用了roster记录\r\n<code>Erlang\r\n-record(roster, {usj,\r\n                 us,\r\n                 jid,\r\n                 name = &lt;&lt;&gt;&gt;,\r\n                 subscription = none :: both | from | to | none | remove,\r\n                 ask = none,\r\n                 groups = [],\r\n                 askmessage = &lt;&lt;&gt;&gt;,\r\n                 xs = []}).\r\n</code>\r\n在这里，subscription代表着订阅关系，ask代表正在进行出席的操作，当出席订阅结束后该字段的意义就不重要了。</p>\n\n<p>所有出席的订阅处理都被<code>mod_roster</code>注册在<code>roster_in_subscription</code>和<code>roster_out_subscription</code>这两个hook上，最终交给<code>mod_roster:process_subscription_transaction</code>函数进行处理</p>\n\n<h3>出席订阅</h3>\n\n<h4>好友申请</h4>\n\n<p>用户A要添加用B为好友，首先要做的就是要生成一个出站的出席订阅请求，也就是我们说的好友申请\r\n<code>XML\r\n &lt;presence id='xk3h1v69'\r\n              to='juliet@example.com'\r\n              type='subscribe'/&gt;\r\n</code></p>\n\n<h5>出站处理</h5>\n\n<p>出站指的是用户A将申请发送到服务器上，并要求服务器更新A相关状态并转发给用户B的过程。<br/>\neJabberd的服务器接收到该请求后，会使用<code>roster_out_subscription</code>的hook进行处理，在处理过程中如果发现roster的存储中没有用户到目标用的条目会在内存中建立一个默认条目。</p>\n\n<p>并且根据下面的规则，将这个roster的ask状态更新为out，subscription状态不变，存储到roster存储中，并将该出席信息转发给目标用户。\r\n<code>Erlang\r\nout_state_change(none, none, subscribe) -&gt; {none, out};\r\n</code></p>\n\n<h5>入站处理</h5>\n\n<p>入站指的是服务器将用户A的请求发送给用户B，并在服务器上更新B的相关状态的过程。<br/>\neJabberd在入站的过程中，ejabberd_sm会发现这个好友请求，并使用<code>roster_in_subscription</code>进行处理，在处理过程中如果发现roster的存储中没有用户到目标用的条目会在内存中建立一个默认条目。</p>\n\n<p>并且根据下面的规则，将这个roster的ask状态更新为in，subscription状态不变，存储到roster存储中，并将该出席信息转发给目标用户。</p>\n\n<pre><code><span class=\"code\"><span class=\"function\">in_state_change</span><span class=\"paren1\">(<span class=\"code\">none, none, subscribe</span>)</span> -&gt; <span class=\"paren1\">{<span class=\"code\">none, in</span>}</span>;</span></code></pre>\n\n<h4>好友应答</h4>\n\n<p>用户B收到用户A的好友申请后，就要做出回答，也就是我们说的好友批准流程，好友应答有两种情况\r\n``` XML\r\n<!-- 同意的情况 -->\r\n<presence id='h4v1c4kj'\r\n              to='romeo@example.net'\r\n              type='subscribed'/></p>\n\n<!-- 不同意的情况 -->\n\n<presence id='tb2m1b59'\r\n              to='romeo@example.net'\r\n              type='unsubscribed'/>\n\n<pre><code>##### 出站处理\r\n此时的出站，指的是用户B将好友应答发送给服务器，并要求服务器更新B的相关状态，并将申请转发给A的过程\r\n同样eJabberd的服务器接收到该请求后，会使用`roster_out_subscription`的hook进行处理，这个时候会从roster存储中读取出ask状态为in，subscription状态为none的记录。\r\n\r\n根据下面的规则进行状态更新\r\n``` Erlang\r\nout_state_change(none, in, subscribed) -&gt; {from, none};\r\nout_state_change(none, in, unsubscribed) -&gt; {none, none};</code></pre>\n\n<ul>\n<li>不同意订阅，会返回{none,none}，在<code>mod_roster:process_subscription_transaction</code>的处理过程中将会将记录删除</li>\n<li>如果同意订阅，会返回{from, none}，会将subscription状态更新为from，ask状态更新为none并保存</li>\n</ul>\n\n<h5>入站处理</h5>\n\n<p>此时的入站，指服务器将B的应答发送给A，并将更新状态并将消息发送给A的过程\r\n同样eJabberd在入站的过程中，ejabberd_sm会发现这个好友请求，并使用<code>roster_in_subscription</code>进行处理，这个时候会从roster存储中读取出ask状态为out，subscription状态为none的记录。</p>\n\n<p>根据下面的规则进行状态更新\r\n<code>Erlang\r\nin_state_change(none, out, subscribed) -&gt; {to, none};\r\nin_state_change(none, out, unsubscribed) -&gt; {none, none};\r\n</code>\r\n- 不同意订阅，会返回{none,none}，在<code>mod_roster:process_subscription_transaction</code>的处理过程中将会将记录删除\r\n- 如果同意订阅，会返回{from, none}，会将subscription状态更新为to，ask状态更新为none并保存</p>\n\n<h2>总结</h2>\n\n<p>从整个出席订阅也就是我们常说的好友添加过程中，可以看出XMPP是非常严谨的，将好友添加合理分配给，请求方，服务器和被请求方进行处理，各司其职。本篇中还有几个处理并没有介绍，其中包括，出席订阅取消既好友删除，出席订阅预批准既好友添加白名单。</p>\n","id":127671432853250282997048840720624944412,"intro":"XMPP","published":false,"published_at":63734916126,"title":"eJabberd 的花名册和出席 (2)","topic_id":1},{"content":"<h2>为什么探讨这个话题</h2>\n\n<p><a href=\"https://www.emqx.io/?utm_source=ttalk.im&utm_medium=website&utm_campaign=Tech%2520Talk\">EMQ</a> 作为一个非常不错的开源MQTT服务器，被广泛使用。虽然广泛使用，但是对EMQ的消耗并没有特别多的了解，因此本篇将讲述下一个客户端链接到EMQ服务器上会产生多少消耗，以便在部署服务器前做好一定的规划。</p>\n\n<h2>Erlang进程消耗</h2>\n\n<p>EMQ对客户端链接使用链接进程(<code>emqtt_client</code>)和session进程(<code>emqtt_session</code>)分开的策略。 当一个mqtt的客户端连接到EMQ的服务器上的时候，首先会建立一个负责管理连接的进程(<code>emqtt_client</code>)，当验证客户端有效后会建立另一个进程(<code>emqtt_session</code>)，负责该客户端的会话。</p>\n\n<p>在EMQ中，每一个clientID只能登录一次，因此后登录的客户端会将先登录的客户端踢下线。</p>\n\n<h2>主要内存消耗</h2>\n\n<h3>数据表</h3>\n\n<p>当一个客户端成功完成了验证，EMQ会在<code>mqtt_session</code>中添加一个表项目，同时会在<code>mqtt_local_session</code>和<code>mqtt_client</code>这两张ets表中添加表项目。</p>\n\n<h3>进程上下文</h3>\n\n<p>链接进程(<code>emqtt_client</code>)负责接收客户端发来的数据和接受服务器内部要发送给客户端的数据，并使用编解码器进行编解码，因此链接进程的上下文消耗，主要取决接收到的数据包大小和将要发送的数据包大小和数量。</p>\n\n<p>session进程(<code>emqtt_session</code>)会保持一个inflight队列，用来对QoS大于0的消息进行应答等待，默认会保存32个消息在等待应答，如果超过这个量级就会放入等待队列。因此session进程(<code>emqtt_session</code>)的主要内存消耗，取决于多少等待应答的消息，以及这些需要应答消息的数据包的大小。</p>\n\n<h2>主要CPU消耗</h2>\n\n<h3>定时器</h3>\n\n<p>链接进程(<code>emqtt_client</code>)，默认会启动一个心跳定时器，定期的检查链接是否存活。session进程(<code>emqtt_session</code>)同样会开启一个重新发送定时器，用来检查QoS大于0的消息的infligt响应，当客户端发布QoS为2的消息时还会开启另外一个定时器，用来检测REPL信息的响应，当然session进程(<code>emqtt_session</code>)有可能会在客户端离线后保持一段时间，因此在这段时间会建立一个超时退出的定时器。因此session进程(<code>emqtt_session</code>)在某一个时刻会同时存在三个定时器。</p>\n\n<h3>监控</h3>\n\n<p>session进程(<code>emqtt_session</code>)为了发现链接进程的退出，会建立一个针对链接进程的监控。而在客户端上线成功后后在向<code>mqtt_local_session</code>和<code>mqtt_client</code>这两张ets表中添加项目的时候，会分别建立两个监控，用来监控session进程(<code>emqtt_session</code>)和链接进程(<code>emqtt_client</code>)的退出。</p>\n\n<h3>进程消息</h3>\n\n<p>因为EMQ使用了链接进程(<code>emqtt_client</code>)和session进程(<code>emqtt_session</code>)分开的策略，因此产生进程消息传递是无法避免的。因为session进程(<code>emqtt_session</code>)会负责接收服务器发送给客户端的消息，并进行预先处理，处理完之后再交付给链接进(<code>emqtt_client</code>)程进行发送。</p>\n\n<p>当使用持久化session的时候，session进程(<code>emqtt_session</code>)的查找和恢复时也会产生大量的进程消息。</p>\n\n<h2>总结</h2>\n\n<p>从上面的介绍中，可以看出，在部署一个EMQ服务器前需要考虑，一个客户端平均消息的量级，QoS占比和数据包大小，同时根据有多少客户端进行CPU频率和数量的选择。</p>\n\n<p>当运营一个EMQ服务器的时候，如果在消息量级和客户端数量没有明显变化的情况下，CPU突然飙升，就要去考虑下是否出现客户端频繁上下线的情况。当然这只是一个简单的例子，还有很多情况在此就不一一列举了。</p>\n","id":99283148354289491372501535021179491559,"intro":"MQTT服务器EMQ的代码分析和调优。","published":true,"published_at":63734916126,"title":"EMQ客户链接的资源消耗","topic_id":1},{"content":"<h2>什么宏</h2>\n\n<p>宏（Macro)，是一种批量处理的称谓。一般说来，宏是一种规则或模式，或称语法替换 ，用于说明某一特定输入（通常是字符串）如何根据预定义的规则转换成对应的输出（通常也是字符串)。这种替换在预编译时进行，称作宏展开。\n说道宏，就不得不提一个经典语言和它的宏。</p>\n\n<h3>Lisp</h3>\n\n<p>Lisp的特点</p>\n\n<ol>\n<li>数据就代码，代码就是数据</li>\n<li>LISP中所有的都是list, 当然也可以叫做S表达式。</li>\n<li>如果把list中的第一元素视为函数，该list就可视作代码一样运行。术语叫做求值, evaluate。当然也可以不求值，此时list就是数据。因此这里引出一个重要概念 ，代码也是数据，一切皆为数据，一切都是list。</li>\n</ol>\n\n<h3>Lisp的宏</h3>\n\n<ol>\n<li>如果一个list传递给lisp函数，则先被求值为atom（一个特殊的list，不能再被求值）后再传递进去 如果一个list传递给lisp宏，则不被求值，而将其完整的传递进去，至于宏里面怎么干，随便宏的实现者怎么玩。像C的宏吧，不过C的宏只是文本替换，还是简单了点。</li>\n<li>宏可以返回的是一个list，而且被视作可以求值的list，也就是代码。</li>\n<li>两阶段执行，第一阶段在编译期，称之为展开，第二阶段在运行期，称之为计算。宏在展开时，并不对实参求值，只把宏定义中对形参的引用简单替换为实参。实参在计算阶段时才求值。</li>\n</ol>\n\n<h2>Elixir是什么</h2>\n\n<p>Elixir 是一个基于Erlang虚拟机强大的类Ruby语法的编程语言。</p>\n\n<h2>Elixir的宏</h2>\n\n<p>Elixir也是支持宏的，并且Elixir的宏也是异常强大的，也做到了两阶段执行。\n但是今天要介绍的主要是关于Elixir中use和@before_compile的部分。</p>\n\n<h3>代码例子</h3>\n\n<pre><code>defmodule MyModule do\n  use MyPlugBuilder\n\n  plug :hello\n  plug :world, good: :morning\nend\n</code></pre>\n\n<pre><code>\ndefmodule MyPlugBuilder do\n\n  defmacro __using__(_opts) do\n    quote do\n      import MyPlugBuilder, only: [plug: 1, plug: 2]\n      Module.register_attribute(__MODULE__, :plugs, accumulate: :true)\n      @before_compile MyPlugBuilder\n    end\n  end\n\n  defmacro plug(plug, opts \\\\ []) do\n    quote do\n      @plugs {unquote(plug), unquote(opts)}\n    end\n  end\n\n  defmacro __before_compile__(env) do\n    plugs = Module.get_attribute(env.module, :plugs)\n    quote do\n      def plugs, do: unquote(plugs)\n    end\n  end\nend\n</code></pre>\n\n<h4>MyPlugBuilder的展开</h4>\n\n<h4>第一步</h4>\n\n<pre><code>\ndefmodule MyModule do\n  # ----\n  # use MyPlugBuilder\n  # ---- ↓\n  require MyPlugBuilder\n  MyPlugBuilder.__using__([])\n  # ----\n\n  plug :hello\n  plug :world, good: :morning\nend\n</code></pre>\n\n<p>因为use MyPlugBuilder这句话会展开成\n    require MyPlugBuilder\n    MyPlugBuilder.<strong>using</strong>\nMyModule 会请求引入 MyPlugBuilder，接着会调用<code>__using__</code>宏，并且默认参数为[]</p>\n\n<h4>第二步</h4>\n\n<pre><code>\ndefmodule MyModule do\n  require MyPlugBuilder\n\n  # ----\n  # MyPlugBuilder.__using__([])\n  # ---- ↓\n  import MyPlugBuilder, only: [plug: 1, plug: 2]\n  Module.register_attribute(__MODULE__, :plugs, accumulate: :true)\n  @before_compile MyPlugBuilder\n  # ----\n\n  plug :hello\n  plug :world, good: :morning\nend</code></pre>\n\n<p><code>__using__</code>宏会立刻被执行，相当于立刻将MyPlugBuilder的函数引入进来，并且给MyModule注册了一个叫做plugs的模块属性。同时告诉编译器，稍后编译MyPlugBuilder的时候，调用<code>__before_compile__</code>。</p>\n\n<h4>第三步</h4>\n\n<pre><code>defmodule MyModule do\n  require MyPlugBuilder\n\n  import MyPlugBuilder, only: [plug: 1, plug: 2]\n  Module.register_attribute(__MODULE__, :plugs, accumulate: :true)\n  @before_compile MyPlugBuilder\n\n  # ----\n  # plug :hello\n  # plug :world, good: :morning\n  # ---- ↓\n  @plugs {:hello, []}\n  @plugs {:world, [good: :morning]}\n  # ----\nend\n</code></pre>\n\n<p>此时还没有展开__before_compile__，而是先展开从MyPlugBuilder模块中import进来的plug宏，完成相关定义内容</p>\n\n<h4>第四步</h4>\n\n<pre><code>defmodule MyModule do\n  require MyPlugBuilder\n\n  import MyPlugBuilder, only: [plug: 1, plug: 2]\n  Module.register_attribute(__MODULE__, :plugs, accumulate: :true)\n  @before_compile MyPlugBuilder\n\n  @plugs {:hello, []}\n  @plugs {:world, [good: :morning]}\n\n  MyPlugBuilder.__before_compile__(__ENV__) end\n</code></pre>\n\n<p>此时展开了MyPlugBuilder中<code>__before_compile__</code>宏，完成整个展开过程。</p>\n\n<p>一个复杂点的例子</p>\n\n<pre><code>\ndefmodule MyPlugBuilder do\n\n  defmacro __using__(_opts) do\n    quote do\n      import MyPlugBuilder, only: [plug: 1, plug: 2, aplug: 1]\n      Module.register_attribute(__MODULE__, :plugs, accumulate: :true)\n      IO.puts __MODULE__\n      IO.puts unquote(__MODULE__)\n      @before_compile MyPlugBuilder\n      unquote(defs())\n    end\n  end\n\n  # `plug` 本体\n  defmacro plug(plug, opts \\\\ []) do\n    quote do\n      IO.puts unquote(plug)\n      @plugs {unquote(plug), unquote(opts)}\n    end\n  end\n\n  defmacro aplug(plug) do\n      xplug(plug, [])\n  end\n\n  defp defs() do\n    IO.puts \"aplug\"\n    quote unquote: false do\n      IO.puts \"eval\"\n      var!(pplug, MyPlugBuilder) = fn resource -&gt;\n        IO.puts resource\n      end\n    end\n  end\n\n  defp xplug(plug,opts \\\\ []) do\n    quote do\n      plug = unquote(plug)\n      var!(pplug, MyPlugBuilder).(plug)\n    end\n  end\n  \n  defmacro __before_compile__(env) do\n    plugs = Module.get_attribute(env.module, :plugs)\n    IO.puts \"__before_compile__\"\n    conn = compile(env)\n    quote do\n      def plugs, do: unquote(plugs)\n      def plug_builder_call(unquote(conn)), do: IO.puts conn\n    end\n  end\n\n  def compile(env) do\n    conn = quote do: conn\n    conn\n  end\n\nend\n</code></pre>\n\n<p>展开后代码上的差异</p>\n\n<pre><code>\ndefmodule MyModule do\n  # ----\n  # use MyPlugBuilder\n  # ---- ↓\n  require MyPlugBuilder\n  MyPlugBuilder.__using__([])\n  # ----\n\n  plug :hello\n  plug :world, good: :morning\nend\n</code></pre>\n\n<pre><code>\ndefmodule MyModule do\n  require MyPlugBuilder\n\n  # ----\n  # MyPlugBuilder.__using__([])\n  # ---- ↓\n  MyPlugBuilder.defs()\n  import MyPlugBuilder, only: [plug: 1, plug: 2, aplug: 1]\n  Module.register_attribute(__MODULE__, :plugs, accumulate: :true)\n  IO.puts __MODULE__\n  IO.puts \"MyPlugBuilder\"\n  @before_compile MyPlugBuilder\n  # ----\n\n  plug :hello\n  plug :world, good: :morning\nend\n</code></pre>\n\n<p>你可能已经注意到了MyPlugBuilder的defs()函数先于两个IO.puts执行了。</p>\n\n<h2>总结</h2>\n\n<p>可以在编译期间展开在执行阶段求值实参的宏，确实可以给我们带来很大的方便，但是也大大带来了危险性。\n宏乃屠龙之技，但是用的时候要慎之再慎。</p>\n\n<p><a href=\"https://github.com/DavidAlphaFox/elixir\" >Elixir 1.1.1</a> 代码分析(未完成)</p>\n","id":93623414883687998533644210104832492951,"intro":"介绍Lisp宏和Elixir宏的，以及通过示例代码，一步步为读者介绍Elixir的宏是如何在编译的过程中进行展开的","published":true,"published_at":63738064356,"title":"带你了解Elixir的宏","topic_id":1},{"content":"<h2>什么是Trap机制</h2>\n\n<p>在分析erlang:send的bif时候发现了一个BIF_TRAP这一系列宏。参考了Erlang自身的一些描述，这些宏是为了实现一种叫做Trap的机制。Trap机制中将Erlang的代码直接引入了Erts中，可以让C函数直接&ldquo;使用&rdquo;这些Erlang的函数。</p>\n\n<h2>为什么要实现Trap机制</h2>\n\n<ol>\n<li>将用C函数实现比较困难的功能用Erlang来实现，直接引入到Erts中。</li>\n<li>延迟执行，将和Driver相关的操作或者需要通过OTP库进行决策的事情，交给Erlang来实现。</li>\n<li>主动放弃CPU，让调度进行再次调度。这个相当于让BIF支持了yield，防止C函数执行时间过长，不能保证软实时公平调度。</li>\n</ol>\n\n<h2>Erlang是怎么实现Trap机制</h2>\n\n<p>Erlang的Trap机制是通过使用Trap函数，BIF_TRAP宏和调度器协作来完成的。下面让我以erlang:send这个BIF和beam_emu中的部分代码来说下Trap的流程。</p>\n\n<p>我们先看下进入BIF的代码：</p>\n\n<pre><code><span class=\"code\">OpCase<span class=\"paren1\">(<span class=\"code\">call_bif_e</span>)</span>:\n    <span class=\"paren1\">{<span class=\"code\">\n         Eterm <span class=\"paren2\">(<span class=\"code\">*bf</span>)</span><span class=\"paren2\">(<span class=\"code\">Process*, Eterm*, BeamInstr*</span>)</span> = GET_BIF_ADDRESS<span class=\"paren2\">(<span class=\"code\">Arg<span class=\"paren3\">(<span class=\"code\">0</span>)</span></span>)</span>;\n         Eterm result;\n         BeamInstr *next;\n\n         PRE_BIF_SWAPOUT<span class=\"paren2\">(<span class=\"code\">c_p</span>)</span>;\n         c_p-&gt;fcalls = FCALLS - 1;\n         if <span class=\"paren2\">(<span class=\"code\">FCALLS &lt;= 0</span>)</span> <span class=\"paren2\">{<span class=\"code\">\n              save_calls<span class=\"paren3\">(<span class=\"code\">c_p, <span class=\"paren4\">(<span class=\"code\">Export *</span>)</span> Arg<span class=\"paren4\">(<span class=\"code\">0</span>)</span></span>)</span>;\n         </span>}</span>\n         PreFetch<span class=\"paren2\">(<span class=\"code\">1, next</span>)</span>;\n         ASSERT<span class=\"paren2\">(<span class=\"code\">!ERTS_PROC_IS_EXITING<span class=\"paren3\">(<span class=\"code\">c_p</span>)</span></span>)</span>;\n         reg<span class=\"paren2\">[<span class=\"code\">0</span>]</span> = r<span class=\"paren2\">(<span class=\"code\">0</span>)</span>;\n         result = <span class=\"paren2\">(<span class=\"code\">*bf</span>)</span><span class=\"paren2\">(<span class=\"code\">c_p, reg, I</span>)</span>;\n         ASSERT<span class=\"paren2\">(<span class=\"code\">!ERTS_PROC_IS_EXITING<span class=\"paren3\">(<span class=\"code\">c_p</span>)</span> || is_non_value<span class=\"paren3\">(<span class=\"code\">result</span>)</span></span>)</span>;\n         ERTS_VERIFY_UNUSED_TEMP_ALLOC<span class=\"paren2\">(<span class=\"code\">c_p</span>)</span>;\n         ERTS_HOLE_CHECK<span class=\"paren2\">(<span class=\"code\">c_p</span>)</span>;\n         ERTS_SMP_REQ_PROC_MAIN_LOCK<span class=\"paren2\">(<span class=\"code\">c_p</span>)</span>;\n         PROCESS_MAIN_CHK_LOCKS<span class=\"paren2\">(<span class=\"code\">c_p</span>)</span>;\n         <span class=\"comment\">//如果mbuf不空，且overhead已经超过了二进制堆的大小，那么需要进行一次垃圾回收\n</span>         if <span class=\"paren2\">(<span class=\"code\">c_p-&gt;mbuf || MSO<span class=\"paren3\">(<span class=\"code\">c_p</span>)</span>.overhead &gt;= BIN_VHEAP_SZ<span class=\"paren3\">(<span class=\"code\">c_p</span>)</span></span>)</span> <span class=\"paren2\">{<span class=\"code\">\n              Uint arity = <span class=\"paren3\">(<span class=\"code\"><span class=\"paren4\">(<span class=\"code\">Export *</span>)</span>Arg<span class=\"paren4\">(<span class=\"code\">0</span>)</span></span>)</span>-&gt;code<span class=\"paren3\">[<span class=\"code\">2</span>]</span>;\n              result = erts_gc_after_bif_call<span class=\"paren3\">(<span class=\"code\">c_p, result, reg, arity</span>)</span>;\n              E = c_p-&gt;stop;\n         </span>}</span>\n         HTOP = HEAP_TOP<span class=\"paren2\">(<span class=\"code\">c_p</span>)</span>;\n         FCALLS = c_p-&gt;fcalls;\n<span class=\"comment\">//看是否直接得道了结果\n</span>         if <span class=\"paren2\">(<span class=\"code\">is_value<span class=\"paren3\">(<span class=\"code\">result</span>)</span></span>)</span> <span class=\"paren2\">{<span class=\"code\">\n              r<span class=\"paren3\">(<span class=\"code\">0</span>)</span> = result;\n              CHECK_TERM<span class=\"paren3\">(<span class=\"code\">r<span class=\"paren4\">(<span class=\"code\">0</span>)</span></span>)</span>;\n              NextPF<span class=\"paren3\">(<span class=\"code\">1, next</span>)</span>;\n<span class=\"comment\">//没有结果，返回了THE_NON_VALUE\n</span>         </span>}</span> else if <span class=\"paren2\">(<span class=\"code\">c_p-&gt;freason == TRAP</span>)</span> <span class=\"paren2\">{<span class=\"code\">\n<span class=\"comment\">//设置进程的接续点\n</span>              SET_CP<span class=\"paren3\">(<span class=\"code\">c_p, I+2</span>)</span>;\n<span class=\"comment\">//设置改变scheduler正在执行的指令\n</span>              SET_I<span class=\"paren3\">(<span class=\"code\">c_p-&gt;i</span>)</span>;\n<span class=\"comment\">//重新进场，更新快存\n</span>              SWAPIN;\n              r<span class=\"paren3\">(<span class=\"code\">0</span>)</span> = reg<span class=\"paren3\">[<span class=\"code\">0</span>]</span>;\n              Dispatch<span class=\"paren3\">(<span class=\"code\"></span>)</span>;\n         </span>}</span></span></span></span></code></pre>\n\n<p>所有Erlang代码要调用BIF操作的时候，都会产生一个call_bif_e的Erts指令。当调度器执行到这个指令的时候，先要找到BIF函数的所在地址，然后通过C语言调用执行BIF获得result，同时根据约定如果result存在则直接放入快存x0(r(0))然后继续执行，如果没有返回值同时freason是TRAP，那么我们就触发TRAP机制。</p>\n\n<p>再让我们看下erl_send的部分代码</p>\n\n<pre><code><span class=\"code\">    switch <span class=\"paren1\">(<span class=\"code\">result</span>)</span> <span class=\"paren1\">{<span class=\"code\">\n    case 0:\n    /* <span class=\"variable\">May need to yield even though we do not bump reds here</span>... */\n         if <span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">ERTS_IS_PROC_OUT_OF_REDS</span><span class=\"paren3\">(<span class=\"code\">p</span>)</span></span>)</span>\n              goto yield_return;\n         <span class=\"variable\">BIF_RET</span><span class=\"paren2\">(<span class=\"code\">msg</span>)</span>; \n         break;\n    case SEND_TRAP:\n         <span class=\"variable\">BIF_TRAP2</span><span class=\"paren2\">(<span class=\"code\">dsend2_trap, p, to, msg</span>)</span>; \n         break;\n    case SEND_YIELD:\n         <span class=\"variable\">ERTS_BIF_YIELD2</span><span class=\"paren2\">(<span class=\"code\">bif_export<span class=\"paren3\">[<span class=\"code\"><span class=\"variable\">BIF_send_2</span></span>]</span>, p, to, msg</span>)</span>;\n         break;\n    case SEND_YIELD_RETURN:\n    yield_return:\n         <span class=\"variable\">ERTS_BIF_YIELD_RETURN</span><span class=\"paren2\">(<span class=\"code\">p, msg</span>)</span>;\n    case SEND_AWAIT_RESULT:\n         <span class=\"variable\">ASSERT</span><span class=\"paren2\">(<span class=\"code\">is_internal_ref<span class=\"paren3\">(<span class=\"code\">ref</span>)</span></span>)</span>;\n         <span class=\"variable\">BIF_TRAP3</span><span class=\"paren2\">(<span class=\"code\">await_port_send_result_trap, p, ref, msg, msg</span>)</span>;\n    case SEND_BADARG:\n         <span class=\"variable\">BIF_ERROR</span><span class=\"paren2\">(<span class=\"code\">p, <span class=\"variable\">BADARG</span></span>)</span>; \n         break;\n    case SEND_USER_ERROR:\n         <span class=\"variable\">BIF_ERROR</span><span class=\"paren2\">(<span class=\"code\">p, <span class=\"variable\">EXC_ERROR</span></span>)</span>; \n         break;\n    case SEND_INTERNAL_ERROR:\n         <span class=\"variable\">BIF_ERROR</span><span class=\"paren2\">(<span class=\"code\">p, <span class=\"variable\">EXC_INTERNAL_ERROR</span></span>)</span>;\n         break;\n    default:\n         <span class=\"variable\">ASSERT</span><span class=\"paren2\">(<span class=\"code\">! <span class=\"string\">\"Illegal send result\"</span></span>)</span>; \n         break;\n    </span>}</span></span></code></pre>\n\n<p>我们可以看到这里面使用了BIF_TRAP很多宏，那么这个宏做了什么呢？这宏非常简单</p>\n\n<pre><code><span class=\"code\"><span class=\"special\">#define BIF_TRAP2(Trap_, p, A0, A1) do {            \\\n</span>      Eterm* reg = ERTS_PROC_GET_SCHDATA<span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">(<span class=\"code\">p</span>)</span></span>)</span>-&gt;x_reg_array; \\\n      <span class=\"paren1\">(<span class=\"code\">p</span>)</span>-&gt;arity = 2;                       \\\n      reg<span class=\"paren1\">[<span class=\"code\">0</span>]</span> = <span class=\"paren1\">(<span class=\"code\">A0</span>)</span>;                        \\\n      reg<span class=\"paren1\">[<span class=\"code\">1</span>]</span> = <span class=\"paren1\">(<span class=\"code\">A1</span>)</span>;                        \\\n      <span class=\"paren1\">(<span class=\"code\">p</span>)</span>-&gt;i = <span class=\"paren1\">(<span class=\"code\">BeamInstr*</span>)</span> <span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">(<span class=\"code\">Trap_</span>)</span>-&gt;addressv<span class=\"paren2\">[<span class=\"code\">erts_active_code_ix<span class=\"paren3\">(<span class=\"code\"></span>)</span></span>]</span></span>)</span>; \\\n      <span class=\"paren1\">(<span class=\"code\">p</span>)</span>-&gt;freason = TRAP;                  \\\n      return THE_NON_VALUE;                 \\\n } <span class=\"symbol\">while</span><span class=\"paren1\">(<span class=\"code\">0</span>)</span></span></code></pre>\n\n<p>就是偷偷的改变了Erlang进程的指令i，同时，直接让函数返回THE_NON_VALUE。</p>\n\n<p>这个时候有人大概会说，这不是天下大乱了，偷偷改掉了Erlang进程执行的指令，那么这段代码执行完了，怎么能回到原来模块的代码中呢。我们可以再次回到调度器的代码中，我们可以看到，调度器的全局指令I还是正在执行的模块的代码，调度器发现了TRAP的存在，先让进程的接续指令cp（相当Erlang函数的退栈返回地址）直接为I＋2也就是原来模块中的下一条指令，然后再将全局指令I设置为Erlang进程指令i，接着执行下去。从Trap宏中，我们不难看出Trap函数是什么了，就是一个Export的数据结构。</p>\n\n<h2>总结</h2>\n\n<p>最后我们分析下为什么Erlang要这样实现TRAP。主要原因是Erlang是OPCode解释型的，Erlang进程执行的流程可控。另一个原因是，直接使用C语言的编译器来完成C函数的退栈和堆栈操作时，兼容性和稳定性要好很多不需要编写平台相关的汇编代码去操作C的堆栈。</p>\n","id":270128067802011060964489044712789931818,"intro":"介绍Erlang的Trap机制，以及为什么需要Trap机制，让读者可以更好的理解Erlang是如何将同步的操作，变成非阻塞的异步操作。","published":true,"published_at":63734916126,"title":"Erlang的Trap 机制","topic_id":1},{"content":"<h2>RPC模块的功能</h2>\n\n<p>RPC模块的功能主要是为了帮助程序员完成本地节点、两个或多个节点之间的调用。RPC模块将远程调用设定为一定的模式，这样能做到方法和进程的位置透明，简化开发工作。\n在RPC模块中主要的方法有下面几个：</p>\n\n<ul>\n<li>call 同步调用</li>\n<li>block_call 阻塞同步调用</li>\n<li>cast 广播调用</li>\n<li>abcast 异步广播调用</li>\n<li>sbcast 同步广播调用</li>\n</ul>\n\n<p>当然还有其它很多方法，就不在这里面一一介绍了</p>\n\n<h2>RPC的代码分析</h2>\n\n<h3>进程创建</h3>\n\n<p>RPC模块本身是一个gen_server会随着kernel模块启动，也就是说，在Erlang/OTP启动后我们就免费获得了一个RPC进程。\nRPC进程启动的时候，会在Erts中通过local注册一个名字rex的进程，这样没有经过修改的Erlang/OTP都会有这个名字在它的名字列表上。</p>\n\n<h3>RPC调用逻辑</h3>\n\n<p>不管是同步调用还是广播调用，在RPC模块中的调用都是依赖gen_server的相关方和erlang:send方法来完成。这样尽最大可能的重用代码，保证了整个OTP中对远程调用的表现的一致性。\n并且RPC模块不单单可以调用远程节点的方法或进程，也可以调用本地节点的方法或进程，这样保证了整个RPC的系统位置透明性，并且RPC模块针对本地节点作了相关优化。</p>\n\n<p>例如说call方法针对本地节点就采用了下面的方法：</p>\n\n<pre><code><span class=\"code\"><span class=\"function\">local_call</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">M</span>, <span class=\"variable\">F</span>, <span class=\"variable\">A</span></span>)</span> <span class=\"symbol\">when</span> <span class=\"symbol\">is_atom</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">M</span></span>)</span>, <span class=\"symbol\">is_atom</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">F</span></span>)</span>, <span class=\"symbol\">is_list</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">A</span></span>)</span> -&gt;\n    <span class=\"symbol\">case</span> <span class=\"symbol\">catch</span> <span class=\"symbol\">apply</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">M</span>, <span class=\"variable\">F</span>, <span class=\"variable\">A</span></span>)</span> <span class=\"symbol\">of</span>\n        <span class=\"paren1\">{<span class=\"code\"><span class=\"atom\">'EXIT'</span>,<span class=\"variable\">_</span></span>}</span> = <span class=\"variable\">V</span> -&gt; <span class=\"paren1\">{<span class=\"code\">badrpc, <span class=\"variable\">V</span></span>}</span>;\n        <span class=\"variable\">Other</span> -&gt; <span class=\"variable\">Other</span>\n    <span class=\"symbol\">end</span>.</span></code></pre>\n\n<h3>call和block_call方法</h3>\n\n<p>这两个方法都是同步的调用，但是实现的细节非常不同，对rex进程的影响也是不同的。当然使用两个方法在并发执行的情况下，得到的结果是完全不同的。\n不管是call也好，block_call也好，都会在执行阶段暂时的将被调用者进程的console输出重定向到调用者进程所在节点的group leader上。</p>\n\n<h4>call方法</h4>\n\n<p>在调用发起者一侧，RPC模块会立刻建立一个监控下的Erlang进程，并在该进程内通过gen_server:call方法来调用远程节点。</p>\n\n<pre><code><span class=\"code\"><span class=\"function\">do_call</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Node</span>, <span class=\"variable\">Request</span>, infinity</span>)</span> -&gt;\n    rpc_check<span class=\"paren1\">(<span class=\"code\"><span class=\"symbol\">catch</span> gen_server:call<span class=\"paren2\">(<span class=\"code\"><span class=\"paren3\">{<span class=\"code\"><span class=\"macro\">?NAME,</span><span class=\"variable\">Node</span></span>}</span>, <span class=\"variable\">Request</span>, infinity</span>)</span></span>)</span>;\n<span class=\"function\">do_call</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Node</span>, <span class=\"variable\">Request</span>, <span class=\"variable\">Timeout</span></span>)</span> -&gt;\n    <span class=\"variable\">Tag</span> = <span class=\"symbol\">make_ref</span><span class=\"paren1\">(<span class=\"code\"></span>)</span>,\n    <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Receiver</span>,<span class=\"variable\">Mref</span></span>}</span> =\n    erlang:spawn_monitor<span class=\"paren1\">(<span class=\"code\">\n      <span class=\"symbol\">fun</span><span class=\"paren2\">(<span class=\"code\"></span>)</span> -&gt;\n          <span class=\"symbol\">process_flag</span><span class=\"paren2\">(<span class=\"code\">trap_exit, true</span>)</span>,\n          <span class=\"variable\">Result</span> = gen_server:call<span class=\"paren2\">(<span class=\"code\"><span class=\"paren3\">{<span class=\"code\"><span class=\"macro\">?NAME,</span><span class=\"variable\">Node</span></span>}</span>, <span class=\"variable\">Request</span>, <span class=\"variable\">Timeout</span></span>)</span>,\n          <span class=\"symbol\">exit</span><span class=\"paren2\">(<span class=\"code\"><span class=\"paren3\">{<span class=\"code\"><span class=\"symbol\">self</span><span class=\"paren4\">(<span class=\"code\"></span>)</span>,<span class=\"variable\">Tag</span>,<span class=\"variable\">Result</span></span>}</span></span>)</span>\n      <span class=\"symbol\">end</span></span>)</span>,\n    <span class=\"symbol\">receive</span>\n    <span class=\"paren1\">{<span class=\"code\"><span class=\"atom\">'DOWN'</span>,<span class=\"variable\">Mref</span>,<span class=\"variable\">_</span>,<span class=\"variable\">_</span>,<span class=\"paren2\">{<span class=\"code\"><span class=\"variable\">Receiver</span>,<span class=\"variable\">Tag</span>,<span class=\"variable\">Result</span></span>}</span></span>}</span> -&gt;\n        rpc_check<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Result</span></span>)</span>;\n    <span class=\"paren1\">{<span class=\"code\"><span class=\"atom\">'DOWN'</span>,<span class=\"variable\">Mref</span>,<span class=\"variable\">_</span>,<span class=\"variable\">_</span>,<span class=\"variable\">Reason</span></span>}</span> -&gt;\n        rpc_check_t<span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\"><span class=\"atom\">'EXIT'</span>,<span class=\"variable\">Reason</span></span>}</span></span>)</span>\n    <span class=\"symbol\">end</span>.</span></code></pre>\n\n<p>RPC模块会将超时或对方节点失去连接的情况处理为bad_rpc，让顶层逻辑发现并非业务本身引起的远程调用问题。</p>\n\n<p>在被调用者一些，RPC模块也会立刻创建一个监控下的Erlang进程，并在该进程内处理调用者的call消息，同时会将相关信息保存在rex进程的进程上下文中。当新的进程完成了业务处理，就会把处理结果返回给被调用者节点的rex进程，然后再将结果返回给调用发起者。\n我们可以仔细观察它的代码：</p>\n\n<pre><code><span class=\"code\"><span class=\"function\">handle_call_call</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Mod</span>, <span class=\"variable\">Fun</span>, <span class=\"variable\">Args</span>, <span class=\"variable\">Gleader</span>, <span class=\"variable\">To</span>, <span class=\"variable\">S</span></span>)</span> -&gt;\n    <span class=\"variable\">RpcServer</span> = <span class=\"symbol\">self</span><span class=\"paren1\">(<span class=\"code\"></span>)</span>,\n    <span class=\"comment\">%% Spawn not to block the rpc server.\n</span>    <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Caller</span>,<span class=\"variable\">_</span></span>}</span> =\n    erlang:spawn_monitor<span class=\"paren1\">(<span class=\"code\">\n      <span class=\"symbol\">fun</span> <span class=\"paren2\">(<span class=\"code\"></span>)</span> -&gt;\n          set_group_leader<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">Gleader</span></span>)</span>,\n          <span class=\"variable\">Reply</span> = \n              <span class=\"symbol\">case</span> <span class=\"symbol\">catch</span> <span class=\"symbol\">apply</span><span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">Mod</span>, <span class=\"variable\">Fun</span>, <span class=\"variable\">Args</span></span>)</span> <span class=\"symbol\">of</span>\n              <span class=\"paren2\">{<span class=\"code\"><span class=\"atom\">'EXIT'</span>, <span class=\"variable\">_</span></span>}</span> = <span class=\"variable\">Exit</span> -&gt;\n                  <span class=\"paren2\">{<span class=\"code\">badrpc, <span class=\"variable\">Exit</span></span>}</span>;\n              <span class=\"variable\">Result</span> -&gt;\n                  <span class=\"variable\">Result</span>\n              <span class=\"symbol\">end</span>,\n          <span class=\"variable\">RpcServer</span> ! <span class=\"paren2\">{<span class=\"code\"><span class=\"symbol\">self</span><span class=\"paren3\">(<span class=\"code\"></span>)</span>, <span class=\"paren3\">{<span class=\"code\">reply, <span class=\"variable\">Reply</span></span>}</span></span>}</span>\n      <span class=\"symbol\">end</span></span>)</span>,\n    <span class=\"paren1\">{<span class=\"code\">noreply, gb_trees:insert<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">Caller</span>, <span class=\"variable\">To</span>, <span class=\"variable\">S</span></span>)</span></span>}</span>.</span></code></pre>\n\n<h4>block_call方法</h4>\n\n<p>于call方法一样，在调用发起者一侧，RPC模块会立刻建立一个监控下的Erlang进程，并在该进程内通过gen_server:call方法来调用远程节点。</p>\n\n<p>但是在被调用者一些，RPC模块会选择使用被调用者所在节点的rex直接执行相关代码</p>\n\n<pre><code><span class=\"code\"><span class=\"function\">handle_call</span><span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">block_call, <span class=\"variable\">Mod</span>, <span class=\"variable\">Fun</span>, <span class=\"variable\">Args</span>, <span class=\"variable\">Gleader</span></span>}</span>, <span class=\"variable\">_To</span>, <span class=\"variable\">S</span></span>)</span> -&gt;\n    <span class=\"variable\">MyGL</span> = <span class=\"symbol\">group_leader</span><span class=\"paren1\">(<span class=\"code\"></span>)</span>,\n    set_group_leader<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Gleader</span></span>)</span>,\n    <span class=\"variable\">Reply</span> = \n    <span class=\"symbol\">case</span> <span class=\"symbol\">catch</span> <span class=\"symbol\">apply</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Mod</span>,<span class=\"variable\">Fun</span>,<span class=\"variable\">Args</span></span>)</span> <span class=\"symbol\">of</span>\n        <span class=\"paren1\">{<span class=\"code\"><span class=\"atom\">'EXIT'</span>, <span class=\"variable\">_</span></span>}</span> = <span class=\"variable\">Exit</span> -&gt;\n        <span class=\"paren1\">{<span class=\"code\">badrpc, <span class=\"variable\">Exit</span></span>}</span>;\n        <span class=\"variable\">Other</span> -&gt;\n        <span class=\"variable\">Other</span>\n    <span class=\"symbol\">end</span>,\n    <span class=\"symbol\">group_leader</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">MyGL</span>, <span class=\"symbol\">self</span><span class=\"paren2\">(<span class=\"code\"></span>)</span></span>)</span>, <span class=\"comment\">% restore\n</span>    <span class=\"paren1\">{<span class=\"code\">reply, <span class=\"variable\">Reply</span>, <span class=\"variable\">S</span></span>}</span>;</span></code></pre>\n\n<h4>同步调用总结</h4>\n\n<p>call方法可以保证，同一调用者的远程请求按序列执行，但是不保证多个调用者的远程请求按序列执行。\nblock_call方法保证，多个调用者的远程请求按序列执行。\n不管是call还是block_call的方法都会给调用者带来大量的进程创建的压力（Erlang创建进程很快，但不代表没有代价）。\ncall方法还会给被调用者节点带来大量的进程创建压力。</p>\n\n<h3>cast方法</h3>\n\n<p>RPC模块的cast方法直接依赖于gen_sever:cast，并没有做更多的事情。</p>\n\n<p>针对本地节点，cast方法会在调用者节点内创建一个进程来执行相关代码：</p>\n\n<pre><code><span class=\"code\"><span class=\"function\">cast</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Node</span>, <span class=\"variable\">Mod</span>, <span class=\"variable\">Fun</span>, <span class=\"variable\">Args</span></span>)</span> <span class=\"symbol\">when</span> <span class=\"variable\">Node</span> =:= <span class=\"symbol\">node</span><span class=\"paren1\">(<span class=\"code\"></span>)</span> -&gt;\n    <span class=\"symbol\">catch</span> <span class=\"symbol\">spawn</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Mod</span>, <span class=\"variable\">Fun</span>, <span class=\"variable\">Args</span></span>)</span>,\n    true;\n<span class=\"function\">cast</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Node</span>, <span class=\"variable\">Mod</span>, <span class=\"variable\">Fun</span>, <span class=\"variable\">Args</span></span>)</span> -&gt;\n    gen_server:cast<span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\"><span class=\"macro\">?NAME,</span><span class=\"variable\">Node</span></span>}</span>, <span class=\"paren2\">{<span class=\"code\">cast,<span class=\"variable\">Mod</span>,<span class=\"variable\">Fun</span>,<span class=\"variable\">Args</span>,<span class=\"symbol\">group_leader</span><span class=\"paren3\">(<span class=\"code\"></span>)</span></span>}</span></span>)</span>,\n    true.</span></code></pre>\n\n<p>被调用者接收到消息后会立刻创建进程执行相关代码：</p>\n\n<pre><code><span class=\"code\"><span class=\"function\">handle_cast</span><span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">cast, <span class=\"variable\">Mod</span>, <span class=\"variable\">Fun</span>, <span class=\"variable\">Args</span>, <span class=\"variable\">Gleader</span></span>}</span>, <span class=\"variable\">S</span></span>)</span> -&gt;\n    <span class=\"symbol\">spawn</span><span class=\"paren1\">(<span class=\"code\"><span class=\"symbol\">fun</span><span class=\"paren2\">(<span class=\"code\"></span>)</span> -&gt;\n          set_group_leader<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">Gleader</span></span>)</span>,\n          <span class=\"symbol\">apply</span><span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">Mod</span>, <span class=\"variable\">Fun</span>, <span class=\"variable\">Args</span></span>)</span>\n      <span class=\"symbol\">end</span></span>)</span>,\n    <span class=\"paren1\">{<span class=\"code\">noreply, <span class=\"variable\">S</span></span>}</span>;</span></code></pre>\n\n<h4>cast方法总结</h4>\n\n<p>cast方法是非常简单的。和call方法一样，会给被调用者节点带来大量的进程创建压力。\n同样不要忘记了，cast方法也会将新创建的进程的console输出重新定向调用者所在节点的group leader上。</p>\n\n<h3>abcast和sbcast</h3>\n\n<p>这两个方法都是通过erlang:send将调用者的消息发送到被调用者节点上。</p>\n\n<h4>abcast</h4>\n\n<p>abcast采用的是纯异步，发出去就不管了，直接将消息不经过rex进程直接发送到目标进程上</p>\n\n<pre><code><span class=\"code\">\nabcast<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"variable\">Mess</span></span>)</span> -&gt;\n    abcast<span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">[<span class=\"code\"><span class=\"symbol\">node</span><span class=\"paren3\">(<span class=\"code\"></span>)</span> | nodes<span class=\"paren3\">(<span class=\"code\"></span>)</span></span>]</span>, <span class=\"variable\">Name</span>, <span class=\"variable\">Mess</span></span>)</span>.\n\nabcast<span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">Node|Tail</span></span>]</span>, <span class=\"variable\">Name</span>, <span class=\"variable\">Mess</span></span>)</span> -&gt;\n    <span class=\"variable\">Dest</span> = <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Name</span>,<span class=\"variable\">Node</span></span>}</span>,\n    <span class=\"comment\">%这么做的好处是不会让进程被trap\n</span>    <span class=\"comment\">%从而保证了异步性\n</span>    <span class=\"symbol\">case</span> <span class=\"symbol\">catch</span> erlang:send<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Dest</span>, <span class=\"variable\">Mess</span>, <span class=\"paren2\">[<span class=\"code\">noconnect</span>]</span></span>)</span> <span class=\"symbol\">of</span>\n    noconnect -&gt; <span class=\"symbol\">spawn</span><span class=\"paren1\">(<span class=\"code\">erlang, send, <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">Dest</span>,<span class=\"variable\">Mess</span></span>]</span></span>)</span>, ok;\n    <span class=\"variable\">_</span> -&gt; ok\n    <span class=\"symbol\">end</span>,\n    abcast<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Tail</span>, <span class=\"variable\">Name</span>, <span class=\"variable\">Mess</span></span>)</span>;\n<span class=\"function\">abcast</span><span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">[<span class=\"code\"></span>]</span>, <span class=\"variable\">_</span>,<span class=\"variable\">_</span></span>)</span> -&gt; abcast.</span></code></pre>\n\n<p>此处abcast完全是异步的，如果发现了目标节点是没有连接的时候，直接创建一个新的进程来进行消息发送，完全不会进入Trap状态等待节点连接。</p>\n\n<h4>sbcast</h4>\n\n<p>sbcast算是同步的广播方式，发送后会回收广播结果，并且当节点没有完成连接的时候，会进入Trap状态等待节点连接完成</p>\n\n<pre><code><span class=\"code\"><span class=\"function\">sbcast</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"variable\">Mess</span></span>)</span> -&gt;\n    sbcast<span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">[<span class=\"code\"><span class=\"symbol\">node</span><span class=\"paren3\">(<span class=\"code\"></span>)</span> | nodes<span class=\"paren3\">(<span class=\"code\"></span>)</span></span>]</span>, <span class=\"variable\">Name</span>, <span class=\"variable\">Mess</span></span>)</span>.\n\nsbcast<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Nodes</span>, <span class=\"variable\">Name</span>, <span class=\"variable\">Mess</span></span>)</span> -&gt;\n    <span class=\"variable\">Monitors</span> = send_nodes<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Nodes</span>, <span class=\"macro\">?NAME,</span> <span class=\"paren2\">{<span class=\"code\">sbcast, <span class=\"variable\">Name</span>, <span class=\"variable\">Mess</span></span>}</span>, <span class=\"paren2\">[<span class=\"code\"></span>]</span></span>)</span>,\n    rec_nodes<span class=\"paren1\">(<span class=\"code\"><span class=\"macro\">?NAME,</span> <span class=\"variable\">Monitors</span></span>)</span>.\n\nsend_nodes<span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">Node|Tail</span></span>]</span>, <span class=\"variable\">Name</span>, <span class=\"variable\">Msg</span>, <span class=\"variable\">Monitors</span></span>)</span> <span class=\"symbol\">when</span> <span class=\"symbol\">is_atom</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Node</span></span>)</span> -&gt;\n    <span class=\"variable\">Monitor</span> = start_monitor<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Node</span>, <span class=\"variable\">Name</span></span>)</span>,\n    <span class=\"comment\">%% Handle non-existing names in rec_nodes.\n</span>    <span class=\"symbol\">catch</span> <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"variable\">Node</span></span>}</span> ! <span class=\"paren1\">{<span class=\"code\"><span class=\"symbol\">self</span><span class=\"paren2\">(<span class=\"code\"></span>)</span>, <span class=\"variable\">Msg</span></span>}</span>,\n    send_nodes<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Tail</span>, <span class=\"variable\">Name</span>, <span class=\"variable\">Msg</span>, <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">Monitor</span> | <span class=\"variable\">Monitors</span></span>]</span></span>)</span>;\n<span class=\"function\">send_nodes</span><span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">_Node|Tail</span></span>]</span>, <span class=\"variable\">Name</span>, <span class=\"variable\">Msg</span>, <span class=\"variable\">Monitors</span></span>)</span> -&gt;\n    <span class=\"comment\">%% Skip non-atom _Node\n</span>    send_nodes<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Tail</span>, <span class=\"variable\">Name</span>, <span class=\"variable\">Msg</span>, <span class=\"variable\">Monitors</span></span>)</span>;\n<span class=\"function\">send_nodes</span><span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">[<span class=\"code\"></span>]</span>, <span class=\"variable\">_Name</span>,  <span class=\"variable\">_Req</span>, <span class=\"variable\">Monitors</span></span>)</span> -&gt; \n    <span class=\"variable\">Monitors</span>.\n\nrec_nodes<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"variable\">Nodes</span></span>)</span> -&gt; \n    rec_nodes<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"variable\">Nodes</span>, <span class=\"paren2\">[<span class=\"code\"></span>]</span>, <span class=\"paren2\">[<span class=\"code\"></span>]</span></span>)</span>.\n\nrec_nodes<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">_Name</span>, <span class=\"paren2\">[<span class=\"code\"></span>]</span>,  <span class=\"variable\">Badnodes</span>, <span class=\"variable\">Replies</span></span>)</span> -&gt;\n    <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Replies</span>, <span class=\"variable\">Badnodes</span></span>}</span>;\n<span class=\"function\">rec_nodes</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"paren2\">[<span class=\"code\"><span class=\"paren3\">{<span class=\"code\"><span class=\"variable\">N</span>,<span class=\"variable\">R</span></span>}</span> | <span class=\"variable\">Tail</span></span>]</span>, <span class=\"variable\">Badnodes</span>, <span class=\"variable\">Replies</span></span>)</span> -&gt;\n    <span class=\"symbol\">receive</span>\n    <span class=\"paren1\">{<span class=\"code\"><span class=\"atom\">'DOWN'</span>, <span class=\"variable\">R</span>, <span class=\"variable\">_</span>, <span class=\"variable\">_</span>, <span class=\"variable\">_</span></span>}</span> -&gt;\n        rec_nodes<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"variable\">Tail</span>, <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">N|Badnodes</span></span>]</span>, <span class=\"variable\">Replies</span></span>)</span>;\n    <span class=\"paren1\">{<span class=\"code\"><span class=\"macro\">?NAME,</span> <span class=\"variable\">N</span>, <span class=\"paren2\">{<span class=\"code\">nonexisting_name, <span class=\"variable\">_</span></span>}</span></span>}</span> -&gt;  \n        <span class=\"comment\">%% used by sbcast()\n</span>        erlang:demonitor<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">R</span>, <span class=\"paren2\">[<span class=\"code\">flush</span>]</span></span>)</span>,\n        rec_nodes<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"variable\">Tail</span>, <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">N|Badnodes</span></span>]</span>, <span class=\"variable\">Replies</span></span>)</span>;\n    <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"variable\">N</span>, <span class=\"variable\">Reply</span></span>}</span> -&gt;  <span class=\"comment\">%% Name is bound !!!\n</span>        erlang:demonitor<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">R</span>, <span class=\"paren2\">[<span class=\"code\">flush</span>]</span></span>)</span>,\n        rec_nodes<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"variable\">Tail</span>, <span class=\"variable\">Badnodes</span>, <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">Reply|Replies</span></span>]</span></span>)</span>\n    <span class=\"symbol\">end</span>.</span></code></pre>\n\n<h2>总结</h2>\n\n<p>RPC模块是Erlang/OTP当中非常重要的一个模块，它的存在简化了很多编码工作但是也为我们带来了很多隐患</p>\n\n<ul>\n<li>单个gen_server的消息承载能力和block_call的阻塞</li>\n<li>错误使用时，RPC模块大量的进程创建，影响了Erts的调度</li>\n<li>使用RPC模块来传递大块的数据，引起dist_busy_port</li>\n<li>group leader重定向引起的数据量叠加，引起dist_busy_port</li>\n</ul>\n\n<p>当然这些问题不影响我们正常使用RPC模块，例如我们可以将RPC用于以下场景：</p>\n\n<ul>\n<li>Erlang集群构建boot阶段</li>\n<li>Erlang集群的元信息和控制信息交换</li>\n</ul>\n","id":129951779454948563520957562049789225725,"intro":"Erlang作为一个并发和集群性的语言和平台，其中RPC就必不可少。本文对Erlang自身携带的RPC模块进行分析","published":true,"published_at":63734916123,"title":"Erlang的RPC 模块代码分析","topic_id":1},{"content":"<h2>为什么是Haskell</h2>\n\n<p>因为想尝试下新东西，在决定使用ttalk.im这个域名，当然现在的你所看到的，已经不是Sblog。前我还做个很多很多的尝试，例如<a href=\"https://github.com/DavidAlphaFox/mate.im\" >mate.im</a>是使用Elixir开发的。当然还有一个叫ailink.io的网站，是使用Clojure开发的。</p>\n\n<p>令一方面，在使用了很久的Erlang之后，感觉函数类语言比较适合自己，当然我也拿Haskell写过一些非Web的产品，为了让自己更加专注，所以就选择了全部使用函数类语言开发后端（Erlang和Haskell）。</p>\n\n<h2>Web开发选型</h2>\n\n<p>因为自己对Haskell的功底并没有达到很高的境界，就没有选择Haskell开发Web的神奇Yesod，而是选择比较轻量级的Scotty，当然当时也有想尝试Spock（Live long and prosper 或者 Peace and long life）的想法。不过因为自己已经看了好一段时间Scotty的代码，所以就决定使用了Scotty。</p>\n\n<p>选择Postgresql-simple完全是因为自己还不想接触复杂的Haskell Teamplate，并且为了让整个项目看起来不太恐怖（比较害怕哪天自己都不知道自己在写什么）。</p>\n\n<p>选择Blaze-html的原因是因为个人一贯喜欢吧View直接写成代码，而不是渲染模板文件的原因，但是从生产角度上来讲，渲染模板文件的做法才更加实际。</p>\n\n<p>前端CSS框架并没有使用大家所熟知的Bootstrap，而是选择使用了semantic-ui，也是为了尝试些新的东西。不过在JS的选择上，并没有选择比较花哨的ReactJS或Vue这类的，更多是简单的JQuery，因为这个项目的重点是后端Haskell开发Web的实践。</p>\n\n<h3>Scotty使用心得</h3>\n\n<p>Scotty作为一个Web框架，代码量非常少，非常轻量级。因此很多东西需要自己重新造轮子，但是也为每个人带来了很多灵活的地方，整个项目相当是我自己在Scotty基础上封装了一些便于操作数据库的东西。</p>\n\n<p>Scotty的优势：</p>\n\n<ol>\n<li>轻量级，代码简单，有问题可以直接翻代码</li>\n<li>上手曲线平滑，没有大的波动</li>\n<li>路由解析和异常处理非常完善</li>\n<li>性能非常好</li>\n</ol>\n\n<p>Scotty的缺陷：</p>\n\n<ol>\n<li>没有URI相关操作工具</li>\n<li>不提供很多常见的组件，例如说Cache，Cookie，CSRF等</li>\n</ol>\n\n<h2>整个项目总结</h2>\n\n<p>Haskell开发的Web项目，尤其是对大量的列表读取处理还是非常简单，因为有大量的工具函数，例如说map，filiter，fold等。\r\n整个项目冗余代码偏多，并没有使用太多的Haskell的高级技巧，甚至没有使用Class来完成不同的数据类型进行同名操作。因此整个项目并不是优良的Haskell项目，但是依然不影响它作为一个Scotty入门教程的项目。</p>\n\n<h3>代码地址</h3>\n\n<p>整个项目被开源放到了<a href=\"https://github.com/DavidAlphaFox/sblog\" >Github</a>上，有兴趣的同学可以帮忙添加一些特性。</p>\n","id":52469860465127742064241171926887570922,"intro":"ML类","published":false,"published_at":63734916124,"title":"Sblog 开发笔记","topic_id":1},{"content":"<h2>什么是Erlang</h2>\n\n<p>Erlang（[&apos;ə:læŋ]）是一种通用的面向并发的编程语言，其创立者是Joe Armstrong，在1987年由瑞典电信设备制造商爱立信于主持开发。Erlang的开发目的是创造一种可以应对大规模并发活动的编程语言和运行环境，从而简化交换机的开发工作，提高电话交换机的稳定性和可扩展性。</p>\n\n<p>Erlang是一个结构化，动态类型编程语言，内建并行计算支持，非常适合于构建分布式，实时软并行计算系统。使用Erlang编写出的应用运行时通常由成千上万个轻量级进程组成，并通过消息传递相互通讯。Erlang使用用户态抢占式协作线程来完成Erlang进程的调度，这比起C程序的线程切换要高效得多得多了。</p>\n\n<h2>Erlang的特点</h2>\n\n<ul>\n<li>并发性：Erlang支持超大量级的并发进程，并且不需要操作系统具有并发机制。</li>\n<li>分布式： 一个分布式Erlang系统是多个Erlang节点组成的网络。</li>\n<li>健壮性：Erlang具有多种基本的错误检测能力，它们能够用于构建容错系统。</li>\n<li>软实时性： Erlang支持可编程的“软”实时系统，使用了用户态抢占式协作线程，同时使用了递增式垃圾收集技术。</li>\n<li>热代码升级：Erlang允许程序代码在运行系统中被修改。旧代码能被逐步淘汰而后被新代码替换。在此过渡期间，新旧代码是共存的。</li>\n<li>递增式代码装载：用户能够控制代码如何被装载的细节。</li>\n<li>函数式编程：尾递归优化，变量不可变，可预知的函数输出，匿名函数，闭包等。</li>\n<li>动态类型：无需声明变量类型，Erlang会根据情况自动确定变量类型。</li>\n</ul>\n\n<h2>什么是OTP</h2>\n\n<p>OTP是Open Telecom Platform的缩写，字面上直接的意思就是开放电信平台，这刚接触Erlang/OTP的人感到这玩意好像和一般服务器开发没什么关系。\n但是OTP是基于Erlang语言的一个非常强大，且非常通用的平台。</p>\n\n<p>OTP当中提供了大量的工具模块来帮助我们完成日常开发工作，同时该平台抽象了大量的行为模式，例如常见的状态机，通用服务器，进程监控以及内置的Mnesia数据库等。\n这些库不单单加快了我们的开发工作，同时也提高了整个系统的稳定性和可扩展性。</p>\n","id":17010233579631072023177630943530279267,"intro":"介绍Erlang语言和Erlang语言的一些特点，以及Erlang自己的OTP平台。","published":true,"published_at":63737716850,"title":"Erlang语言简介","topic_id":1},{"content":"<h2>什么是NIF</h2>\n\n<p>NIF是Native Implemented Function的缩写，从词面意思就可以看出，NIF是Erlang使用平台相关语言（一般是C语言）在Erts层面实现操作系统或外部库沟通的方案。</p>\n\n<h2>NIF和Ports的异同</h2>\n\n<h3>相同点</h3>\n\n<p>NIF和Ports 都是为Erts可以同操作系统和外部库进行通讯，给使用者在不改变Erts代码的前提下扩展Erts的功能。</p>\n\n<h3>不同点</h3>\n\n<p>Ports可以被分为普通Port和Port Driver。</p>\n\n<p>普通Port是连接外部程序进程和Erts的桥梁，外部进程通过标准输入输出与Erts虚拟机交互，并运行于独立的地址空间。它有以下特点：</p>\n\n<ol>\n<li>从操作系统的角度看，外部程序和Erlang虚拟机都是独立运行的进程，Erts通过外部程序的标准输入输出与外部程序教务， 因此外部程序的崩溃不会影响到Erts本身的正常运行。</li>\n<li>当外部程序崩溃了，Erlang虚拟机可以检测到，可以选择重启等对应策略。由于两者在不同的地址空间，通过标准IO交互，</li>\n<li>每个Port都有一个owner进程，通常为创建Port的进程，当owner进程终止时，Port也将被自动关闭。</li>\n</ol>\n\n<p>可以看出普通Port的优势在于隔离性和安全性，因为外部程序的任何异常都不会导致Erts崩溃，并且Erlang层通过receive来实现同步调用等待外部程序响应时，是不会影响Erts的调度器调度Erlang进程。<br/>\n读者也可以看出Port的缺点，就是效率低，因为是操作系统中两个程序通过标准输入输出传递字节流数据，所以需要额外的序列化和反序列化。\n同时外部程序是Erts通过系统fork调用或者exec调用创建出来的，因此创建Port的资源代价是很大的。</p>\n\n<p>Port Driver 从Erlang的角度来看，端口驱动和普通Port所体现的行为模式一样，收发消息，注册名字，并且使用和普通Port相同的语义，因此Port Driver也具有一个Owner进程。\n但是端口驱动本身是作为一个链接库运行于Erts中的，也就是和Erts共享一个操作系统进程，因此Port Driver的性能比普通的Port提高了不少。\n但是缺点也非常明显，链入的动态链接库本身可能出现内存泄露或异常，将影响Erts正常运行甚至导致虚拟机崩溃。</p>\n\n<p>NIF是Erlang调用C代码最简单高效的方案，对Erlang层来说，调用NIF就像调用普通函数一样，只不过这个函数是由C实现的。\nNIF是同步语义的，运行于调度线程中，无需上下文切换，因此效率很高。但是对于执行时间长的NIF，在NIF返回之前，调度线程不能做别的事情，影响了虚拟机的公平调度，甚至会影响调度线程之间的协作。</p>\n\n<p>从Erlnag层面上Port Driver和NIF非常相似，但是NIF并没有所谓的Owner进程，因为它只是一组函数。\nPort Driver是可以监控Owner进程的存活状态，当Owner进程终止时，Port Driver也会终止，并释放所拥有的资源。\n那么就引出本文题目的问题了。</p>\n\n<h2>为什么会产生NIF资源</h2>\n\n<p>从前面的描述，读者已经可以清楚的看到NIF的优势，NIF更加体现函数化编程的思想，NIF自身并不和任何Erlang进程绑定，是完全可以重入的，可以被任何一个Erlang进程在任何时间调用，并且在Erts的调度线程上执行。\n但是很多时候，NIF仍需要产生上下文供函数使用，这种上下文就是所说的资源，而这种资源很可能是需要在调用者退出时进行释放的。\n举例子来说，在开发<a href=\"https://github.com/DavidAlphaFox/ailua?utm_source=ttalk.im&utm_medium=website&utm_campaign=Tech%2520Talk\">AiLua</a>的时候，其中NIF需要将Lua虚拟机作为资源和调用者的Erlang进程绑定。当Erlang进程不管是正常退出还是异常退出，都需要释放这个资源，从而防止内存泄漏。</p>\n\n<h2>解决方法</h2>\n\n<p>这个时候，我想起了一个伟大的工程eleveldb。leveldb也是需要打开句柄，并且相应的进程也使用这个句柄。所以就去翻看了eleveldb的代码。发现几个非常重要的函数</p>\n\n<pre><code><span class=\"code\">\nErlNifResourceType *enif_open_resource_type<span class=\"paren1\">(<span class=\"code\">ErlNifEnv* env, <span class=\"symbol\">const</span> <span class=\"symbol\">char</span>* module_str, <span class=\"symbol\">const</span> <span class=\"symbol\">char</span>* name,\n ErlNifResourceDtor* dtor, ErlNifResourceFlags flags, ErlNifResourceFlags* tried</span>)</span>;\n\n<span class=\"symbol\">void</span> *enif_alloc_resource<span class=\"paren1\">(<span class=\"code\">ErlNifResourceType* type, <span class=\"symbol\">unsigned</span> size</span>)</span>;\n\nERL_NIF_TERM enif_make_resource<span class=\"paren1\">(<span class=\"code\">ErlNifEnv* env, <span class=\"symbol\">void</span>* obj</span>)</span>;\n\n<span class=\"symbol\">void</span> enif_release_resource<span class=\"paren1\">(<span class=\"code\"><span class=\"symbol\">void</span>* obj</span>)</span>;\n</span></code></pre>\n\n<p>这几个函数是怎么解决资源释放问题的呢？</p>\n\n<p>我们可以看到eleveldb在on_load的时候，使用enif_open_resource_type创建了一个资源类型。之后在每次请求打开DB的时候，通过i下面方式进行NIF资源和Erlang进程绑定</p>\n\n<ol>\n<li>用enif_alloc_resource分配出一个资源.</li>\n<li>用enif_make_resource和enif_release_resource将资源的控制权交给了调用的进程</li>\n</ol>\n\n<h2>实现方式</h2>\n\n<p>Erts对NIF资源的管理，使用了最简单的资源计数的方式来进行管理。</p>\n\n<p>将一个NIF的资源和Erlang进程绑定需要以下几个步骤</p>\n\n<ol>\n<li>使用enif_alloc_resource在分配资源的时候，分配的资源引用计数为1，并且该资源不属于任何一个Erlang的进程。</li>\n<li>使用enif_make_resource的时候，相当于在调用者的堆栈上分配了一个指向资源的指针，并将资源的引用计数加1。</li>\n<li>使用enif_release_resource将资源的引用计数减少1，这样就相当将资源的控制权交给了调用的Erlang进程。</li>\n</ol>\n\n<p>那么资源是怎么安全释放的呢？</p>\n\n<p>这个时候我们可以看到资源的引用计数为1，并且这个引用者是Erlang进程堆。我们都知道Erlang进程崩溃后，Erts会清理Erlang进程堆和栈，释放资源。\n那么当Erlang进程崩溃后，就会调用enif_open_resource_type被调用的时候所传入的析构函数，而这个析构函数的参数就是前面所分配的资源。</p>\n","id":164803488297946712896231372563936839178,"intro":"NIF是Erlang除了Ports 之外的一种可以让Erlang运行时环境和操作系统或外部库进行沟通的解决方案。笔者在开发Erlang的LUA插件时，遇到了很多和NIF相关问题，其中一个比较主要的问题就是NIF中如何在Erlang进程崩溃时自动释放和它绑定的资源。","published":true,"published_at":63737857847,"title":"Erlang 是如何释放NIF的资源","topic_id":1},{"content":"<h2>什么是交换机</h2>\n\n<h3>什么是交换</h3>\n\n<p>交换（switching）是按照通信两端传输信息的需要，用人工或设备自动完成的方法，把要传输的信息送到符合要求的相应路由上的技术的统称。交换机有多个端口，每个端口都具有桥接功能，可以连接一个局域网或一台高性能服务器或工作站。实际上，交换机有时被称为多端口网桥。</p>\n\n<h3>交换机核心功能</h3>\n\n<p>交换机工作于OSI参考模型的第二层，即数据链路层。\n1. 交换机内部会在每个端口成功连接时，通过将MAC地址和端口对应，形成一张MAC表。\n1. 在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。\n1. 交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层广播，即广播域。</p>\n\n<h3>交换机如何实现的</h3>\n\n<p>交换机拥有一条很高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背部总线上，控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口。当目的MAC若不存在，广播到所有的端口，接收端口回应后交换机会“学习”新的MAC地址，并把它添加入内部MAC地址表中。\n使用交换机也可以把网络“分段”，通过对照IP地址表，交换机只允许必要的网络流量通过交换机。通过交换机的过滤和转发，可以有效的减少冲突域，但它不能划分网络层广播，即广播域。</p>\n\n<h2>交换机和路由器的区别</h2>\n\n<h3>交换机</h3>\n\n<p>我们经常说到的以太网交换机实际是一个基于网桥技术的多端口第二层网络设备，它为数据帧从一个端口到另一个任意端口的转发提供了低时延、低开销的通路。 交换机内部核心处有一个交换矩阵，为任意两端口间的通信提供通路，或是一个快速交换总线，以使由任意端口接收的数据帧从其他端口送出。</p>\n\n<h3>路由器</h3>\n\n<p>而路由器是OSI参考模型的网络层中的分组交换设备（或网络层中继设备），路由器的基本功能是把数据（IP报文）传送到正确的网络，二层转发能力有限。</p>\n\n<p>路由器支持广域网连接，丰富的广域网接口，包括serial、atm等等，支持多种不同有线传输介质，包括串行线缆、光纤、电话线、专线等等，并且接口上支持广域网连接的封装类型，支持HDLC、FR、ATM、PPP、ISDL封装。</p>\n\n<p>在主干网上，路由器的主要作用是路由选择。主干网上的路由器，必须知道到达所有下层网络的路径。这需要维护庞大的路由表，并对连接状态的变化作出尽可能迅速的反应。路由器的故障将会导致严重的信息传输问题。</p>\n\n<h3>三层交换机</h3>\n\n<p>三层交换机就是具有部分路由器功能的交换机，三层交换机的最重要目的是加快大型局域网内部的数据交换，所具有的路由功能也是为这目的服务的，能够做到一次路由，多次转发。\n对于数据包转发等规律性的过程由硬件高速实现，而像路由信息更新、路由表维护、路由计算、路由确定等功能，由软件实现。\n三层交换机就是二层交换技术+三层转发技术。传统交换机是在OSI网络标准模型第二层数据链路层进行操作的，而三层交换技术是在网络模型中的第三层实现了数据包的高速转发，既可实现网络路由功能，又可根据不同网络状况做到最优网络性能。\n但是三层交换机依然无法取代路由器，三层交换机，它只是提供简单的路由功能及一些三层过滤功能。</p>\n\n<h2>PPS，背板带宽和无阻塞交换机</h2>\n\n<h3>什么是PPS</h3>\n\n<p>pps的意思是Packet Per Second，每秒钟传输的数据包的数，也就是我们说的 包转发率。</p>\n\n<h3>如何计算PPS</h3>\n\n<p>假定我们是1个10Mbps的网络端口，那么我们就有以下的算式了，</p>\n\n<pre><code>10M/[(64+12+8)*8]=14.881Kpps \n</code></pre>\n\n<p>其中64代表以太网最小包，12代表以太网祯间隙，第一个8代表以太网帧头大小，第二个8代表1 byte = 8 bit。</p>\n\n<h3>PPS有什么用</h3>\n\n<p>PPS代表在这条线路上，最大的转发速度是多少，这里可以看出10Mpbs的网卡接口最大转发速度每秒钟不能超过15K，同时这是我们计算交换机背板带宽和交换机包转发率的一个重要参数。</p>\n\n<h3>交换机的PPS</h3>\n\n<p>交换机的PPS代表交换机转发数据包能力的大小。我们可以通过，所有类型端口PPS＊该类型端口数量之和的2倍这个方式计算出。\n例如 : 1个千兆＋4个百兆的端口的交换机，达到全双工无阻塞需要的包转发率如下：</p>\n\n<pre><code>（1.488Mpps ＋ 4 * 0.1488Mpps) * 2 = 4.1664Mpps\n</code></pre>\n\n<h3>什么是背板带宽</h3>\n\n<p>背板带宽是交换机接口处理器或接口卡和数据总线间所能吞吐的最大数据量。背板带宽标志了交换机总的数据交换能力。</p>\n\n<h3>如何计算背板带宽</h3>\n\n<p>方法很简单，可以通过所有类型端口传输＊该类型端口数量之和的2倍这个方式计算出交换机的背板带宽。\n例如一个1个千兆＋4个百兆的端口的交换机，达到全双工无阻塞的需要的背板带宽如下：</p>\n\n<pre><code>（1Gbps＋ 4 * 0.1Gbps) * 2 = 2.8Gbps\n</code></pre>\n\n<h3>无阻塞全双工交换机</h3>\n\n<p>我们依然使用 1个千兆＋4个百兆的端口的交换机为例子，当我们看到交换机数据指标中背板带宽&gt;= 2.8Gbps，PPS(包转发率) &gt;= 4.1664Mpps，就可以认为该交换机是无阻塞全双工的交换机。</p>\n\n<h2>交换方式</h2>\n\n<h3>什么是交换方式</h3>\n\n<p>交换方式代表一个以太网包通过端口A转发到端口B时，交换机内部是如何处理的。常见的交换方式有，直通式，存储转发式，碎片隔离式。</p>\n\n<h3>常见交换方式</h3>\n\n<h4>直通式</h4>\n\n<p>顾名思义，就是从端口A直接转发到端口B，除了读取下以太网帧的头直接找出目的端口B是谁，直接将包发给端口B。</p>\n\n<h4>存储转发式</h4>\n\n<p>交换机先将输入端口到来的数据包缓存起来，先检查数据包是否正确，并过滤掉冲突包错误，确定包正确后，取出目的地址，通过查找表找到想要发送的输出端口地址，然后将该包发送出去。</p>\n\n<h4>碎片隔离式</h4>\n\n<p>该模式则是介于直通式和存储转发式之间的一种解决方案，在这个模式下如果发现一个以太网帧小于64字节，则会被丢弃，从而确保碰撞碎片不通过网络传播，能够在很大程度上提高网络传输效率。</p>\n\n<h4>交换方式的差异</h4>\n\n<p>直通式，传输时延非常小，但是当出现千兆端口向百兆端口转发的时候，由于速率不匹配容易出现丢包现象，同时由于只读取了目标地址而不进行包完整性和正确性检测，很容易出现碰撞碎片在网络上传播。\n存储转发的方式解决了直通方式的问题，但是带来的问题是增加了时延。\n碎片隔离式，避免了长时延和碰撞碎片在网络上传播，但是缺少存储的过程，依然无法解决高速端口向低速端口转发丢包的情况。</p>\n\n<h2>如何选择一款好的交换机</h2>\n\n<p>根据RFC 894的说明，以太网封装IP数据包的最大长度是1500字节，也就是说我们可以得出，一个完整的以太网传输为12字节帧间隙 ＋ 8字节帧头 ＋ 6字节的目的MAC + 6字节的源MAC + 2字节的帧类型 + 1500 + 4字节的FCS。因此根据RFC 894和1秒钟业务数据包所承载的数据量，可以计算出我们要求交换机的PPS至少为下面的大小：</p>\n\n<pre><code> 端口速率/(20+平均ip包大小＋12+8) = Xpps\n</code></pre>\n\n<p>如果我们的应用在1秒钟发数据包的量要求的PPS &gt; X的时候，就会产生丢包重传的可能性，就会出现我们的系统完全满跑的时候，瓶颈出现在了交换机上，网络时延变大。\n因此，不言而喻，我们不单单要选择百兆还是千兆，还要看懂交换机的各项参数。</p>\n\n<h2>总结</h2>\n\n<p>不要认为所有的交换机都是一样的，在轻负载的时候也许没问题，当你系统满载的时候，就会出现瓶颈吞吐反而一落千丈和自己的估算值相差甚远的情况。因此，在选择交换机的时候，不单单要看是百兆的还是千兆的，更要看背板带宽和包转发率。</p>\n","id":8434478513412937263325198667373759095,"intro":"通过对交换机的和交换原理进行相应的介绍，从而帮助读者们读懂交换机上的参数，从而做到正确选择适合业务的交换机。","published":true,"published_at":63738250205,"title":"读懂交换机的参数","topic_id":1},{"content":"<h2>为什么做接口设计</h2>\n\n<p>我们在工作的时候一般都是面一个大型项目，随着微服务的兴起，不单单要设计模块之间的接口，还要考虑各个微服务之间的接口。这篇文章就是针对如何去做微服务之间的接口设计的思考。</p>\n\n<h2>如何做接口的设计</h2>\n\n<p>从我个人角度来说，可以从以下几个特性进行分析：</p>\n\n<ol>\n<li>大规模系统和小规模系统</li>\n<li>面向内部系统接口和面向外部系统的接口</li>\n<li>大数据传输的接口和小数据传输的接口</li>\n<li>长链接的接口和短链接的接口</li>\n</ol>\n\n<p>很多时候我们优先考虑的是系统有多大，扩张性要有多好，对内还是对外以及我们有多大的能力。很多时候这个东西并没有一个定论，更多是基于业务和团队人员组成而决定的。</p>\n\n<h2>接口的实施</h2>\n\n<p>一定要做的事情</p>\n\n<p>不管接口是对内的还是对外的，我们都要做以下几件事情：</p>\n\n<ol>\n<li>接口功能定义是否明确，是否有功能重复的地方</li>\n<li>接口的升级机制，是否能兼容以前的数据</li>\n<li>接口的数据量是多少，是否需要使用传输压缩机制</li>\n<li>接口的熔断点在何处，何时该降级或停止服务</li>\n<li>接口的安全机制是怎么样的，如何将非法调用隔离开来</li>\n</ol>\n\n<p>这些事情是我们在开始设计和实现接口的时候，必须要先想到的。但是不要认为我们想到了这些东西，我们就可以高枕无忧，然后事情就会像我们期待的那样发展下去。很多时候，接口都会变成像阿米巴原虫一样，不是圆的而是不规则的多边形。</p>\n\n<h3>对内的接口</h3>\n\n<p>对内的接口简单说就是SOA，但是SOA也有很多种做法，例如常见的dubbo框架。在dubbo框架下，我们所做的事情完全可以说是在dubbo框架下进行业务开发，并定义interface然后暴露出去，我们此时貌似没有进行接口设计，但是实际上我们是完全按照dubbo的规范完成了接口的定义，没错就是那个interface。看起来对内部的接口完全非常明确了，没什么可讲的，但是其中还是有很多东西可讲的，我先讲讲我们常见的。</p>\n\n<p>对服务发现的方案选择：</p>\n\n<ol>\n<li>使用主动推送的方式，注册中心每次发生变化都会推送最新的列表给服务的使用者</li>\n<li>使用被动拉取的方式，注册中心每次变化都保存好，然后使用者每次调用服务者的时候，先到注册中心查询一次</li>\n</ol>\n\n<p>好了，让我分别来说说这两个方案</p>\n\n<h4>使用主动推送</h4>\n\n<p>可以让使用者很快的更新服务者信息，使用者调用服务者的时候只需要在本地的一个hash表中查询一下即可，并且注册中心挂掉了之后，也不影响使用者调用服务者，看起来不错吧。那么让我来说说这方案的弊端，首先要实现watch－notify机制，大概有人会说不是有Zookeeper吗？自带该机制和数据冗余机制，那么我想说的是，当业务量起来的时候，Zookeeper的watch机制真的能顶住吗？接着是，服务者的负载均衡并不好处理。那么有没有解决方法，这个可以参看dubbo中的注册中心是如何玩耍的。</p>\n\n<h4>使用被动拉取</h4>\n\n<p>这个好像很直观，但是每次都查询注册中心，这性能，注册中心能处理的了吗？大家不妨想一下DNS服务器，其实该方案完全可以使用简单的内部DNS实现。那么该方案的好处不言而喻，负载均衡好处理，并且非常简单。但是问题呢，性能和稳定性是要深入考虑的事情。</p>\n\n<h3>传输协议</h3>\n\n<p>剩下的就是需要考虑的传输协议了，为什么要考虑传输协议？原因很简单：</p>\n\n<ol>\n<li>接口平均传输的数据量和自己的内网带宽的平衡</li>\n<li>是否要跨语言协作</li>\n<li>是否侵入业务了</li>\n</ol>\n\n<h4>为何考虑带宽</h4>\n\n<p>虽然注册中心第一步解决了我们的快速扩张的问题，但是呢，内网带宽毕竟是有限的。随着服务数量增多和调用量的增加，有时候我们会发现，同一个服务我们明明增加了N台部署响应时间却下降了很多，按照公式应该响应时间不变的呀？这个时候，我们可能猛然看到监控上我们的内网带宽已经跑满了。</p>\n\n<h4>为何考虑跨语言</h4>\n\n<p>难道一个公司不就是一种后端语言？其实不然，我曾见面试过一个公司，内部的业务之复杂，语言使用之繁多。很多时候，我们需要站在一个公司发展的角度上考虑这个问题，而不是一个纯技术的细节上考虑这个问题。</p>\n\n<h4>为什么要考虑是否侵入业务</h4>\n\n<p>不侵入业务，就是尽可能的封装底层的实现，让业务线更少的去考虑底层发生什么了。很多人说，这对业务线的人不公平，阻碍了他们的技术发展。其实不然，让业务线的同仁们更多，更深入的思考业务发展是非常重要的事情，我个人认为研发分两类，一类是玩算法和底层的，另一类就是深入业务的，他们都有自己的长处和短处。其实减少业务的侵入是为了更快的实现产品功能，让产品上线，让公司的业务快速迭代起来，这样对任何人都是有好处的。</p>\n\n<h3>接口升级</h3>\n\n<p>这个与其说是升级，不如说是怎么做不同版本的数据共存和A/B测试。一般在很多成行的SOA系统中，已经很完善了，我没必要在这里面多废话。但是还是要多说一句，数据多版本不易，且升且小心。</p>\n\n<h3>对外接口</h3>\n\n<p>对外接口，大家很快就会想到Restful。随着现在创业的兴起，应当说是智能手机和Web2.0的兴起（更应该说的本质是，网络带宽变好，手机流量降价）。但是对外接口并不限于Restful，还有大家不愿意谈的纯Socket接口。对外接口可讲的东西非常多，不过思路上基本上和对内接口没太大的差别，所以我这里就主要讲下为什么选择纯Socket的接口。</p>\n\n<p>我们不愿意面对的长链接，很多研发，甚至公司级别，都不愿意去尝试这个技术。原因嘛，请看下面：</p>\n\n<ol>\n<li>调试复杂，研发成本高</li>\n<li>国内网络环境复杂，加重了第一条</li>\n<li>国内用户对流量敏感，长链接心跳控制不好，容易被认为是偷流量</li>\n<li>协议设计比较复杂，对研发的要求上升了很多</li>\n</ol>\n\n<p>但是长链接真的就那么难嘛，其实不然。更多时候，是产品层面用不上，一般只有IM类型的应用或者实时对战类的游戏才会选择长链接。当然偶尔我们也想提供一些高互动的交互，如果只是在应用内短暂使用，完全可以选择websocket（不过面对中国强大的高铁和运营商基础建设的规划TT）。</p>\n\n<h2>接口的保护</h2>\n\n<h3>安全保护</h3>\n\n<p>当我们面对很多外部接口的时候，我们需要考虑数据的安全性。为什么要考虑安全性：</p>\n\n<ol>\n<li>包含用户数据</li>\n<li>包含交易数据</li>\n<li>以及甚至你不想让用户自己知道的数据</li>\n</ol>\n\n<p>保护接口的方式最基本的是SSL/TLS，然后呢：</p>\n\n<ol>\n<li>对称加密的方式</li>\n<li>非对称加密的方式</li>\n<li>动态秘钥</li>\n</ol>\n\n<p>先说下我们为什么要在SSL/TLS下面再次进行加密呢？大家可能听说过以色列一个网络安全公司的事情了，换句话说一旦根证书被释放出去了，分分钟可以做SSL/TLS的man in middle的攻击。同时有些稍微高级的用户，会针对你的接口进行刷接口的行为。</p>\n\n<h4>对称加密</h4>\n\n<p>简单且易用。但是问题也明显，一旦秘钥泄漏或者被用户强猜出来了，那么影响还是很大的。</p>\n\n<h4>非对称加密的方式</h4>\n\n<p>实现略复杂，同样也面临第一种方式的问题。但是可以有一个专门的秘钥管理人员，生成公钥和秘钥对后，将公钥交付给客户端，将秘钥交付给服务器端，大大减少了泄漏的可能性。同时用户即便猜出了客户端的公钥，也无法解密别的用户提交的数据，而只能伪造请求。</p>\n\n<h4>动态秘钥</h4>\n\n<p>机器在运行的时候，定期自动和秘钥管控中心进行秘钥交换，每台机器在交互的时候使用的秘钥都不同。虽然可以带来一定的安全性，但是会给秘钥管理中心带来巨大的压力，同时调试也比较麻烦。这种方式个人认为适合使用在，传统小交易量的行业中，例如说银行的ATM机。</p>\n\n<h3>熔断保护</h3>\n\n<h4>内部接口需要吗？</h4>\n\n<p>我们可以假定一个场景，服务者A有10个服务器，但是由于使用者B的算法错误，总是先选择服务者A的某台服务器，那么我们可以想象到服务者A的某台服务器压力非常大，然后逐步的就失去了响应，接着就会被认为被离线，接着使用者B又同样的方式打掉了第二台服务器。带来的影响就是，轻者响应速度很慢，严重的就是整个系统雪崩性的逐个崩溃停止服务。</p>\n\n<h4>一般怎么做</h4>\n\n<p>不管对内部还是对外部，我们都可以选择使用漏桶和令牌桶等算法来保护接口。对外部，我们还可以通过使用时间戳加整个URL整体签名技术来防止重放攻击和进行限流保护。</p>\n","id":27258581512608640561098849374883940320,"intro":"随着微服务的兴起，在工作当中会涉及到很多接口互相调用的情况，本文从宏观上介绍了微服的接口设计原则。","published":true,"published_at":63734916123,"title":"像架构师一样来思考微服务接口设计","topic_id":1},{"content":"<p>原文地址： <a href=\"https://nextviewventures.com/blog/peace-of-mind-businesses/?utm_source=ttalk.im&utm_medium=website&utm_campaign=Tech%2520Talk\">“让人心安”也是一种生意</a></p>\n\n<p>我的第一笔种子投资之一是在一家想要在课本发行上寻求突破的公司。他们的团队很棒，他们开发出一种比传统教科书便宜20倍，更好，更方便的数字教科书产品。团队将这款让人叹为观止的产品推向的了市场，但是结果是，这项产品并未像预想的商业模式运作起来。</p>\n\n<p>将我们正在进行的业务了类型进行了错误的评估和分类是我们所犯的最核心的错误。我们认为大学教科书是传媒业，但是事实并非如此。学生购买昂贵的教科书，并非只为了每天花费数个小时来学习其中过得内容的，同时他们也是为了以防万一在有需要的时候，可以快速翻阅其中的内容。他们购买图书时，购买后内心感到平静比购买图书和及获取图书上的内容更重要。</p>\n\n<p>另一个“让人心安”的生意的例子是保险和信贷监控。还有一些生意中“让人心安”的成分和这个两个例子相比并不明显，或者体现在别的方面上，但是不管怎么说，“让人心安”已经成为了产品价值中重要的部分。这类业务有趣的地方是，它的运作方式往往和创业公司所想构建的业务运作方式是截然不同的。例如，一个用高用户参与度的软件会被认为是一个成功的软件产品，但是在“让人心安”类型的生意中，高用户参与度将是一个不好的信号。</p>\n\n<p>这类业务的重点就是，用户觉得他们无需关心你所解决的问题，因为你已经为他们解决的很好了。所以， 在这类业务中，我们只希望一定量的用户参与进来让他们帮助我们高效的完成产品或服务，同时用来提示其它用户我们产品还存在和继续付费使用的价值。换句话说，大量的用户参与进来可能会给用户更多的机会来质疑他们是否应该继续为我们的产品支付服务费，甚至可能会导致大量的用户流失。让人安心类型的生意，用户参与度并不是非常重要。</p>\n\n<p>“让人心安”这种生意是建立在信任的基础上，用户信任对于这类公司要远超其它类型的公司。 整个业务的重点是用户不必担心产品正在解决的问题，因此无法兑现其品牌承诺会造成灾难性的后果。</p>\n\n<p>建立信誉是非常困难的事情，很多保险公司品牌即便没有百年的资产，也有数十年的资产可以进行参考。而LifeLock的创始人，通过将自己的社会保险号和全世界分享来建立信誉。教科书发行商都花费了大量的时间和金钱用来争取大学教授的认可，这些大学教授是用户决定购买的重要推手（译者注：这就是为什么国外很多教科书很贵，且每年没啥大的变动，也让你买新的）。</p>\n\n<p>这种灵活多变的规则，让在这个领域的创业公司很难获得关注。这需要大笔的自己进场，或者非常取巧的营销手段或者一些渠道的背书才能获得最初的关注。</p>\n\n<p>并不是所有的企业都是在运作“让人心安”的生意，但是那些运作这种生意的企业看起来都很好。如果一个企业可以跨过这个领域的门槛，他们将获得巨大的用户留存率和潜在的惊人毛利润。 这些业务往往不是赢家通吃，但可以非常持久。</p>\n\n<p>这就是为什么保险公司通常都会有100多年的历史，为什么教科书公司，可以在已经被数字媒体支配的世界中将教科书销售到200美元。当今世界中，有很多这种公司使用这种策略，我相信还会有更多公司使用这种策略。</p>\n","id":127210524609375559397497241270734407599,"intro":"有一些花钱买放心的 business，如保险，教科书，杀毒软件等，有点像交保护费。这种类型的 business 需要长久累计下来的良好的信誉，用户活跃度不重要。","published":true,"published_at":63739450782,"title":"“让人心安”也是一种生意","topic_id":1},{"content":"<h2>SBCL是什么</h2>\n\n<p>SBCL是Common Lisp的一个实现，也是笔者比较推荐的一个实现，因为看到著名企业<a href=\"https://www.grammarly.com/?utm_source=ttalk.im&utm_medium=website&utm_campaign=Tech%2520Talk\">Grammarly</a>也在使用这个实现，并且该实现得到了Google的程序员的支持。</p>\n\n<h2>出现了什么问题</h2>\n\n<p>SBCL对UTF8的支持一直很好，但是在编写一个东西的时候出现了个奇怪的东西，通过SBCL的的repl存储到redis中的数据，并不是UTF-8的，并且是完全错误的。</p>\n\n<h2>解决问题</h2>\n\n<h3>输入输出编码检查</h3>\n\n<p>在SBCL的repl中使用下面的代码</p>\n\n<pre><code><span class=\"code\">\n<span class=\"paren1\">(<span class=\"code\">stream-external-format <span class=\"special\">*standard-output*</span></span>)</span>\n<span class=\"paren1\">(<span class=\"code\">stream-external-format <span class=\"special\">*standard-input*</span></span>)</span>\nsb-impl::*default-external-format*\n</span></code></pre>\n\n<p>得到的结果是(:ASCII :REPLACEMENT #\\?)，说明默认的输入输出的格式是ASCII的</p>\n\n<h3>解决方法</h3>\n\n<p>是用了下面这段代码</p>\n\n<pre><code><span class=\"code\">\n<span class=\"paren1\">(<span class=\"code\"><i><span class=\"symbol\">defun</span></i> set-default-external-format <span class=\"paren2\">(<span class=\"code\">external-format</span>)</span>\n  <span class=\"paren2\">(<span class=\"code\">assert <span class=\"paren3\">(<span class=\"code\">sb-impl::find-external-format external-format</span>)</span></span>)</span>\n  <span class=\"paren2\">(<span class=\"code\">setf <span class=\"special\">sb-impl::*default-external-format*</span> external-format</span>)</span>\n  <span class=\"paren2\">(<span class=\"code\"><i><span class=\"symbol\">with-output-to-string</span></i> <span class=\"paren3\">(<span class=\"code\"><span class=\"special\">*error-output*</span></span>)</span>\n    <span class=\"paren3\">(<span class=\"code\">setf <span class=\"special\">sb-sys:*stdin*</span>\n          <span class=\"paren4\">(<span class=\"code\">sb-sys:make-fd-stream 0 <span class=\"keyword\">:name</span> <span class=\"string\">\"standard input\"</span> <span class=\"keyword\">:input</span> t <span class=\"keyword\">:buffering</span> <span class=\"keyword\">:line</span></span>)</span></span>)</span>\n    <span class=\"paren3\">(<span class=\"code\">setf <span class=\"special\">sb-sys:*stdout*</span>\n          <span class=\"paren4\">(<span class=\"code\">sb-sys:make-fd-stream 1 <span class=\"keyword\">:name</span> <span class=\"string\">\"standard output\"</span> <span class=\"keyword\">:output</span> t <span class=\"keyword\">:buffering</span> <span class=\"keyword\">:line</span></span>)</span></span>)</span>\n    <span class=\"paren3\">(<span class=\"code\">setf <span class=\"special\">sb-sys:*stderr*</span>\n          <span class=\"paren4\">(<span class=\"code\">sb-sys:make-fd-stream 2 <span class=\"keyword\">:name</span> <span class=\"string\">\"standard error\"</span> <span class=\"keyword\">:output</span> t <span class=\"keyword\">:buffering</span> <span class=\"keyword\">:line</span></span>)</span></span>)</span>\n    <span class=\"paren3\">(<span class=\"code\">setf <span class=\"special\">sb-sys:*tty*</span> \n        <span class=\"paren4\">(<span class=\"code\">make-two-way-stream <span class=\"special\">sb-sys:*stdin*</span> <span class=\"special\">sb-sys:*stdout*</span></span>)</span></span>)</span> \n    <span class=\"paren3\">(<span class=\"code\">princ <span class=\"paren4\">(<span class=\"code\">get-output-stream-string <span class=\"special\">*error-output*</span></span>)</span> <span class=\"special\">sb-sys:*stderr*</span></span>)</span></span>)</span></span>)</span>\n</span></code></pre>\n\n<p>将SBCL的repl输入输出设定为了UTF-8。</p>\n","id":305649956240045886573557766352306019152,"intro":"Common Lisp的实现SBCL日常使用中的一些问题处理和解决方法。此次解决在特定场景下SBCL的repl操作redis不能正常保存为UTF-8","published":true,"published_at":63737806238,"title":"SBCL的repl中使用UTF-8","topic_id":1},{"content":"<h2>什么是花名册和出席</h2>\n\n<p>XMPP的<a href=\"https://tools.ietf.org/html/rfc6120\" >RFC6120 Extensible Messaging and Presence Protocol (XMPP): Core </a>非常详细的介绍了XMPP的核心协议。核心协议虽然非常好的完成了数据流交换机制，以及建立了非常强大的可扩展体系，但是这还不能称为即时通信系统。因此XMPP在<a href=\"https://tools.ietf.org/html/rfc6121\" >RFC6121 Extensible Messaging and Presence Protocol (XMPP):Instant Messaging and Presence</a>中详细的介绍了，花名册，出席和端到端消息交换。</p>\n\n<h3>花名册</h3>\n\n<p>作为成熟的即时通讯系统，就必然有联系人的管理和存储机制，花名册就是XMPP用来进行管理和存储一个用户的好友们的机制。</p>\n\n<h3>出席</h3>\n\n<p>XMPP为了让用户知道自己的联系人什么时候在线和可进行通讯。XMPP建立了一种通知机制，当用户的联系人在线状态发生变化的时候，服务器会自动向用户发送通知，也就是出席机制。</p>\n\n<h2>花名册的使用</h2>\n\n<h3>ver 属性</h3>\n\n<p>ver属性是一个标识名册信息的特定版本的字符串。它的值必须仅由服务器生成并且必须由客户端不透明地处理。服务器可以使用任何适当的方法来生成该版本ID, 类似名册数据的哈希值或一个严格递增的序列号。</p>\n\n<p>因为数据同步天生就存在很多不确定性，因此在RFC6121中就做出了明确规定，一切以服务器为准，这样就解决了同步操作中的冲突问题。</p>\n\n<h3>名册管理</h3>\n\n<p>XMPP中名册管理是通过IQ处理来完成的。在逻辑上并没有复杂的操作，只是常见的增删改查，唯一的增加的就是XMPP的名册管理多出了一个服务器推送名册的功能。这是因为XMPP支持多客户端（resource）同时登录的原因。</p>\n\n<h4>名册获取</h4>\n\n<p>客户端会给服务器发送出下面的XML用来获取名册\r\n<code>XML\r\n&lt;iq from='juliet@example.com/balcony'\r\n       id='bv1bs71f'\r\n       type='get'&gt;\r\n    &lt;query xmlns='jabber:iq:roster'/&gt;\r\n  &lt;/iq&gt;\r\n</code>\r\n而服务器必须做出应答，即便是用户的名册为空的时候也不应返回error，而是返回空的result\r\n<code>XML\r\n &lt;iq id='bv1bs71f'\r\n       to='juliet@example.com/chamber'\r\n       type='result'&gt;\r\n    &lt;query xmlns='jabber:iq:roster' ver='ver7'&gt;\r\n      &lt;item jid='nurse@example.com'/&gt;\r\n      &lt;item jid='romeo@example.net'/&gt;\r\n    &lt;/query&gt;\r\n  &lt;/iq&gt;\r\n&lt;iq id='bv1bs71f'\r\n       to='juliet@example.com/chamber'\r\n       type='result'&gt;\r\n    &lt;query xmlns='jabber:iq:roster' ver='ver9'/&gt;\r\n  &lt;/iq&gt;\r\n</code>\r\n只有，且仅有名册服务不存在的时候，才应返回error应答\r\n<code>XML\r\n&lt;iq id='bv1bs71f'\r\n          to='juliet@example.com/chamber'\r\n          type='error'&gt;\r\n       &lt;error type='cancel'&gt;\r\n         &lt;item-not-found\r\n             xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/&gt;\r\n       &lt;/error&gt;\r\n     &lt;/iq&gt;\r\n</code></p>\n\n<h4>名册修改</h4>\n\n<p>名册的修改是通过IQ的set操作完成的，所有的增加和修改都需要包含联系人的全部信息，因为XMPP不存在局部修改这个花名册中联系人功能\r\n<code>XML\r\n&lt;iq from='juliet@example.com/balcony'\r\n       id='ph1xaz53'\r\n       type='set'&gt;\r\n     &lt;query xmlns='jabber:iq:roster'&gt;\r\n       &lt;item jid='nurse@example.com'\r\n             name='Nurse'&gt;\r\n         &lt;group&gt;Servants&lt;/group&gt;\r\n       &lt;/item&gt;\r\n     &lt;/query&gt;\r\n   &lt;/iq&gt;\r\n</code>\r\n而删除操作是复用了subscription，关于subscription属性会在第二部分关于出席里面进行详细介绍。在这个删除操作中会给subscription属性赋值为remove。\r\n<code>XML\r\n&lt;iq from='juliet@example.com/balcony'\r\n       id='hm4hs97y'\r\n       type='set'&gt;\r\n     &lt;query xmlns='jabber:iq:roster'&gt;\r\n       &lt;item jid='nurse@example.com'\r\n             subscription='remove'/&gt;\r\n     &lt;/query&gt;\r\n   &lt;/iq&gt;\r\n</code>\r\n需要注意的是，因为<a href=\"https://tools.ietf.org/html/rfc3921\" >RFC3921</a>，并没有定义花名册是带有版本的。因此会在流打开的时候通过下面的XML来协商特性。\r\n<code>XML\r\n&lt;ver xmlns='urn:xmpp:features:rosterver'/&gt;\r\n</code>\r\n如果一个服务器支持带版本的名册，任何对花名册进行修改的操作都会引起版本的变动。</p>\n\n<h2>eJabberd中的花名册实现</h2>\n\n<h3>mod_roster</h3>\n\n<p>eJabberd对花名册的管理是通过插件机制来完成，核心流程都是由mod_roster来完成的。eJabberd的花名册存储方式有多种方式，有Mnesia，Riak，LDAP和ODBC，并且这些存储引擎可以通过配置文件动态指定。</p>\n\n<p>mod_roster在初始化过程中会将自己加入Hook中，并构建对应的存储后端。最重要的是，mod_roster对花名册的IQ处理默认是使用单队列（一个Erlang进程）来序列处理。\r\n<code>Erlang\r\nstart(Host, Opts) -&gt;\r\n    %% 默认情况是使用一个队列完成所有处理的\r\n    IQDisc = gen_mod:get_opt(iqdisc, Opts, one_queue),\r\n    TrackedFuns = [read_roster_version,\r\n                   write_roster_version,\r\n                   get_roster,\r\n                   get_roster_by_jid_t,\r\n                   get_subscription_lists,\r\n                   roster_subscribe_t,\r\n                   get_roster_by_jid_with_groups_t,\r\n                   update_roster_t,\r\n                   del_roster_t,\r\n                   read_subscription_and_groups\r\n                   ],\r\n    %% 启动后端模块\r\n    gen_mod:start_backend_module(?MODULE, Opts, TrackedFuns),\r\n    mod_roster_backend:init(Host, Opts),\r\n    %% 注册roster相关的hook请求\r\n    ejabberd_hooks:add(roster_get, Host,\r\n                       ?MODULE, get_user_roster, 50),\r\n    ejabberd_hooks:add(roster_in_subscription, Host,\r\n                       ?MODULE, in_subscription, 50),\r\n    ejabberd_hooks:add(roster_out_subscription, Host,\r\n                       ?MODULE, out_subscription, 50),\r\n    ejabberd_hooks:add(roster_get_subscription_lists, Host,\r\n                       ?MODULE, get_subscription_lists, 50),\r\n    ejabberd_hooks:add(roster_get_jid_info, Host,\r\n                       ?MODULE, get_jid_info, 50),\r\n    ejabberd_hooks:add(remove_user, Host,\r\n                       ?MODULE, remove_user, 50),\r\n    ejabberd_hooks:add(anonymous_purge_hook, Host,\r\n                       ?MODULE, remove_user, 50),\r\n    ejabberd_hooks:add(roster_get_versioning_feature, Host,\r\n                       ?MODULE, get_versioning_feature, 50),\r\n    %% 添加roster的IQ处理流程\r\n    gen_iq_handler:add_iq_handler(ejabberd_sm, Host, ?NS_ROSTER,\r\n                                  ?MODULE, process_iq, IQDisc).\r\n</code>\r\n对花名册的处理主要都是由<code>mod_roster:process_iq</code>完成的，process_iq封装了process_iq_get和process_iq_set，get主要负责花名册的查询工作。\r\n<code>Erlang\r\nprocess_iq_get(From, To, #iq{sub_el = SubEl} = IQ) -&gt;\r\n    LServer = From#jid.lserver,\r\n    try\r\n        %% 请求带版本了\r\n        AttrVer = xml:get_tag_attr(&lt;&lt;&quot;ver&quot;&gt;&gt;, SubEl),\r\n        %% 是否准许请求带版本\r\n        VersioningEnabled = roster_versioning_enabled(LServer),\r\n        %% 得到DB中的版本\r\n        VersionOnDb = roster_version_on_db(LServer),\r\n        %% 根据版本获取IQ\r\n        {ItemsToSend, VersionToSend} =\r\n        get_user_roster_based_on_version(AttrVer, VersioningEnabled, VersionOnDb,\r\n                                         From, To),\r\n        IQ#iq{type = result,\r\n              sub_el = create_sub_el(ItemsToSend, VersionToSend)}\r\n    catch\r\n        _:_ -&gt;\r\n            IQ#iq{type = error,\r\n                  sub_el = [SubEl, ?ERR_INTERNAL_SERVER_ERROR]}\r\n    end.\r\n</code>\r\n在<code>get_user_roster_based_on_version</code>的时候会去判断是否需要发送版本，以及花名册数据。在<code>get_user_roster_based_on_version</code>的时候，会直接使用roster_get这个hook进行数据获取，这样就给开发者一个机会，可以在不用修改mod_roster的情况下，客户端要获取的花名册的过程中对花名册内部条目的修改。</p>\n\n<p>而process_iq_set的操作，更多是依赖数据库事务的遍历写入操作。\r\n<code>Erlang\r\nprocess_iq_set(#jid{lserver = LServer} = From, To, #iq{sub_el = SubEl} = IQ) -&gt;\r\n    #xmlel{children = Els} = SubEl,\r\n    %% 使用roster_set来过滤所有的消息\r\n    ejabberd_hooks:run(roster_set, LServer, [From, To, SubEl]),\r\n    %% 逐条处理消息\r\n    lists:foreach(fun(El) -&gt; process_item_set(From, To, El) end, Els),\r\n    IQ#iq{type = result, sub_el = []}.\r\n</code>\r\n此处需要重点注意的是，<code>process_item_set</code>这个函数，每修改一个花名册条目，就会增加花名册版本一次。例如说一共处理10个item，初始版本是1，处理完后的版本就是11了。</p>\n\n<h2>总结</h2>\n\n<p>eJabberd非常完整的实现了花名册部分，并且在多个关键点给出了Hook，让开发者可以非常容易的不修改mod_roster的情况下就能对花名册的一些功能进行扩展。后面的文章将会介绍出席，以及XMPP的出席和花名册机制的缺陷。</p>\n","id":267589484649965320012954274902464595617,"intro":"XMPP","published":false,"published_at":63734916126,"title":"eJabberd 的花名册和出席 (1)","topic_id":1},{"content":"<h1>Elixir调用Erlang的代码</h1>\n\n<p>Elixir调用Erlang的代码非常简单，就是将Erlang相应的模块前面加上“:”符号。然后用“.”代替Erlang的“:”符号。</p>\n\n<p>好了如下面的Erlang代码</p>\n\n<pre><code><span class=\"code\"><span class=\"function\">ists:sort</span><span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">[<span class=\"code\">3, 2, 1</span>]</span></span>)</span>.</span></code></pre>\n\n<p>在Elixir中直接可以写成\r\n<code>elixir\r\n:lists.sort([3, 2, 1])\r\n</code></p>\n\n<p>非常简单方便</p>\n\n<h1>Erlang调用Elixir代码</h1>\n\n<p>首先要在rebar.config中添加Elixir的依赖</p>\n\n<pre><code><span class=\"code\"><span class=\"function\">deps</span>, <span class=\"paren1\">[<span class=\"code\"><span class=\"paren2\">{<span class=\"code\"> elixir, <span class=\"string\">\"1.1.*\"</span>,\r\n         <span class=\"paren3\">{<span class=\"code\">git, <span class=\"string\">\"git://github.com/elixir-lang/elixir\"</span>,<span class=\"paren4\">{<span class=\"code\">tag,<span class=\"string\">\"v1.1.1\"</span></span>}</span></span>}</span></span>}</span></span>]</span>}.</span></code></pre>\n\n<p>接着要在rebar.config中添加lib支持</p>\n\n<pre><code><span class=\"code\">{lib_dirs, <span class=\"paren1\">[<span class=\"code\">\r\n  <span class=\"string\">\"deps/elixir/lib\"</span>\r\n]</span>}</span>.</span></code></pre>\n\n<p>这样我们才能使用Elixir相关的类库。</p>\n\n<p>如果我们想在Rebar工程中混合使用Elixir和Erlang，那么就需要使用rebar的插件了。该插件地址为：https://github.com/yrashk/rebar_elixir_plugin</p>\n\n<p>同样，我们需要在rebar.config中进行下配置\r\n<code>erlang\r\n{deps, [{ rebar_elixir_plugin, &quot;.*&quot;,\r\n         {git, &quot;git://github.com/yrashk/rebar_elixir_plugin&quot;}}]}.\r\n%% Let rebar know about the new plugins\r\n{plugins, [rebar_elixir_compiler, rebar_exunit] }.\r\n</code>\r\n用Rebar生成独立运行的环境</p>\n\n<p>为了能让我们生成独立运行的环境，我们还需要在realtool.config中添加</p>\n\n<pre><code><span class=\"code\">{app, elixir, <span class=\"paren1\">[<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">mod_cond, app</span>}</span>,<span class=\"paren2\">{<span class=\"code\">incl_cond, include</span>}</span>,<span class=\"paren2\">{<span class=\"code\">lib_dir,<span class=\"string\">\"../deps/elixir/lib/elixir\"</span></span>}</span></span>]</span>}</span></code></pre>\n\n<p>在rebar.config中添加</p>\n\n<pre><code><span class=\"code\">{post_hooks, <span class=\"paren1\">[<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">compile, <span class=\"string\">\"rm -rf deps/elixir/ebin\"</span></span>}</span></span>]</span>}.</span></code></pre>\n\n<p>这样做是为了让rebar在编译之后删除deps下Elixir没有生成beam的ebin，当我们使用incl_cond的时候，我们才不会发生多个地方存在elixir.app的冲突。</p>\n","id":144463479857209175585324602698789540628,"intro":"Erlang/Elixir","published":false,"published_at":63734916125,"title":"Erlang 和 Elixir 的互操作","topic_id":1},{"content":"<h1>什么是DNS</h1>\n\n<p>DNS全称Domain Name System，Domain Name被译为域名，中文名为域名系统，也称为域名解析系统；另外域名服务器Domain Name Server也简称为DNS。  </p>\n\n<p>域名系统是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。DNS是具有树型结构的名字空间，核心功能是完成域名到IP地址的转换，使用TCP和UDP端口53。</p>\n\n<p>通俗地说，DNS帮助用户在互联网上寻找路径。在互联网上的每一个计算机都拥有一个唯一的地址，称作“IP地址”（即互联网协议地址）。由于IP地址（为一串数字）不方便记忆，DNS允许用户使用一串常见的字母（即“域名”）取代。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。当用户在应用程序中输入DNS名称时，DNS服务可以将此名称解析为与之相关的其他信息，如IP地址。因为，你在上网时输入的网址，是通过域名解析系解析找到相对应的IP地址，这样才能上网。其实，域名的最终指向是IP。  </p>\n\n<p>虽然域名系统后便于人们记忆，但网络中的计算机之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名服务器（Domain Name Server）来完成，这里的DNS就是域名服务器。</p>\n\n<h1>DNS的简史</h1>\n\n<p>60年末代，美国资助试验性广域计算机风，称为ARPAnet。70年代时，ARPAnet只是一个拥有几百台主机的小网络，仅需要一个HOSTS文件就可以容纳所需要主机信息，HOSTS提供的是主机名也IP地址的映射关系，也就是说可以用主机名进行网络信息的共享，而不需要记住IP地址。但是随着网络的扩在，HOSTS文件已经不能够快速完成解析任务了，这时DNS出现了。  </p>\n\n<p>DNS最早于1983年由保罗·莫卡派乔斯（Paul Mockapetris）发明；原始的技术规范在882号因特网标准草案（RFC 882）中发布。1987年发布的第1034和1035号草案修正了DNS技术规范，并废除了之前的第882和883号草案。在此之后对因特网标准草案的修改基本上没有涉及到DNS技术规范部分的改动。</p>\n\n<p>早期的域名必须以英文句号“.”结尾,当用户访问 www.ttalk.im 的HTTP服务时必须在址栏中输入：http://www.ttalk.im. ，这样DNS才能够进行域名解析。如今DNS服务器已经可以自动补上结尾的句号。</p>\n\n<p>当前，对于域名长度的限制是63个字符，包括www.和.com或者其他的扩展名。域名同时也仅限于ASCII字符的一个子集，这使得很多其他语言无法正确表示他们的名字和单词。基于Punycode码的IDNA系统，可以将Unicode字符串映射为有效的DNS字符集，这已经通过了验证并被一些注册机构作为一种变通的方法所采纳。</p>\n\n<h1>DNS的价值和问题</h1>\n\n<p>DNS是一个分布式的数据库，它允许对整个数据库的各个部分进行本地控制，本地控制也是就所谓的授权，可以把数据库的一部分进行授权，减轻主DNS服务器的压力，就是按域结构进行授权。同时，一旦DNS配置成功，HOSTS文件可以为空。因为DNS的出现就是要代替HOSTS文件的。只需一条语句就可以127.0.0.1 localhost. 。</p>\n\n<h3>价值</h3>\n\n<ul>\n<li>DNS解析是互联网绝大多数应用的实际寻址方式。</li>\n<li>域名技术的再发展、以及基于域名技术的多种应用，丰富了互联网应用和协议。</li>\n<li>域名是互联网上的身份标识，是不可重复的唯一标识资源。</li>\n<li>互联网的全球化使得域名成为标识一国主权的国家战略资源。</li>\n</ul>\n\n<h3>问题</h3>\n\n<p>但是DNS整个系统在设计之初，并没有太多考虑安全问题，因此，DNS整个体系存在一定的安全问题。主要有：</p>\n\n<ul>\n<li>针对域名系统的恶意攻击：DDOS攻击造成域名解析瘫痪。</li>\n<li>域名劫持：修改注册信息、劫持解析结果。</li>\n<li>根域名的归属和根域名主机安全问题</li>\n</ul>\n","id":206711763796221524253399214524658198712,"intro":"读者可能已经注意到了DNS是一个非常重要的协议，它可以直接让服务商知道每个请求要去往哪里。同时，读者可能已经注意到了，很多浏览器和手机应用已经开始使用DNS over HTTPS来避免运营商发现请求的目标。本文将简单介绍DNS是什么。\n","published":true,"published_at":63737545008,"title":"什么是DNS","topic_id":1},{"content":"<h2>为什么写这个</h2>\n\n<p>近期Erlang语言的排名上升了，算事可喜可贺的事情，国内知名的MQTT产品EMQ也受到了广大厂家和研发的认可。但是有人就提出了疑问，为什么EMQ选择使用Erlang而非Java作为开发？虽然并不了解作者本人的想法，但是本篇将从Java虚拟机和Erlang运行时的层面上说明下Erlang为什么更适合消息总线类产品。</p>\n\n<h2>宏观比较</h2>\n\n<h3>Erlang运行时</h3>\n\n<p>Erlang是一种函数类型语言，使用Actor模型。在Erlang中一个Actor就是一个Erlang进程，Actor通过彼此之间传递消息来完成通信。Erlang运行时采用执行beam文件中的bytecode来完成工作。</p>\n\n<h3>JVM</h3>\n\n<p>Java是一门面向对象的语言，JVM是通过执行Java原文件编译后class文件中的bytecode来完成相应的工作，这让Java具备的一次编译只要JVM版本兼容就可以多处运行。同时JVM会通过JIT技术，将class文件中的bytecode进行即时编译生成高性能的本地代码以提高执行速度。</p>\n\n<h2>线程使用</h2>\n\n<h3>Erlang运行时</h3>\n\n<p>Erlang会为创建和系统中安装CPU数量相同的OS线程，这些线程被称为调度器。每个调度器会管理大量前面提到的Erlang进程。为了最大限度的利用调度器，Erlang会使用任务秘取相关技术，让Erlang进程自动在多个调度器中进行负载均衡。<br/>\n这些调度器通过<code>reduction</code>机制严格限制了每个Erlang进程执行的时间，同时使用任务优先级机制可以让高优先级的进程优先执行，从而实现Erlang进程软实时特性。<br/>\n由于Erlang的进程并非真正的OS线程或OS进程，只是Erlang运行时中的一组数据结构，因此非常轻量级，可以在创建成千上万个Erlang进程。</p>\n\n<h3>JVM</h3>\n\n<p>JVM将Java中的线程直接影射到OS级别的线程，因此Java中的线程调度直接依赖于操作系统的线程调度机制。同时，由于是OS级别的线程，因此是非常消耗资源的。JVM也提供了线程池的封装，用来调度异步任务，但是这些异步任务是无法做到软实时的。<br/>\n每个Java线程都会包含下面信息：</p>\n\n<ol>\n<li>一个程序计数器PC，用来保存当前指令地址 . 一个栈用来保存栈帧</li>\n<li>如果使用native方法还会创建一个native栈</li>\n</ol>\n\n<h2>内存管理</h2>\n\n<h3>Erlang运行时</h3>\n\n<h4>内存分配</h4>\n\n<p>Erlang运行时会大量使用内存池，根据使用目的不同划分多个内存池。<br/>\n由于Erlang本身并没有变量，每个Erlang的进程都拥有自己的堆和栈。Erlang进程的堆和栈共享一段内存空间，堆向上生长，栈向下生长，因此非常容易检测到堆栈溢出。<br/>\nErlang在消息传递的过程中会使用内存复制，对于大于64bytes的二进制在Erlang运行时中会独立内存池进行分配，当在进程间传递这种消息的时候只是传递指向该二进制的指针。</p>\n\n<h4>垃圾回收</h4>\n\n<p>对于超过64bytes的二进制使引用计数来进行垃圾回收。对于每个进程则采用内存分代垃圾回收。Erlang运行时的垃圾回收，是针对Erlang进程的堆栈进行的，当一个Erlang进程结束运行，可以将该进程所有内存直接回收，因此无需进行stop the world。</p>\n\n<h3>JVM</h3>\n\n<h4>内存分配</h4>\n\n<p>JVM将内存分为堆内存和非堆内存，堆内存保存了所有的Java对象，整个JVM共享这个堆。非堆内存，用来保存编译过的Java代码，以及JIT代码等。</p>\n\n<h4>垃圾回收</h4>\n\n<p>JVM堆内存使用分代垃圾回收，并且可以使用多种垃圾回收算法。但是对于堆内存回收不管何种算法都需要stop the world阶段。</p>\n\n<h2>并发</h2>\n\n<h3>Erlang运行时</h3>\n\n<p>Erlang使用了Actor模型，在Erlang语言层面上Erlang进程是不存在互锁的机制，所有的通讯都是通过消息传递进行的。<br/>\nErlang运行时中，当Erlang进程互发消息的时候，会使用off_heap机制，尽可能减少Erlang进程执行的时候需要加锁的次数</p>\n\n<h3>JVM</h3>\n\n<p>由于Java线程是OS线程，所以可以只是使用OS线程锁的相关元语。</p>\n\n<h2>网络IO</h2>\n\n<p>涉及到消息系统，一定会涉及到网络IO，因此在这里面单独讨论下。</p>\n\n<h3>Erlang运行时</h3>\n\n<p>Erlang默认优先使用高级IO多路复用的API，在没有这个API的情况下，默认使用select作为IO多路复用。整个Erlang运行时共享一个IO多路复用。所有的调度器使用leader/follower模式，为了确保IO的实效和Erlang进程的软实时性，Erlang调度器会使用<code>reduction</code>机制，在执行一定量Erlang进程后强制检查IO是否有触发。但是与leader/follower模式稍有不同的是，如果一个Erlang调度器发现已经有另一个调度器在检查IO，会立刻放IO多路复用的锁去调取可执行的Erlang进程来执行。</p>\n\n<h4>socket处理模式</h4>\n\n<p>因为Erlang进程的轻量性，因此在Erlang中socket处理方案是为每个socket创建一个Erlang进程，socket断开连接后，可以选择Erlang进程直接退出。和socket绑定的Erlang进程可以直接进行业务处理，而不会影响IO复用器进行IO复用。</p>\n\n<h3>JVM</h3>\n\n<p>JVM封装了多种IO多路复用，并且在支持AIO。但是JVM并不提供类似Erlang运行时的IO任务管理机制，需要研发人员自行开发。</p>\n\n<h4>netty框架</h4>\n\n<p>Java中开发网络IO，netty是一个非常完善的Java网络框架，并经过大量的实践检验，可以在netty代码中看到大量针对JVM的IO子系统的bug进行针对性优化的代码。将IO处理，任务处理和编解码进行非常完整的规划，并提供了大量的基础设施。<br/>\nnetty使用的是IO Per Thread模型，在一般服务器开发中又使用acceptor和worker线程分开的方案，acceptor和worker实用的是boss/worker模式，当acceptor完成socket的接入流程就通过worker的wakup机制，将socket交付给worker的IO复用器进行复用。<br/>\n需要注意的是，worker在进行业务处理的时候，会直接占用worker线程直到业务结束，在此期间和该worker绑定的IO复用器是无法进行IO复用的。因此在netty开发的是有，需要经常使用netty的future线程池，将耗时的业务交给专用的线程池进行处理。</p>\n\n<h2>总结</h2>\n\n<p>选择Erlang进行消息系统开发有下面的优势：</p>\n\n<ol>\n<li>Erlang本身就是Actor模式，无需设计复杂的线程间消息交换机制（锁力度，队列管理等等）</li>\n<li>Erlang的GC不存在stop the world，因此内存效率相对较高，可以有效的防止大链接量下因为GC抖动而引起的socket接入失败（句柄不足依然会引起socket接入失败）</li>\n<li>软实时性，每个socket一个Erlang进程，所有的业务逻辑只需要线性思考（特殊的业务除外，依然需要进行异步思考），Erlang运行时自动完成IO，任务切换，不会因为线性思考而影响IO复用</li>\n<li>自带分布式，在一定量级前无需过度思考机器间RPC</li>\n<li>Erlang的binary操作可以进行二进制位操作，进行位级别的编解码非常简单</li>\n</ol>\n\n<p>当然选择Erlang进行消息系统开发也有下面一些劣势：</p>\n\n<ol>\n<li>Erlang语法是函数式，受众群体小</li>\n</ol>\n\n<p>总体来讲，Erlang开发消息系统的时候，除了语法外，心智负担比较小。</p>\n","id":17565483275317697480571316991366289144,"intro":"对Erlang的运行机制进行了简单介绍，同时对比Java和Erlang的运行时，来说明为什么Erlang不单单可以用来开发业务型应用，同时也适合开发消息总线。","published":true,"published_at":63737625859,"title":"为什么Erlang适合开发消息总线","topic_id":1},{"content":"<h2>Actor模型</h2>\n\n<h3>Actor模型定义</h3>\n\n<p>Actor模型可以说是并发编程中非常常见的一种模型，该模型是Carl Hewitt在1973年提出的。</p>\n\n<h3>Actor模型如何工作</h3>\n\n<ol>\n<li>Actor是独立的，每个Actor只管理自己的内部数据，对外暴露一个通信用的邮箱</li>\n<li>Actor都是通过向另一Actor暴露的邮箱发送消息来进行通信</li>\n<li>Actor之间的通讯行为是异步的</li>\n</ol>\n\n<h3>Actor模型中的Actor可以做什么</h3>\n\n<ol>\n<li>接收消息并进行相应处理</li>\n<li>创建新的Actor</li>\n<li>发送消息给另一个Actor</li>\n</ol>\n\n<h2>Actor实现</h2>\n\n<h3>Erlang的Actor实现</h3>\n\n<ol>\n<li>Erlang的Actor模型是基于Erlang进程实现的</li>\n<li>Erlang的Actor在死亡后会立刻进行垃圾处理</li>\n<li>Erlang的Actor直被Erts内部的POSIX线程调度</li>\n</ol>\n\n<h3>Akka的Actor实现</h3>\n\n<ol>\n<li>Akka的Actor模型以类为基础，通过Java的类库来实现</li>\n<li>Akka的Actor在死亡后，需要等待JVM进行GC时才进行垃圾处理</li>\n<li>Akka的Actor是通过Java的线程池调度</li>\n</ol>\n\n<h3>两种实现的差异</h3>\n\n<h4>Actor调度</h4>\n\n<p>Erlang的调度方式是抢占式公平调度（Erts强行切换），Akka的调度是协作式调度（完全依赖Actor主动放弃调度器）。</p>\n\n<p>Erlang的Actor调度会受到CPU数量和Actor数量影响，具体例子可以看下面：</p>\n\n<ul>\n<li>我们的CPU为2Core时，process数为200，每个process平均获得CPU的能力 1/200 ＊ 2  ＝ 1% 。</li>\n<li>我们的CPU为4Core时，process数为200，每个process平均获得CPU的能力 1/200 ＊ 4 ＝ 2% 。</li>\n<li>我们的CPU为8Core时，process数为1000，每个process平均获得CPU的能力 1/1000 * 8 Core = 0.8%。</li>\n</ul>\n\n<p>也就是说，Erlang在进程数不变的时候，增加CPU会增加每个Erlang进程的执行时，而Akka的调度是协作式的调度，这就代表着我们无法得到上面例子中的算式，当一个调度器上的某个Actor在做一个非常长时间的计算，完全由可能让调度器上的其它Actor不能按时调度。</p>\n\n<h4>IO操作</h4>\n\n<p>Erlang的Actor在执行IO的时候会进入等待状态，放弃调度线程，Akkaz不使用封装后的IO操作时会一直占用调度线程，使用封装的IO操作时才会放弃调度线程。\r\nErlang因为是Erts提供的IO操作，相对会比较统一，但是如果使用自己编写的Nif或Driver就需要注意是否存在同步的IO操作，因为这种原生的IO操作会让Actor一直占用调度线程。\r\n因此在Akka的Actor中，尽量不要使用Java提供的同步IO操作，而应该使用Akka提供的异步IO操作。</p>\n","id":6726492528192067248754332752029813593,"intro":"Actor模型的简单介绍，以及Akka和Erlang在实现Actor模型时有什么差异，分析CPU数量是如何对Erlang的调度器产生影响的。","published":true,"published_at":63734916126,"title":"Actor 模型介绍","topic_id":1},{"content":"<h1>起因</h1>\n\n<p>个人最近在学习OCaml和使用ZeroMQ，但是在我的OpenBSD上搞了好久，就是无法通过opam安装ZeroMQ的绑定。</p>\n\n<h1>发现问题</h1>\n\n<p>通过观察用户目录下.opam/system/build/可以发现，ZeroMQ的绑定依赖conf-zmq。而conf-zmq只是尝试编译一个文件test.c。在编译该文件的时候，使用的命令是gcc test.c -lzmq。通过查看test.c其中包含头文件的方式为#include&lt;zmq.h&gt;。根据gcc的参考文件，在Unix上会在下面这些文件夹中寻找头文件：</p>\n\n<pre><code><span class=\"code\">/usr/local/include\n/usr/lib/gcc-lib/target/version/include\n/usr/target/include\n/usr/include</span></code></pre>\n\n<p>但是当我用gcc -v test.c -lzmq的时候，却发现只有：</p>\n\n<pre><code><span class=\"code\">/usr/include</span></code></pre>\n\n<h1>解决方式</h1>\n\n<p>gcc在编译的时候，会使用几个标准的环境变量：</p>\n\n<pre><code><span class=\"code\">C_INCLUDE_PATH, CPATH, CPLUS_INCLUDE_PATH, DEPENDENCIES_OUTPUT,\nOBJC_INCLUDE_PATH, SUNPRO_DEPENDENCIES</span></code></pre>\n\n<p>我们只需要将我们需要的路径加入到这些环境变量中就可以了</p>\n\n<pre><code><span class=\"code\"><span class=\"special\">#在PATH中找到可执行文件程序的路径。\n</span>export PATH =$PATH:$HOME/bin\n<span class=\"special\">#gcc找到头文件的路径\n</span>C_INCLUDE_PATH=$C_INCLUDE_PATH:/usr/local/include/:/usr/local/include/zmq\nexport C_INCLUDE_PATH\n<span class=\"special\">#g++找到头文件的路径\n</span>CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/local/include/:/usr/local/include/zmq\nexport CPLUS_INCLUDE_PATH\n<span class=\"special\">#找到动态链接库的路径\n</span>LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib\nexport LD_LIBRARY_PATH\n<span class=\"special\">#找到静态库的路径\n</span>LIBRARY_PATH=$LIBRARY_PATH:/usr/local/lib\nexport LIBRARY_PATH</span></code></pre>\n\n<p>接着我们只要重新执行</p>\n\n<pre><code>opam install zmq</code></pre>\n","id":227042424101147267231852958400248232589,"intro":"OCaml的多核心支持尚不完善，但是OCaml的单进程性能非常客观，为了能让OCaml充分使用多核心机器的计算能力，就需要使用Master slave模型和队列模型进行分布式计算。这就不可避免的使用Socket通讯了，而ZeroMQ是一个非常不错的Socket抽象库，支持消息队列，消息路由等模式，因此选在在OCaml中使用ZeroMQ进行通讯。","published":true,"published_at":63737458068,"title":"如何通过 opam 安装 ZeroMQ","topic_id":1},{"content":"<h2>什么是模块</h2>\n\n<p>在前面的教程中，编写的代码都是在Erlang的shell中进行的。而交互式shell也被认为是绝大部分动态语言的特性之一。但是，任何一个项目不可能都是靠在shell中输入代码完成的，那么代码必须保存在某处。保存的代码就是模块，模块就是一个包含了大量函数的文件，因为模块是文件，就一定要有一个名字。</p>\n\n<h3>如何编写一个模块</h3>\n\n<p>编写模块非常简单，只要打开任意一款文本编辑器就可以了（推荐使用VScode，当然如果你喜欢命令行我十分乐意的推荐你使用Emacs），然后将我们前面教程中的函数放入其中，但是这并不能形成一个模块。</p>\n\n<p>Erlang定义一个模块必须满足下面两点\r\n1. 声明属性，这些属性描述模块自身的特质，例如模块的名字\r\n1. 声明函数。</p>\n\n<p>声明函数已经完成了，那么如何声明属性呢？Erlang的模块一般会定义模块名和导出函数，定义方法如下\r\n<code>Erlang\r\n-module(Name). %% 声明模块名，模块名必须是原子\r\n-export([Function1/Arity, Function2/Arity, ..., FunctionN/Arity]). %% 声明函数导出\r\n</code>\r\n下面就用就用<a href=\"https://www.ttalk.im/topics/7\" >Erlang 入门-命名函数</a>中的greet函数编写一个msg模块：\r\n``` Erlang\r\n-module(msg).\r\n-export([greet/2]).</p>\n\n<p>greet(male, Name) &rarr;\r\n  io:format(&ldquo;Hello, Mr. ~s!~n&rdquo;, [Name]);\r\ngreet(female, Name) &rarr;\r\n  io:format(&ldquo;Hello, Mrs. ~s!~n&rdquo;, [Name]);\r\ngreet(_, Name) &rarr;\r\n  io:format(&ldquo;Hello, ~s!~n&rdquo;, [Name]).\r\n```</p>\n\n<h3>如何在shell使用模块</h3>\n\n<p>先假定<code>msg.erl</code>文件保存在<code>/home/david/erl</code>目录下，我们在这个目录下用<code>erl</code>命令打开Erlang的交互式shell\r\n``` Erlang\r\nErlang/OTP 20 [erts-9.1.5] [64-bit] [ds:8:8:10] [hipe] [dtrace]</p>\n\n<p>Eshell V9.1.5  (abort with ^G)\r\n1&gt;  c(&ldquo;msg&rdquo;).\r\n{ok,msg}\r\n2&gt;msg:greet(male,&ldquo;David&rdquo;).\r\nHello, Mr. David!\r\nok\r\n3&gt;\r\n``<code>\r\n可以看到，当函数放到模块中的时候，调用函数就需要在函数前面增加模块名字和冒号，如</code>msg:greet(male,&ldquo;David&rdquo;).`</p>\n\n<h2>什么是Erlang的进程</h2>\n\n<p>在Erlang中，最小执行单位是进程，当然这个进程并不是系统层面上的进程，也不是系统的线程线程，而是Erlang运行时中自己定义的一种轻量级的执行结构。</p>\n\n<h3>Erlang的进程是如何执行的</h3>\n\n<p>在上面提到Erlang的进程是Erlang运行时中定义的一种轻量级的执行结构，那么这个结构就是由Erlang的运行时来进行调度。Erlang运行时在启动之后会创建出和内核数量相同的系统线程，每个线程上都绑定了一个Erlang虚拟机的CPU，然后Erlang通过调度算法将就绪的Erlang进程调度到这个虚拟机的CPU上。</p>\n\n<p>下面是调度逻辑的伪代码：\r\n<code>C\r\npid schedule() {\r\n  static int majorReductions = MREDS;  // 计算自己执行多少个时钟\r\n  majorReductions--; // 减少时钟\r\n  if(majorReductions == 0) {  \r\n    externalPoll(); // 时钟为0，检查外部事件，主要是socket\r\n    majorReductions = MREDS;  // 重置时钟\r\n   }  \r\n  checkTimeouts(); // 检查超时\r\n  pid p = nextReady(readyQueue); // 在准备就绪队列中找出就绪的进程 \r\n  p-&gt;reductions = REDS;  // 给进程分配时间片\r\n  p-&gt;status = RUNNING; // 标记运行\r\n  return p; // 返回给CPU\r\n}\r\n</code>\r\n是不是非常像一个操作系统在调度进程？因为Erlang的运行时，本身就在模拟一个特殊的基于寄存器的CPU，以及上面的一个任务调度器（最简单OS）。</p>\n\n<h3>如何创建一个Erlang进程</h3>\n\n<p>Erlang做为一个面向并发的计算机语言，它为我们提供了两个比较有意思的进程创建元语<code>erlang:spawn</code>和<code>erlang:spawn_link</code>。这两个元语唯一的差别是<code>erlang:spawn</code>在创建一个Erlang进程成功后就不管这个进程了。而<code>erlang:spawn_link</code>会将创建者和被创建者关联起来，如果创建者异常退出了，被创建者也会跟着退出，反之亦然。</p>\n\n<p>下面就用刚才建立好的msg模块演示下如何创建Erlang进程\r\n``` Erlang\r\nErlang/OTP 20 [erts-9.1.5] [64-bit] [ds:8:8:10] [hipe] [dtrace]</p>\n\n<p>Eshell V9.1.5  (abort with ^G)\r\n1&gt; c(&ldquo;msg&rdquo;).<br/>\n{ok,msg}\r\n2&gt; erlang:spawn(msg,greet,[male,&ldquo;David&rdquo;]).\r\nHello, Mr. David!\r\n&lt;0.67.0&gt;\r\n3&gt; erlang:spawn_link(msg,greet,[male,&ldquo;David&rdquo;]).\r\nHello, Mr. David!\r\n&lt;0.69.0&gt;\r\n4&gt; \r\n```\r\n在这里spawn_link创建的进程因为是正常退出，并没有引起shell的崩溃，在后面介绍异常的时候，将会讲解Erlang进程的异常退出和如何应对。</p>\n\n<h3>Erlang进程的特点</h3>\n\n<p>Erlang为什么要这么大费周章的去设置这样一种进程机制呢？因为它有以下特点：</p>\n\n<ol>\n<li>可抢占的软实时，这是Go，lua以及Akka库做不到的，毕竟Erlang最初设计是给电话交换机使用</li>\n<li>轻量级，可以快速创建和大量创建，在CPU和内存充足的条件下，一个Erlang运行时环境可以创建上百万的Erlang进程</li>\n<li>可监控，Erlang进程是可以通过监控机制进行管理，在异常退出的场景下，快速恢复。</li>\n</ol>\n\n<h2>总结</h2>\n\n<p>虽然已经讲述了如何进行进程创建了，但是大家很快就发现了吧，进程在执行完函数就立刻退出了，同时通过前面的<a href=\"https://www.ttalk.im/topics/6\" >文章</a>知道Erlang中的变量是不可变的，那么Erlang进程要如何交换数据呢。在后面的文章，将会逐步介绍消息传递，异常处理等知识。</p>\n","id":308944797000599015848626755869361830440,"intro":"Erlang/Elixir","published":false,"published_at":63734916125,"title":"Erlang 入门-模块和进程","topic_id":1},{"content":"<h2>XMPP的IQ</h2>\n\n<h3>什么是IQ机制</h3>\n\n<p>XMPP将信息系统抽象的非常好，将信息直接划分成了下面三大类：</p>\n\n<ol>\n<li><message/> 纯粹的消息&ldquo;推送&rdquo;机制，将实体推送信息到另一个实体, 类似发生在email系统里的通讯一样。</li>\n<li><presence/> 特定的&ldquo;广播&rdquo;或&ldquo;发布-订阅&rdquo;机制, 这里多个实体接收关于他们订阅的一个实体的信息。</li>\n<li><iq/> 是一个&ldquo;请求-应答&rdquo;机制, 类似某些情况下的超文本传输协议HTTP。</li>\n</ol>\n\n<p>从上面的分类就可以看出来，<message/>是一种双向的，异步的，一对一或一对多的通信机制。<presence/>是一种单向的，一对多广播机制。至此可以看出，剩下的就是请求应答机制了。</p>\n\n<h3>IQ机制怎么工作的</h3>\n\n<p>XMPP中规定IQ消息必须满足下面的条件</p>\n\n<ol>\n<li>必须有id属性，以便于实现跟踪和请求应答机制</li>\n<li>必须有type属性，以便于告知操作类型，并且必须是下面相应的值</li>\n<li>get  用于请求信息, 查询需要什么数据以完成更多操作, 等等。</li>\n<li>set  用于完成某个操作提供需要的数据, 设置新值, 取代旧值, 等等。</li>\n<li>result 用于对成功的get或set请求的应答。</li>\n<li>error 用于报告关于处理或递送一个get或set请求时发生的错误。</li>\n<li>接收到类型为get或set的IQ请求的实体必须返回一个类型为result或error的IQ应答. 该应答必须保留请求中的id属性(或为空，如果生成的节没有包含id属性)。</li>\n<li>接收到类型为result或error节的实体不能发送更多的类型为&ldquo;result&rdquo;或&ldquo;error&rdquo;的IQ应答来应答; 但是 请求实体可以发送另一个请求(例如, 使用类型为set的IQ对之前在get/result对中查询到的信息提供特定的信息)。</li>\n<li>类型为get或set的IQ节必须严格地包含一个子元素, 用来定义特定请求。</li>\n<li>类型为result的IQ节必须包含零或一个子元素。</li>\n<li>类型为error的IQ节可以包含相关的get或set子元素并且必须包含一个<error/>子元素。</li>\n</ol>\n\n<h3>IQ的价值</h3>\n\n<p>至此，可以看出IQ机制是在XMPP当中提供了一个完整的RPC方案，可以是同步的，也可以是异步的，这样就可以非常方便的去扩展XMPP了。</p>\n\n<h2>eJabberd是如何处理IQ请求的</h2>\n\n<h3>eJabberd中的IQ是如何触发的</h3>\n\n<p>在上一篇介绍 <a href=\"https://www.ttalk.im/topics/47\" >eJabberd的路由系统</a> 中就提到，当消息路由到ejabberd_sm模块时，且JID的resource部分为空了，就有可能触发IQ。在ejabberd_sm中IQ的handler都保存在sm_iqtable这个命名的ETS中。当ejabberd_c2s进程在这张ETS中找到相应的IQ处理模块的时候，如果处理模块没有额外参数的情况下，直接就使用模块对应函数处理，但是当模块有额外参数的时候，就会使用gen_iq_handler:handle来进行相应处理。细节可以看下面的代码\r\n<code>Erlang\r\nprocess_iq(From, To, Packet) -&gt;\r\n    IQ = jlib:iq_query_info(Packet),\r\n    case IQ of\r\n        #iq{xmlns = XMLNS} -&gt;\r\n            Host = To#jid.lserver,\r\n            %% IQ处理器的NS部分是全局唯一性的\r\n            %% 所以在查找的时候，只有一条记录\r\n            case ets:lookup(sm_iqtable, {XMLNS, Host}) of\r\n                [{_, Module, Function}] -&gt;\r\n                    ResIQ = Module:Function(From, To, IQ),\r\n                    if\r\n                        ResIQ /= ignore -&gt;\r\n                            ejabberd_router:route(To, From,\r\n                                                  jlib:iq_to_xml(ResIQ));\r\n                        true -&gt;\r\n                            ok\r\n                    end;\r\n                [{_, Module, Function, Opts}] -&gt;\r\n                    gen_iq_handler:handle(Host, Module, Function, Opts,\r\n                                          From, To, IQ);\r\n                [] -&gt;\r\n                    Err = jlib:make_error_reply(\r\n                            Packet, ?ERR_SERVICE_UNAVAILABLE),\r\n                    ejabberd_router:route(To, From, Err)\r\n            end;\r\n        reply -&gt;\r\n            ok;\r\n        _ -&gt;\r\n            Err = jlib:make_error_reply(Packet, ?ERR_BAD_REQUEST),\r\n            ejabberd_router:route(To, From, Err),\r\n            ok\r\n    end.\r\n</code></p>\n\n<h3>gen_iq_handler模块</h3>\n\n<p>eJabberd将IQ处理方案划分成下面四类：\r\n1. no_queue 无队列\r\n1. one_queue 一个队列\r\n1. {queues, N} 多个队列负载均衡\r\n1. parallel 并发处理</p>\n\n<p>为了方便管理，eJabberd统一使用gen_iq_handler来进行注册，当然也保留了不使用gen_iq_handler来注册IQ处理机制的方式。当不使用gen_iq_handler注册IQ处理机制的时候，相当于gen_iq_handler的no_queue模式，IQ处理都会在ejabberd_c2s进程中直接执行，唯一的差别是，gen_iq_handler会默认进行异常捕获。</p>\n\n<h4>gen_iq_handler是如何注册IQ处理模块的</h4>\n\n<p>eJabberd中的IQ处理模块都会被注册到ejabberd_sm进程所拥有的sm_iqtable这个ETS中，整个过程都是依赖ejabberd_sm这个gen_server的消息有序性来保证事务的。当不小心注册了一个同名的IQ，最后写入ETS的模块会被触发。</p>\n\n<p>gen_iq_handler在注册IQ模块的时候，会检测上面所说的处理方案，如果是one_queue或 {queues, N} 就会通过ejabberd_iq_sup这个supervisor产生一个或多个gen_iq_handler进程，并将这些进程的Pid作为附加参数注册到sm_iqtable中。</p>\n\n<h4>gen_iq_handler是如何处理IQ</h4>\n\n<p>当使用gen_iq_handler:handle来触发IQ处理的时候，会出现下面几种情况。</p>\n\n<ol>\n<li>no_queue 直接使用调用者的ejabberd_c2s 进程来处理，默认捕获异常</li>\n<li>one_queue 使用注册时候产生的gen_iq_handler来进行排队处理</li>\n<li>{queues, N} 使用注册时候产生的多个gen_iq_handler中的任意一个（随机负载均衡）来进行处理</li>\n<li>parallel 使用spawn生成一个无关联进程进行处理</li>\n</ol>\n\n<h2>总结</h2>\n\n<p>XMPP的IQ机制给XMPP带来了非常强的扩展能力，eJabberd中又将IQ处理方案进行了细化。我们甚至可以将eJabberd服务器当作一个强力的RPC业务处理服务器，是不是很有意思。</p>\n","id":77408649922502264221198098899043325125,"intro":"XMPP","published":false,"published_at":63734916124,"title":"eJabberd 的 IQ 处理","topic_id":1},{"content":"<h2>Erlang中的global和local名字</h2>\n\n<p>在开发Erlang/OTP程序的时候，看到最多的就是gen_server，在调用gen_server:start_link是，经常会看到{global,?MODULE}或{local,?MODULE}。那么这之间有什么差异呢？</p>\n\n<h3>Erlang进程的名字</h3>\n\n<p>Erlang在创建的进程的时候，给予Erlang进程一个PID作为进程的标识。那么经常使用的命名进程是怎么来的呢？是调用erlang:register这个函数将原子和PID进行关联，从而产生了命名的Erlang进程。而erlang:register函数接收的第一个参数可以看到是一个原子，而不是一个元组。难么gen_server为什么会使用一个元组呢？</p>\n\n<h3>gen_server是如何创建进程</h3>\n\n<p>先看下gen_server:start_link的代码</p>\n\n<pre><code><span class=\"code\">\nstart_link<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"variable\">Mod</span>, <span class=\"variable\">Args</span>, <span class=\"variable\">Options</span></span>)</span> -&gt;\n    gen:start<span class=\"paren1\">(<span class=\"code\"><span class=\"macro\">?MODULE,</span> <span class=\"symbol\">link</span>, <span class=\"variable\">Name</span>, <span class=\"variable\">Mod</span>, <span class=\"variable\">Args</span>, <span class=\"variable\">Options</span></span>)</span>.\n</span></code></pre>\n\n<p>从这里看到gen_server是调用gen模块进行进程创建的，那么gen模块又是如何创建进程的：</p>\n\n<pre><code><span class=\"code\"><span class=\"attribute\">-spec</span> start<span class=\"paren1\">(<span class=\"code\">module<span class=\"paren2\">(<span class=\"code\"></span>)</span>, linkage<span class=\"paren2\">(<span class=\"code\"></span>)</span>, emgr_name<span class=\"paren2\">(<span class=\"code\"></span>)</span>, module<span class=\"paren2\">(<span class=\"code\"></span>)</span>, term<span class=\"paren2\">(<span class=\"code\"></span>)</span>, options<span class=\"paren2\">(<span class=\"code\"></span>)</span></span>)</span> -&gt;\n    start_ret<span class=\"paren1\">(<span class=\"code\"></span>)</span>.\n \n<span class=\"function\">start</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">GenMod</span>, <span class=\"variable\">LinkP</span>, <span class=\"variable\">Name</span>, <span class=\"variable\">Mod</span>, <span class=\"variable\">Args</span>, <span class=\"variable\">Options</span></span>)</span> -&gt;\n    <span class=\"symbol\">case</span> where<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span></span>)</span> <span class=\"symbol\">of</span>\n    undefined -&gt;\n        do_spawn<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">GenMod</span>, <span class=\"variable\">LinkP</span>, <span class=\"variable\">Name</span>, <span class=\"variable\">Mod</span>, <span class=\"variable\">Args</span>, <span class=\"variable\">Options</span></span>)</span>;\n    <span class=\"variable\">Pid</span> -&gt;\n        <span class=\"paren1\">{<span class=\"code\">error, <span class=\"paren2\">{<span class=\"code\">already_started, <span class=\"variable\">Pid</span></span>}</span></span>}</span>\n    <span class=\"symbol\">end</span>.\n \n<span class=\"attribute\">-spec</span> start<span class=\"paren1\">(<span class=\"code\">module<span class=\"paren2\">(<span class=\"code\"></span>)</span>, linkage<span class=\"paren2\">(<span class=\"code\"></span>)</span>, module<span class=\"paren2\">(<span class=\"code\"></span>)</span>, term<span class=\"paren2\">(<span class=\"code\"></span>)</span>, options<span class=\"paren2\">(<span class=\"code\"></span>)</span></span>)</span> -&gt; start_ret<span class=\"paren1\">(<span class=\"code\"></span>)</span>.\n \n<span class=\"function\">start</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">GenMod</span>, <span class=\"variable\">LinkP</span>, <span class=\"variable\">Mod</span>, <span class=\"variable\">Args</span>, <span class=\"variable\">Options</span></span>)</span> -&gt;\n    do_spawn<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">GenMod</span>, <span class=\"variable\">LinkP</span>, <span class=\"variable\">Mod</span>, <span class=\"variable\">Args</span>, <span class=\"variable\">Options</span></span>)</span>.\n \n<span class=\"comment\">%%-----------------------------------------------------------------\n</span><span class=\"comment\">%% Spawn the process (and link) maybe at another node.\n</span><span class=\"comment\">%% If spawn without link, set parent to ourselves 'self'!!!\n</span><span class=\"comment\">%%-----------------------------------------------------------------\n</span><span class=\"function\">do_spawn</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">GenMod</span>, <span class=\"symbol\">link</span>, <span class=\"variable\">Mod</span>, <span class=\"variable\">Args</span>, <span class=\"variable\">Options</span></span>)</span> -&gt;\n    <span class=\"variable\">Time</span> = timeout<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Options</span></span>)</span>,\n    proc_lib:start_link<span class=\"paren1\">(<span class=\"code\"><span class=\"macro\">?MODULE,</span> init_it,\n            <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">GenMod</span>, <span class=\"symbol\">self</span><span class=\"paren3\">(<span class=\"code\"></span>)</span>, <span class=\"symbol\">self</span><span class=\"paren3\">(<span class=\"code\"></span>)</span>, <span class=\"variable\">Mod</span>, <span class=\"variable\">Args</span>, <span class=\"variable\">Options</span></span>]</span>, \n            <span class=\"variable\">Time</span>,\n            spawn_opts<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">Options</span></span>)</span></span>)</span>;\n<span class=\"function\">do_spawn</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">GenMod</span>, <span class=\"variable\">_</span>, <span class=\"variable\">Mod</span>, <span class=\"variable\">Args</span>, <span class=\"variable\">Options</span></span>)</span> -&gt;\n    <span class=\"variable\">Time</span> = timeout<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Options</span></span>)</span>,\n    proc_lib:start<span class=\"paren1\">(<span class=\"code\"><span class=\"macro\">?MODULE,</span> init_it,\n           <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">GenMod</span>, <span class=\"symbol\">self</span><span class=\"paren3\">(<span class=\"code\"></span>)</span>, <span class=\"symbol\">self</span>, <span class=\"variable\">Mod</span>, <span class=\"variable\">Args</span>, <span class=\"variable\">Options</span></span>]</span>, \n           <span class=\"variable\">Time</span>,\n           spawn_opts<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">Options</span></span>)</span></span>)</span>.\n \n<span class=\"function\">do_spawn</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">GenMod</span>, <span class=\"symbol\">link</span>, <span class=\"variable\">Name</span>, <span class=\"variable\">Mod</span>, <span class=\"variable\">Args</span>, <span class=\"variable\">Options</span></span>)</span> -&gt;\n    <span class=\"variable\">Time</span> = timeout<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Options</span></span>)</span>,\n    proc_lib:start_link<span class=\"paren1\">(<span class=\"code\"><span class=\"macro\">?MODULE,</span> init_it,\n            <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">GenMod</span>, <span class=\"symbol\">self</span><span class=\"paren3\">(<span class=\"code\"></span>)</span>, <span class=\"symbol\">self</span><span class=\"paren3\">(<span class=\"code\"></span>)</span>, <span class=\"variable\">Name</span>, <span class=\"variable\">Mod</span>, <span class=\"variable\">Args</span>, <span class=\"variable\">Options</span></span>]</span>,\n            <span class=\"variable\">Time</span>,\n            spawn_opts<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">Options</span></span>)</span></span>)</span>;\n<span class=\"function\">do_spawn</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">GenMod</span>, <span class=\"variable\">_</span>, <span class=\"variable\">Name</span>, <span class=\"variable\">Mod</span>, <span class=\"variable\">Args</span>, <span class=\"variable\">Options</span></span>)</span> -&gt;\n    <span class=\"variable\">Time</span> = timeout<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Options</span></span>)</span>,\n    proc_lib:start<span class=\"paren1\">(<span class=\"code\"><span class=\"macro\">?MODULE,</span> init_it,\n           <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">GenMod</span>, <span class=\"symbol\">self</span><span class=\"paren3\">(<span class=\"code\"></span>)</span>, <span class=\"symbol\">self</span>, <span class=\"variable\">Name</span>, <span class=\"variable\">Mod</span>, <span class=\"variable\">Args</span>, <span class=\"variable\">Options</span></span>]</span>, \n           <span class=\"variable\">Time</span>,\n           spawn_opts<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">Options</span></span>)</span></span>)</span>.</span></code></pre>\n\n<p>可以清楚的看到，使用的proc_lib，而proc_lib是对erlang:spawn_link进行封装，以确保初始化函数能正确运行，那么注册名字的秘密就在gen:init_it中。在gen:init_it中可以看到一个内部函数name_register</p>\n\n<pre><code><span class=\"code\"><span class=\"function\">name_register</span><span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">local, <span class=\"variable\">Name</span></span>}</span> = <span class=\"variable\">LN</span></span>)</span> -&gt;\n    <span class=\"symbol\">try</span> <span class=\"symbol\">register</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"symbol\">self</span><span class=\"paren2\">(<span class=\"code\"></span>)</span></span>)</span> <span class=\"symbol\">of</span>\n    true -&gt; true\n    <span class=\"symbol\">catch</span>\n    error:_ -&gt;\n        <span class=\"paren1\">{<span class=\"code\">false, where<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">LN</span></span>)</span></span>}</span>\n    <span class=\"symbol\">end</span>;\n<span class=\"function\">name_register</span><span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">global, <span class=\"variable\">Name</span></span>}</span> = <span class=\"variable\">GN</span></span>)</span> -&gt;\n    <span class=\"symbol\">case</span> global:register_name<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"symbol\">self</span><span class=\"paren2\">(<span class=\"code\"></span>)</span></span>)</span> <span class=\"symbol\">of</span>\n    yes -&gt; true;\n    no -&gt; <span class=\"paren1\">{<span class=\"code\">false, where<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">GN</span></span>)</span></span>}</span>\n    <span class=\"symbol\">end</span>;\n<span class=\"function\">name_register</span><span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">via, <span class=\"variable\">Module</span>, <span class=\"variable\">Name</span></span>}</span> = <span class=\"variable\">GN</span></span>)</span> -&gt;\n    <span class=\"symbol\">case</span> <span class=\"variable\">Module:register_name</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"symbol\">self</span><span class=\"paren2\">(<span class=\"code\"></span>)</span></span>)</span> <span class=\"symbol\">of</span>\n    yes -&gt;\n        true;\n    no -&gt;\n        <span class=\"paren1\">{<span class=\"code\">false, where<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">GN</span></span>)</span></span>}</span>\n    <span class=\"symbol\">end</span>.</span></code></pre>\n\n<p>此时此刻，可以看到global和local的明显差异。</p>\n\n<h3>local和global的区别</h3>\n\n<p>从上面的代码和对Erlang虚拟机的跟踪可以知道，erlang:register管理的名字和进程PID关联表只是调用者本地的Erlang虚拟机内的，不是整个集群中的。而global:register_name是通过global模块对集群中所有Erlang虚拟机进行操作。从这可以看出，Erlang语言本身并没有所谓本地名字或集群名字的概念，而这个概念是OTP当中的（但是Erlang有本地节点进程和远程节点进程的概念）。</p>\n\n<h2>Global模块分析</h2>\n\n<h3>global模块功能</h3>\n\n<ol>\n<li>管理全局名字</li>\n<li>管理全局锁</li>\n<li>维护Erlang集群的互联互通</li>\n</ol>\n\n<h3>global模块启动</h3>\n\n<p>该模块是在Erlang节点启动的时候自动被启动的，并且会组册一个名为global_name_server的进程。并且需要注意的是global模块本身就是一个gen_server，不过为了避免死循环，global模块使用gen_server注册的是本地名字。在global进程创建成功后，建立了大量的ets表，其中global_names表，global_pid_names表就是用来管理全局命名的。</p>\n\n<h3>global名字注册</h3>\n\n<p>注册名字的时候，就是让所有节点执行{register,Name,Pid,Method}。可以看下面这段代码：</p>\n\n<pre><code><span class=\"code\">\nregister_name<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"variable\">Pid</span></span>)</span> <span class=\"symbol\">when</span> <span class=\"symbol\">is_pid</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Pid</span></span>)</span> -&gt;\n    register_name<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"variable\">Pid</span>, <span class=\"symbol\">fun</span> random_exit_name/3</span>)</span>.\n     \n<span class=\"function\">register_name</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"variable\">Pid</span>, <span class=\"variable\">Method0</span></span>)</span> <span class=\"symbol\">when</span> <span class=\"symbol\">is_pid</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Pid</span></span>)</span> -&gt;\n    <span class=\"variable\">Method</span> = allow_tuple_fun<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Method0</span></span>)</span>,\n    <span class=\"variable\">Fun</span> = <span class=\"symbol\">fun</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Nodes</span></span>)</span> -&gt;\n        <span class=\"symbol\">case</span> <span class=\"paren1\">(<span class=\"code\">where<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">Name</span></span>)</span> =:= undefined</span>)</span> <span class=\"symbol\">andalso</span> check_dupname<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, <span class=\"variable\">Pid</span></span>)</span> <span class=\"symbol\">of</span>\n            true -&gt;\n                gen_server:multi_call<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Nodes</span>,\n                                      global_name_server,\n                                      <span class=\"paren2\">{<span class=\"code\"><span class=\"symbol\">register</span>, <span class=\"variable\">Name</span>, <span class=\"variable\">Pid</span>, <span class=\"variable\">Method</span></span>}</span></span>)</span>,\n                yes;\n            <span class=\"variable\">_</span> -&gt;\n                no\n        <span class=\"symbol\">end</span>\n    <span class=\"symbol\">end</span>,\n    <span class=\"macro\">?trace(</span><span class=\"paren1\">{<span class=\"code\">register_name, <span class=\"symbol\">self</span><span class=\"paren2\">(<span class=\"code\"></span>)</span>, <span class=\"variable\">Name</span>, <span class=\"variable\">Pid</span>, <span class=\"variable\">Method</span></span>}</span>),\n    gen_server:call<span class=\"paren1\">(<span class=\"code\">global_name_server, <span class=\"paren2\">{<span class=\"code\">registrar, <span class=\"variable\">Fun</span></span>}</span>, infinity</span>)</span>.\n</span></code></pre>\n\n<p>当gobal进程收到了{register,Name,Pid,Method}消息后，会向在global进程建立时建立的另一个无名进程发送消息{trans_all_known, Fun, From}，这个无名进程的代码如下：</p>\n\n<pre><code><span class=\"code\">\n loop_the_registrar<span class=\"paren1\">(<span class=\"code\"></span>)</span> -&gt;\n    <span class=\"symbol\">receive</span>\n        <span class=\"paren1\">{<span class=\"code\">trans_all_known, <span class=\"variable\">Fun</span>, <span class=\"variable\">From</span></span>}</span> -&gt;\n            <span class=\"macro\">?trace(</span><span class=\"paren1\">{<span class=\"code\">loop_the_registrar, <span class=\"symbol\">self</span><span class=\"paren2\">(<span class=\"code\"></span>)</span>, <span class=\"variable\">Fun</span>, <span class=\"variable\">From</span></span>}</span>),\n            gen_server:reply<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">From</span>, trans_all_known<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">Fun</span></span>)</span></span>)</span>;\n    <span class=\"variable\">Other</span> -&gt;\n            unexpected_message<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Other</span>, <span class=\"symbol\">register</span></span>)</span>\n    <span class=\"symbol\">end</span>,\n    loop_the_registrar<span class=\"paren1\">(<span class=\"code\"></span>)</span>.\n \n<span class=\"function\">unexpected_message</span><span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\"><span class=\"atom\">'EXIT'</span>, <span class=\"variable\">_Pid</span>, <span class=\"variable\">_Reason</span></span>}</span>, <span class=\"variable\">_What</span></span>)</span> -&gt;\n    <span class=\"comment\">%% global_name_server died\n</span>    ok;\n<span class=\"function\">unexpected_message</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Message</span>, <span class=\"variable\">What</span></span>)</span> -&gt; \n    error_logger:warning_msg<span class=\"paren1\">(<span class=\"code\"><span class=\"string\">\"The global_name_server ~w process \"</span>\n                             <span class=\"string\">\"received an unexpected message:</span><span class=\"string\">\\n</span><span class=\"string\">~p</span><span class=\"string\">\\n</span><span class=\"string\">\"</span>, \n                             <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">What</span>, <span class=\"variable\">Message</span></span>]</span></span>)</span>.\n</span></code></pre>\n\n<p>这个进程会使用trans_all_known来执行传入的函数，trans_all_known函数代码如下：</p>\n\n<pre><code><span class=\"code\">\ntrans_all_known<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Fun</span></span>)</span> -&gt;\n    <span class=\"variable\">Id</span> = <span class=\"paren1\">{<span class=\"code\"><span class=\"macro\">?GLOBAL_RID,</span> <span class=\"symbol\">self</span><span class=\"paren2\">(<span class=\"code\"></span>)</span></span>}</span>,\n    <span class=\"variable\">Nodes</span> = set_lock_known<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Id</span>, 0</span>)</span>,\n    <span class=\"symbol\">try</span>\n<span class=\"comment\">%当锁住了所有的节点，才执行相关的操作\n</span><span class=\"comment\">%全局的大锁呀，用多了性能还是比较差的\n</span>        <span class=\"variable\">Fun</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Nodes</span></span>)</span>\n    <span class=\"symbol\">after</span>\n        delete_global_lock<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Id</span>, <span class=\"variable\">Nodes</span></span>)</span>\n    <span class=\"symbol\">end</span>.\n \n<span class=\"function\">set_lock_known</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Id</span>, <span class=\"variable\">Times</span></span>)</span> -&gt; \n    <span class=\"variable\">Known</span> = get_known<span class=\"paren1\">(<span class=\"code\"></span>)</span>,\n    <span class=\"variable\">Nodes</span> = <span class=\"paren1\">[<span class=\"code\"><span class=\"symbol\">node</span><span class=\"paren2\">(<span class=\"code\"></span>)</span> | <span class=\"variable\">Known</span></span>]</span>,\n<span class=\"comment\">%Boss是List中最后的那个元素\n</span>    <span class=\"variable\">Boss</span> = the_boss<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Nodes</span></span>)</span>,\n    <span class=\"comment\">%% Use the  same convention (a boss) as lock_nodes_safely. Optimization.\n</span><span class=\"comment\">%先锁定住Boss\n</span>    <span class=\"symbol\">case</span> set_lock_on_nodes<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Id</span>, <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">Boss</span></span>]</span></span>)</span> <span class=\"symbol\">of</span>\n        true -&gt;\n<span class=\"comment\">%接这锁住剩下的节点\n</span>            <span class=\"symbol\">case</span> lock_on_known_nodes<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Id</span>, <span class=\"variable\">Known</span>, <span class=\"variable\">Nodes</span></span>)</span> <span class=\"symbol\">of</span>\n                true -&gt;\n                    <span class=\"variable\">Nodes</span>;\n                false -&gt; \n                    del_lock<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Id</span>, <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">Boss</span></span>]</span></span>)</span>,\n                    random_sleep<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Times</span></span>)</span>,\n                    set_lock_known<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Id</span>, <span class=\"variable\">Times</span>+1</span>)</span>\n            <span class=\"symbol\">end</span>;\n        false -&gt;\n            random_sleep<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Times</span></span>)</span>,\n            set_lock_known<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Id</span>, <span class=\"variable\">Times</span>+1</span>)</span>\n    <span class=\"symbol\">end</span>.\n \n<span class=\"function\">lock_on_known_nodes</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Id</span>, <span class=\"variable\">Known</span>, <span class=\"variable\">Nodes</span></span>)</span> -&gt;\n    <span class=\"symbol\">case</span> set_lock_on_nodes<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Id</span>, <span class=\"variable\">Nodes</span></span>)</span> <span class=\"symbol\">of</span>\n        true -&gt;\n            <span class=\"paren1\">(<span class=\"code\">get_known<span class=\"paren2\">(<span class=\"code\"></span>)</span> -- <span class=\"variable\">Known</span></span>)</span> =:= <span class=\"paren1\">[<span class=\"code\"></span>]</span>;\n        false -&gt;\n            false\n    <span class=\"symbol\">end</span>.\n \n<span class=\"function\">set_lock_on_nodes</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">_Id</span>, <span class=\"paren2\">[<span class=\"code\"></span>]</span></span>)</span> -&gt;\n    true;\n<span class=\"function\">set_lock_on_nodes</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Id</span>, <span class=\"variable\">Nodes</span></span>)</span> -&gt;\n    <span class=\"symbol\">case</span> local_lock_check<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Id</span>, <span class=\"variable\">Nodes</span></span>)</span> <span class=\"symbol\">of</span>\n        true -&gt;\n            <span class=\"variable\">Msg</span> = <span class=\"paren1\">{<span class=\"code\">set_lock, <span class=\"variable\">Id</span></span>}</span>,\n            <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Replies</span>, <span class=\"variable\">_</span></span>}</span> = \n                gen_server:multi_call<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Nodes</span>, global_name_server, <span class=\"variable\">Msg</span></span>)</span>,\n            <span class=\"macro\">?trace(</span><span class=\"paren1\">{<span class=\"code\">set_lock,<span class=\"paren2\">{<span class=\"code\">me,<span class=\"symbol\">self</span><span class=\"paren3\">(<span class=\"code\"></span>)</span></span>}</span>,<span class=\"variable\">Id</span>,<span class=\"paren2\">{<span class=\"code\">nodes,<span class=\"variable\">Nodes</span></span>}</span>,<span class=\"paren2\">{<span class=\"code\">replies,<span class=\"variable\">Replies</span></span>}</span></span>}</span>),\n            check_replies<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Replies</span>, <span class=\"variable\">Id</span>, <span class=\"variable\">Replies</span></span>)</span>;\n        false=Reply -&gt;\n            <span class=\"variable\">Reply</span>\n    <span class=\"symbol\">end</span>.</span></code></pre>\n\n<p>可以看出执行流程是这样的，先锁住集群中排序最大的那个节点，如上锁成功，则让所有的其余节点跟着上锁，如果上锁失败，则随机睡眠一段时间再接着尝试。如果当所有节点上都拿到锁，就执行名字注册，并且执行注册后。由于使用try after语句进行包裹，在执行最后一定会释放锁。</p>\n\n<h4>为什么这样上锁</h4>\n\n<p>首先全局的锁（GLOBAL_RID）是所有节点共享的，如果从随机的一个节点开始上锁，很容易出现同时好几个节点都在上锁而发生锁冲突，那么大家就约定先上锁某一个节点，这样能快速的发现锁的冲突。\n其次，因为要在没给节点上的ets表中添加一个记录，如果不能在所有参与节点上添加记录，会出现数据不一致的问题。\n最后，不能只锁定一个约定的节点，考虑到不稳定性，当节点出现异常无法连通的时候，那么这个锁的机制就无效了。</p>\n","id":299964005322925670293021034398418044003,"intro":"Erlang是一个非常强大的分布式平台，其中一大特点就是可以为集群中任意一个进程添加全集群唯一标识。本文通过分析Erlang/OTP的代码，来介绍Erlang是如何完成全集群唯一名标管理。也就是常说的进程名字管理。","published":true,"published_at":63734916123,"title":"Erlang集群的唯一标识管理","topic_id":1},{"content":"<h2>ejabberd_listener简介</h2>\n\n<p>ejabberd_listener模块，虽然是一个文件。但是，它包含了两个部分，第一部分是ejabberd_listener作为监控树进程启动，第二部分是作为这个监控树的子进程启动端口监听。</p>\n\n<p>ejabberd_listener模作为监控树进程启动的时候，是作为ejabberd_sup监控树中的子进程启动的。该进程启动后会在本地注册为ejabberd_listeners进程，是一个one_for_one模式的空监控树为后面启动各种各样的端口监听进程准备的。可以参考ejabberd_sup.erl中的代码。</p>\n\n<p>ejabberd_listener模块作为ejabberd_listeners监控树的子进程启动时，是在eJabberd整个应用启动的最后一步调用ejabberd_listener:start_listeners()完成的。可以参考ejabberd_app.erl中的代码。</p>\n\n<p>ejabberd_listener模块的大量代码都是为端口监听服务的，我们就具体分析下这些代码。</p>\n\n<h2>ejabberd_listener开启监听</h2>\n\n<pre><code><span class=\"code\"><span class=\"function\">start_listeners</span><span class=\"paren1\">(<span class=\"code\"></span>)</span> -&gt;\r\n  <span class=\"symbol\">case</span> ejabberd_config:get_local_option<span class=\"paren1\">(<span class=\"code\">listen</span>)</span> <span class=\"symbol\">of</span>\r\n    undefined -&gt;\r\n      ignore;\r\n    <span class=\"variable\">Ls</span>  -&gt;\r\n       <span class=\"variable\">Ls2</span> = lists:map<span class=\"paren1\">(<span class=\"code\">\r\n          <span class=\"symbol\">fun</span><span class=\"paren2\">(<span class=\"code\"><span class=\"paren3\">{<span class=\"code\"><span class=\"variable\">Port</span>, <span class=\"variable\">Module</span>, <span class=\"variable\">Opts</span></span>}</span></span>)</span>  -&gt;\r\n             <span class=\"symbol\">case</span> start_listener<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">Port</span>, <span class=\"variable\">Module</span>, <span class=\"variable\">Opts</span></span>)</span> <span class=\"symbol\">of</span>\r\n                <span class=\"paren2\">{<span class=\"code\">ok, <span class=\"variable\">_Pid</span></span>}</span> = <span class=\"variable\">R</span>  -&gt; <span class=\"variable\">R</span>;\r\n                <span class=\"paren2\">{<span class=\"code\">error, <span class=\"variable\">Error</span></span>}</span>  -&gt; <span class=\"symbol\">throw</span><span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">Error</span></span>)</span>\r\n           <span class=\"symbol\">end</span>\r\n        <span class=\"symbol\">end</span>, <span class=\"variable\">Ls</span></span>)</span>,\r\n       report_duplicated_portips<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Ls</span></span>)</span>,\r\n      <span class=\"paren1\">{<span class=\"code\">ok, <span class=\"paren2\">{<span class=\"code\"><span class=\"paren3\">{<span class=\"code\">one_for_one, 10, 1</span>}</span>, <span class=\"variable\">Ls2</span></span>}</span></span>}</span>\r\n   <span class=\"symbol\">end</span>.</span></code></pre>\n\n<p>从这段代码可以看出，ejabberd_listener:start_listeners()会从配置中找出所有的监听模块并通过start_listener函数逐个启动。start_listener通过调用start_listener2进而调用连个比较核心的函数start_module_sup和start_listener_sup来完成端口监听进程的启动。\r\n<code>erlang\r\nstart_module_sup(_PortIPProto, Module) -&gt;\r\n    Proc1 = gen_mod:get_module_proc(&quot;sup&quot;, Module),\r\n    ChildSpec1 =\r\n        {Proc1,\r\n         {ejabberd_tmp_sup, start_link, [Proc1, Module]},\r\n         permanent,\r\n         infinity,\r\n         supervisor,\r\n         [ejabberd_tmp_sup]},\r\n    supervisor:start_child(ejabberd_sup, ChildSpec1).\r\n</code>\r\nstart_module_sup使用gen_mod来生成监控树进程的名字，使用ejabberd_tmp_sup模块作为代码载体，创建一个监控进程在ejabberd_sup下启动。例如，ejabberd_c2s作为Module，那么Proc1就是ejabberd_c2s_sup。由于ejabberd_tmp_sup在构建监控树的时候，使用的是simple_one_for_one模式，所以在ejabberd_c2s_sup这个监控进程被创建成功后并不会创建一个ejabberd_c2s的进程。\r\n``` erlang\r\nstart_listener_sup(PortIPProto, Module, Opts) &rarr;\r\n    case Module:socket_type() of\r\n        independent &rarr;\r\n            Module:start_listener(PortIPProto, Opts);\r\n        _ &rarr;</p>\n\n<pre><code>        ChildSpec = {PortIPProto,\r\n                     {?MODULE, start, [PortIPProto, Module, Opts]},\r\n                     transient,\r\n                     brutal_kill,\r\n                     worker,\r\n                     [?MODULE]},\r\n        supervisor:start_child(ejabberd_listeners, ChildSpec)\r\nend.\r\n</code></pre>\n\n<pre><code>start_listener_sup函数首先会判断Module的端口类型，如果是独立监听的模块，那么就让模块通过start_listener来自行启动监听，如果是其它类型的，都认为是可以使用ejabberd_listener作为监听模块来进行监听。直接将ejabberd_listener模块作为ejabberd_listeners的子进程启动起来。\r\n\r\n## ejabberd_listener进行监听\r\nejabberd_listener是支持TCP端口监听和UDP端口监听的，这里重点分析下ejabberd_listener针对TCP的accept操作。\r\n```erlang\r\naccept(ListenSocket, Module, Opts) -&gt;\r\n    case gen_tcp:accept(ListenSocket) of\r\n        {ok, Socket} -&gt;\r\n            case {inet:sockname(Socket), inet:peername(Socket)} of\r\n                {{ok, Addr}, {ok, PAddr}} -&gt;\r\n                    ?INFO_MSG(\"(~w) Accepted connection ~w -&gt; ~w\",\r\n                              [Socket, PAddr, Addr]);\r\n                _ -&gt;\r\n                    ok\r\n            end,\r\n            ejabberd_socket:start(Module, gen_tcp, Socket, Opts),\r\n            ?MODULE:accept(ListenSocket, Module, Opts);\r\n        {error, Reason} -&gt;\r\n            ?INFO_MSG(\"(~w) Failed TCP accept: ~w\",\r\n                      [ListenSocket, Reason]),\r\n            ?MODULE:accept(ListenSocket, Module, Opts)\r\n    end.</code></pre>\n\n<p>accept函数在gen_tcp进行accept成功后，先获取对端的地址，并交付给ejabberd_socket:start函数去关联数据接收进程和协议进程。而accept函数，就继续循环调用gen_tcp的accept来接入连接。</p>\n\n<h2>自定义传输方式</h2>\n\n<p>假设我们需要在XMPP协议外面封装一层其它的协议，例如说STOMP，应该如何实现自己的监听和数据解析呢？</p>\n\n<p>有以下两种方式实现：</p>\n\n<p>1.使用independent方式，实现监听和协议解析，可以参考ejabberd_cowboy.erl。</p>\n\n<p>2.使用raw方式，让ejabberd_listener完成监听，自定义模块进行协议解析，可以参考ejabberd_socket.erl</p>\n\n<p>不管使用哪种方式都需要实现关键函数socket_type。剩下关于自定义传输方式模块的编写，将在后面的博客进一步介绍。</p>\n\n<h2>备注</h2>\n\n<p>在MongooseIM中Webosocket和BOSH都被实现了。所以在有需要使用Websocket的生产环境中，博主非常推荐使用MongooseIM来代替社区版本ejabberd。</p>\n","id":103358889677340480645254157458279719316,"intro":"XMPP","published":false,"published_at":63734916124,"title":"ejabberd_listener 代码分析","topic_id":1},{"content":"<h2>起因</h2>\n\n<p>近期大量语言发生了突飞猛进的发展，很多古代语言从单纯的支持ASCII演变成支持utf8。但是utf8并非是一个有效字符存储方案，所以在Erlang中一个中文字符会被定义为16位，也就是我们常说的utf16，从而达到高效但非节约的存储。那么自己常用的Common Lisp中，一个中文字符又是会被定义为多少位呢？</p>\n\n<h2>解决方案</h2>\n\n<p>首先要实现下面这函数</p>\n\n<pre><code><span class=\"code\"><span class=\"paren1\">(<span class=\"code\"><i><span class=\"symbol\">defun</span></i> get-object-size/octets <span class=\"paren2\">(<span class=\"code\">object</span>)</span>\n  <span class=\"paren2\">(<span class=\"code\">sb-sys:without-gcing\n    <span class=\"paren3\">(<span class=\"code\">nth-value 2 <span class=\"paren4\">(<span class=\"code\">sb-vm::reconstitute-object\n                  <span class=\"paren5\">(<span class=\"code\">ash <span class=\"comment\">;; 因为返回了一个fixnum对象的lispobj，因此需要进行这一步的处理\n</span>                        <span class=\"paren6\">(<span class=\"code\">logandc1 sb-vm:lowtag-mask <span class=\"paren1\">(<span class=\"code\">sb-kernel:get-lisp-obj-address object</span>)</span></span>)</span> <span class=\"comment\">;; 掩码掩掉最后nbit，得到lispobj真正地址,n取决于平台，x64是4\n</span>                       <span class=\"paren6\">(<span class=\"code\">- sb-vm:n-fixnum-tag-bits</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>\n\n<p>为什么会有这个函数呢，因为lisp在创建对象的时候和Erlang是一致的，都会将指针的空位设置为标签掩码。</p>\n\n<p>接着我们测试一个中文字符</p>\n\n<pre><code><span class=\"code\"><span class=\"paren1\">(<span class=\"code\"><i><span class=\"symbol\">defvar</span></i> <span class=\"special\">*c*</span> <span class=\"string\">\"中\"</span></span>)</span>\n<span class=\"paren1\">(<span class=\"code\">get-object-size/octets <span class=\"special\">*c*</span></span>)</span> <span class=\"comment\">;; 32bit</span></span></code></pre>\n\n<p>但是查阅了SBCL的代码的时候，发现</p>\n\n<pre><code><span class=\"code\"><span class=\"paren1\">(<span class=\"code\"><i><span class=\"symbol\">def!constant</span></i> sb!xc:char-code-limit #!-sb-unicode 256 #!+sb-unicode #x110000\n  <span class=\"string\">\"the upper exclusive bound on values produced by CHAR-CODE\"</span></span>)</span></span></code></pre>\n\n<p>也就是说，SBCL会使用一个32bit的位长来表示一个utf16的字符，具体可以参阅<a href=\"http://www.sbcl.org/sbcl-internals/Memory-Layout.html?utm_source=ttalk.im&utm_medium=website&utm_campaign=Tech%2520Talk\">Memory Layout</a>。</p>\n\n<h2>总结</h2>\n\n<p>从这个测试中可以发现，绝大部份古代语言真对宽字符会直接处理成utf16，而不是utf8。当然也有一些特例，例如OCaml，一个字符依然是8bits，对宽字符会处理成utf8。</p>\n","id":73396689907878178203466782248282592188,"intro":"因为字符串编码问题，引发笔者对SBCL的内存分配进行一次简单的探究。","published":true,"published_at":63734916124,"title":"在 SBCL 中获取对象位长","topic_id":1},{"content":"<h2>什么是路由</h2>\n\n<p>在网络工程上，定义路由（routing）是非常简单的，路由就是指分组从源到目的地时，决定端到端路径的网络范围的进程 。在eJabberd中，路由有这相似的定义，同样也是江西消息分组，从源送到目的地址。</p>\n\n<h2>ejabberd_c2s进程</h2>\n\n<p>ejabberd_c2s进程，是客户端在eJabberd服务进程中的代理（agent），全面负责一个客户端在服务进程中的所有的动作，包括认证，特性使用以及我们要说的路由。</p>\n\n<p>因为ejabberd_c2s进程作为客户端在服务进程中的代理，就要注意以下几个事项\r\n- 所有incoming，代表由服务端发给客户端的消息，所有outcoming，代表客户端发给服务端的消息\r\n- 只代表一个客户端，并且和客户端的链接状况紧密相连\r\n- 不负责网络消息的解码操作，只负责协议的动作操作，包括认证，特性协商和路由</p>\n\n<h2>ejabberd_router模块</h2>\n\n<p>ejabberd_router模块在启动的时候，会创建一个进程，但是该进程并不负责消息的路由，只负责路由的部分原信息管理和路由的高级抽象。</p>\n\n<h3>eJabberd中路由种类</h3>\n\n<h4>普通路由</h4>\n\n<p>这类路由，一般都是非常简单的消息，只需要经过简单的目的查找，即可将消息直接交付给目标进行处理。这种路由就像网络中路由一样可以存在多个层级，在eJabberd中是被做成分层处理的。</p>\n\n<h4>外部服务路由</h4>\n\n<p>这类路由，是代表那些不在eJabberd服务进程内的服务，需要通过特定方式将消息转发给特定服务，这种外部服务是通过某种方式在当前的eJabberd进程中注册的。</p>\n\n<h4>全局外部服务路由</h4>\n\n<p>这类路由，同样代表那些不在eJabberd服务进程内的服务，但是唯一区别的是，当前的eJabberd进程是无法直接访问的，需要通过eJabberd集群中特定eJabberd进程来完成访问。</p>\n\n<h4>s2s路由</h4>\n\n<p>这类路由，是eJabberd进行不同域和域之间互通的路由。只要双发都符合XMPP规范，并建立互相信任的链接后，就可以让A域下的用户和B域下的用户消息互通。</p>\n\n<h3>路由抽象</h3>\n\n<p>ejabberd_router将路由过程抽象为一个按序列进行的流水线，按照预先设定好的数据，将一个消息按序列流过各个路由模块，并且在路由模块中将消息处理分成两个阶段，一个阶段是filter，一个阶段是route。简单的说就是先进行初步过滤，在路由前尽可能过滤掉不需要的数据包，减少路由压力。</p>\n\n<pre><code><span class=\"code\"><span class=\"function\">route</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">From</span>, <span class=\"variable\">To</span>, <span class=\"variable\">Packet</span>, <span class=\"paren2\">[<span class=\"code\"></span>]</span></span>)</span> -&gt;\r\n    <span class=\"macro\">?ERROR_MSG(</span><span class=\"string\">\"error routing from=~ts to=~ts, packet=~ts, reason: no more routing modules\"</span>,\r\n               <span class=\"paren1\">[<span class=\"code\">jid:to_binary<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">From</span></span>)</span>, jid:to_binary<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">To</span></span>)</span>,\r\n                exml:to_binary<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">Packet</span></span>)</span></span>]</span>),\r\n    mongoose_metrics:update<span class=\"paren1\">(<span class=\"code\">global, routingErrors, 1</span>)</span>,\r\n    ok;\r\n<span class=\"function\">route</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">OrigFrom</span>, <span class=\"variable\">OrigTo</span>, <span class=\"variable\">OrigPacket</span>, <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">M|Tail</span></span>]</span></span>)</span> -&gt;\r\n    <span class=\"macro\">?DEBUG(</span><span class=\"string\">\"Using module ~p\"</span>, <span class=\"paren1\">[<span class=\"code\"><span class=\"variable\">M</span></span>]</span>),\r\n    <span class=\"comment\">%% 先过滤数据\r\n</span>    <span class=\"symbol\">case</span> <span class=\"paren1\">(<span class=\"code\"><span class=\"symbol\">catch</span> <span class=\"variable\">M:filter</span><span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">OrigFrom</span>, <span class=\"variable\">OrigTo</span>, <span class=\"variable\">OrigPacket</span></span>)</span></span>)</span> <span class=\"symbol\">of</span>\r\n        <span class=\"paren1\">{<span class=\"code\"><span class=\"atom\">'EXIT'</span>, <span class=\"variable\">Reason</span></span>}</span> -&gt;\r\n            <span class=\"comment\">%% 过滤阶段出现异常，记录下来\r\n</span>            <span class=\"comment\">%% 之后就不做过多的处理\r\n</span>            <span class=\"macro\">?DEBUG(</span><span class=\"string\">\"Filtering error\"</span>, <span class=\"paren1\">[<span class=\"code\"></span>]</span>),\r\n            <span class=\"macro\">?ERROR_MSG(</span><span class=\"string\">\"error when filtering from=~ts to=~ts in module=~p, reason=~p, packet=~ts, stack_trace=~p\"</span>,\r\n                       <span class=\"paren1\">[<span class=\"code\">jid:to_binary<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">OrigFrom</span></span>)</span>, jid:to_binary<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">OrigTo</span></span>)</span>,\r\n                        <span class=\"variable\">M</span>, <span class=\"variable\">Reason</span>, exml:to_binary<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">OrigPacket</span></span>)</span>,\r\n                        erlang:get_stacktrace<span class=\"paren2\">(<span class=\"code\"></span>)</span></span>]</span>),\r\n            ok;\r\n        drop -&gt;\r\n            <span class=\"comment\">%% 过滤后发现需要丢弃，就直接结束路由过程\r\n</span>            <span class=\"macro\">?DEBUG(</span><span class=\"string\">\"filter dropped packet\"</span>, <span class=\"paren1\">[<span class=\"code\"></span>]</span>),\r\n            ok;\r\n        <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">OrigFrom</span>, <span class=\"variable\">OrigTo</span>, <span class=\"variable\">OrigPacketFiltered</span></span>}</span> -&gt;\r\n            <span class=\"macro\">?DEBUG(</span><span class=\"string\">\"filter passed\"</span>, <span class=\"paren1\">[<span class=\"code\"></span>]</span>),\r\n            <span class=\"comment\">%% 任何一个匹配且路由成功的模块，都可以直接结束\r\n</span>            <span class=\"symbol\">case</span> <span class=\"symbol\">catch</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">M:route</span><span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">OrigFrom</span>, <span class=\"variable\">OrigTo</span>, <span class=\"variable\">OrigPacketFiltered</span></span>)</span></span>)</span> <span class=\"symbol\">of</span>\r\n                <span class=\"paren1\">{<span class=\"code\"><span class=\"atom\">'EXIT'</span>, <span class=\"variable\">Reason</span></span>}</span> -&gt;\r\n                    <span class=\"macro\">?ERROR_MSG(</span><span class=\"string\">\"error when routing from=~ts to=~ts in module=~p, reason=~p, packet=~ts, stack_trace=~p\"</span>,\r\n                               <span class=\"paren1\">[<span class=\"code\">jid:to_binary<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">OrigFrom</span></span>)</span>, jid:to_binary<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">OrigTo</span></span>)</span>,\r\n                                <span class=\"variable\">M</span>, <span class=\"variable\">Reason</span>, exml:to_binary<span class=\"paren2\">(<span class=\"code\"><span class=\"variable\">OrigPacketFiltered</span></span>)</span>,\r\n                                erlang:get_stacktrace<span class=\"paren2\">(<span class=\"code\"></span>)</span></span>]</span>),\r\n                    <span class=\"macro\">?DEBUG(</span><span class=\"string\">\"routing error\"</span>, <span class=\"paren1\">[<span class=\"code\"></span>]</span>),\r\n                    ok;\r\n                done -&gt;\r\n                    <span class=\"comment\">%% 在该模块已经成功路由，就不再向下个模块进行传递了\r\n</span>                    <span class=\"macro\">?DEBUG(</span><span class=\"string\">\"routing done\"</span>, <span class=\"paren1\">[<span class=\"code\"></span>]</span>),\r\n                    ok;\r\n                <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">From</span>, <span class=\"variable\">To</span>, <span class=\"variable\">Packet</span></span>}</span> -&gt;\r\n                    <span class=\"macro\">?DEBUG(</span><span class=\"string\">\"routing skipped\"</span>, <span class=\"paren1\">[<span class=\"code\"></span>]</span>),\r\n                    route<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">From</span>, <span class=\"variable\">To</span>, <span class=\"variable\">Packet</span>, <span class=\"variable\">Tail</span></span>)</span>\r\n            <span class=\"symbol\">end</span>\r\n    <span class=\"symbol\">end</span>.</span></code></pre>\n\n<p>eJabberd优先进行全局过滤，接着进行常规消息路由，再接着进行外部服务的消息路由，最后进行s2s路由。\r\n<code>Erlang\r\n%% 默认的路由模块\r\ndefault_routing_modules() -&gt;\r\n    [mongoose_router_global,%% 只使用filter_packet进行过滤，不进行任何路由操作\r\n     mongoose_router_localdomain, %% 只路由本host和subhosts的消息\r\n     mongoose_router_external_localnode, %% 本节点内外挂功能路由\r\n     mongoose_router_external, %% 所有节点外挂功能路由\r\n     ejabberd_s2s].\r\n</code></p>\n\n<h3>节点内路由</h3>\n\n<p>节点内路由，会将消息路由给用户和节点内的IQ handler。节点内路由是由ejabberd_local进行负责的，ejabberd_local在eJabberd启动的时候，会建立一个进程，用来管理本地注册的IQ handler。ejabberd_local在启动的时候，不单单建立了进程而且还将模块注册成host节点内默认路由。</p>\n\n<p>当消息进行路由的时候，ejabberd_local会先查看JID的user部分是否是空的，非空的情况下交给ejabberd_sm处理，当是空的时候那么一定是服务，就交给IQ处理，剩下的消息一概都忽略。</p>\n\n<pre><code><span class=\"code\"><span class=\"function\">do_route</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">From</span>, <span class=\"variable\">To</span>, <span class=\"variable\">Packet</span></span>)</span> -&gt;\r\n    <span class=\"macro\">?DEBUG(</span><span class=\"string\">\"local route~n</span><span class=\"string\">\\t</span><span class=\"string\">from ~p~n</span><span class=\"string\">\\t</span><span class=\"string\">to ~p~n</span><span class=\"string\">\\t</span><span class=\"string\">packet ~P~n\"</span>,\r\n           <span class=\"paren1\">[<span class=\"code\"><span class=\"variable\">From</span>, <span class=\"variable\">To</span>, <span class=\"variable\">Packet</span>, 8</span>]</span>),\r\n    <span class=\"symbol\">if</span>\r\n        <span class=\"comment\">%% user部分不为空\r\n</span>        <span class=\"comment\">%% 说明是给用户的，或者特定服务的，所以需要让ejabberd_sm来处理这个路由信息\r\n</span>        <span class=\"variable\">To#jid</span>.luser /= &lt;&lt;&gt;&gt; -&gt;\r\n            ejabberd_sm:route<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">From</span>, <span class=\"variable\">To</span>, <span class=\"variable\">Packet</span></span>)</span>;\r\n        <span class=\"comment\">%% resource部分为空，user部分为空了\r\n</span>        <span class=\"comment\">%% 如果是message或者presence的消息不进行任何处理\r\n</span>        <span class=\"variable\">To#jid</span>.lresource == &lt;&lt;&gt;&gt; -&gt;\r\n            #xmlel<span class=\"paren1\">{<span class=\"code\">name = <span class=\"variable\">Name</span></span>}</span> = <span class=\"variable\">Packet</span>,\r\n            <span class=\"symbol\">case</span> <span class=\"variable\">Name</span> <span class=\"symbol\">of</span>\r\n                &lt;&lt;<span class=\"string\">\"iq\"</span>&gt;&gt; -&gt;\r\n                    <span class=\"comment\">%% 如果是IQ信息，就交给IQ handler来进行处理\r\n</span>                    process_iq<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">From</span>, <span class=\"variable\">To</span>, <span class=\"variable\">Packet</span></span>)</span>;\r\n                &lt;&lt;<span class=\"string\">\"message\"</span>&gt;&gt; -&gt;\r\n                    ok;\r\n                &lt;&lt;<span class=\"string\">\"presence\"</span>&gt;&gt; -&gt;\r\n                    ok;\r\n                <span class=\"variable\">_</span> -&gt;\r\n                    ok\r\n            <span class=\"symbol\">end</span>;\r\n        true -&gt;\r\n            #xmlel<span class=\"paren1\">{<span class=\"code\">attrs = <span class=\"variable\">Attrs</span></span>}</span> = <span class=\"variable\">Packet</span>,\r\n            <span class=\"symbol\">case</span> xml:get_attr_s<span class=\"paren1\">(<span class=\"code\">&lt;&lt;<span class=\"string\">\"type\"</span>&gt;&gt;, <span class=\"variable\">Attrs</span></span>)</span> <span class=\"symbol\">of</span>\r\n                &lt;&lt;<span class=\"string\">\"error\"</span>&gt;&gt; -&gt; ok;\r\n                &lt;&lt;<span class=\"string\">\"result\"</span>&gt;&gt; -&gt; ok;\r\n                <span class=\"variable\">_</span> -&gt;\r\n                    ejabberd_hooks:run<span class=\"paren1\">(<span class=\"code\">local_send_to_resource_hook,\r\n                                       <span class=\"variable\">To#jid</span>.lserver,\r\n                                       <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">From</span>, <span class=\"variable\">To</span>, <span class=\"variable\">Packet</span></span>]</span></span>)</span>\r\n            <span class=\"symbol\">end</span>\r\n        <span class=\"symbol\">end</span>.\r\n</span></code></pre>\n\n<h3>用户间消息路由</h3>\n\n<p>真正在做用户间消息路由的模块ejabberd_sm模块，该模块同样会创建一个进程，但是该进程同样不进行任何路由操作，只保存路由元信息。其中保存着每个客户端JID和ejabberd_c2s进程对应的关系，以及IQ和处理模块和进程对应的关系。</p>\n\n<p>其中最核心的部分是，通过对session表的查找，将消息路由给特定的ejabberd_c2s进程，让该进程将消息发送给客户端。当无法找到相应的进程，就会进行离线存储处理。当然，当JID的resource部分为空的时候，会尝试匹配群组消息和IQ消息，如果是IQ消息的时候，会去查找sm_iqtable来确定IQ处理模块或进程，从而完成处理。</p>\n\n<pre><code><span class=\"code\"><span class=\"comment\">%% 进行普通路由\r\n</span><span class=\"function\">do_route</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">From</span>, <span class=\"variable\">To</span>, <span class=\"variable\">Packet</span></span>)</span> -&gt;\r\n    <span class=\"macro\">?DEBUG(</span><span class=\"string\">\"session manager~n</span><span class=\"string\">\\t</span><span class=\"string\">from ~p~n</span><span class=\"string\">\\t</span><span class=\"string\">to ~p~n</span><span class=\"string\">\\t</span><span class=\"string\">packet ~P~n\"</span>,\r\n           <span class=\"paren1\">[<span class=\"code\"><span class=\"variable\">From</span>, <span class=\"variable\">To</span>, <span class=\"variable\">Packet</span>, 8</span>]</span>),\r\n    #jid<span class=\"paren1\">{<span class=\"code\"> luser = <span class=\"variable\">LUser</span>, lserver = <span class=\"variable\">LServer</span>, lresource = <span class=\"variable\">LResource</span></span>}</span> = <span class=\"variable\">To</span>,\r\n    #xmlel<span class=\"paren1\">{<span class=\"code\">name = <span class=\"variable\">Name</span>, attrs = <span class=\"variable\">Attrs</span></span>}</span> = <span class=\"variable\">Packet</span>,\r\n    <span class=\"comment\">%% 没有资源信息的路由里面包含IQ处理\r\n</span>    <span class=\"symbol\">case</span> <span class=\"variable\">LResource</span> <span class=\"symbol\">of</span>\r\n        &lt;&lt;&gt;&gt; -&gt;\r\n            <span class=\"comment\">%% 特殊处理\r\n</span>            do_route_no_resource<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, xml:get_attr_s<span class=\"paren2\">(<span class=\"code\">&lt;&lt;<span class=\"string\">\"type\"</span>&gt;&gt;, <span class=\"variable\">Attrs</span></span>)</span>,\r\n                                 <span class=\"variable\">From</span>, <span class=\"variable\">To</span>, <span class=\"variable\">Packet</span></span>)</span>;\r\n        <span class=\"variable\">_</span> -&gt;\r\n            <span class=\"symbol\">case</span> <span class=\"macro\">?SM_BACKEND:get_sessions(</span><span class=\"variable\">LUser</span>, <span class=\"variable\">LServer</span>, <span class=\"variable\">LResource</span>) <span class=\"symbol\">of</span>\r\n                <span class=\"paren1\">[<span class=\"code\"></span>]</span> -&gt;\r\n                    <span class=\"comment\">%% 此处进行离线处理\r\n</span>                    do_route_offline<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Name</span>, xml:get_attr_s<span class=\"paren2\">(<span class=\"code\">&lt;&lt;<span class=\"string\">\"type\"</span>&gt;&gt;, <span class=\"variable\">Attrs</span></span>)</span>,\r\n                                     <span class=\"variable\">From</span>, <span class=\"variable\">To</span>, <span class=\"variable\">Packet</span></span>)</span>;\r\n                <span class=\"variable\">Ss</span> -&gt;\r\n                    <span class=\"variable\">Session</span> = lists:max<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Ss</span></span>)</span>,\r\n                    <span class=\"variable\">Pid</span> = <span class=\"symbol\">element</span><span class=\"paren1\">(<span class=\"code\">2, <span class=\"variable\">Session#session</span>.sid</span>)</span>,\r\n                    <span class=\"macro\">?DEBUG(</span><span class=\"string\">\"sending to process ~p~n\"</span>, <span class=\"paren1\">[<span class=\"code\"><span class=\"variable\">Pid</span></span>]</span>),\r\n                    <span class=\"comment\">%% 向目标进程route消息\r\n</span>                    <span class=\"variable\">Pid</span> ! <span class=\"paren1\">{<span class=\"code\">route, <span class=\"variable\">From</span>, <span class=\"variable\">To</span>, <span class=\"variable\">Packet</span></span>}</span>\r\n            <span class=\"symbol\">end</span>\r\n    <span class=\"symbol\">end</span>.</span></code></pre>\n\n<h3>谁来完成路由</h3>\n\n<p>我们可以产出，eJabberd的路由是非常复杂的，如果只让一个进程来处理相关操作，会形成非常大的瓶颈。因此，eJabberd选择让发送者的ejabberd_c2s进程来进行路由操作，利用mnesia的高并发性和Erlang的变量不变特性，达到高效路由。</p>\n\n<h3>后续</h3>\n\n<p>eJabberd的路由虽然是个非常简单的部分，但是在eJabberd中确实重中之重。它的设计不单单影响整个eJabberd的消息转发性能，同时影响着eJabberd的扩展性。为什么会影响扩展性，将在后续介绍s2s和外部服务<a href=\"https://xmpp.org/extensions/xep-0114.html\" >XEP-0114</a>中详细说明。</p>\n","id":85617388975588690165267734555024514788,"intro":"XMPP","published":false,"published_at":63734916125,"title":"eJabberd 的消息路由","topic_id":1},{"content":"<h2>FALLBACK.BUP生成schema.DAT时机</h2>\n\n<p>前面的文章提到了<a href=\"https://www.ttalk.im/topics/52\" >如何生成FALLBACK.BUP</a>，但没有提到FALLBACK.BUP是怎样生成schema.DAT文件的。想要知道FALLBACK.BUP是如何生成schema.DAT，就需要去观察Mnesia的启动流程和监控树。</p>\n\n<p>通过对代码的分析，可以非常清晰的看到，Mnesia的主要进程都被mnesia_kernel_sup这个监控者进程下\r\n``` Erlang\r\ninit([]) &rarr;\r\n    ProcLib = [mnesia_monitor, proc_lib],\r\n    Flags = {one_for_all, 0, timer:hours(24)}, % Trust the top supervisor\r\n    %% 最先启动的是mnesia_monitor\r\n    %% mnesia_monitor持有mnesia_gvar和mnesia_stats两张ets表\r\n    %% mnesia的全局变量全都保存在此处\r\n    Workers = [worker_spec(mnesia_monitor, timer:seconds(3), [gen_server]),\r\n        %% mnesia_subscr 创建订阅管理进程\r\n        %% 自动将mnesia_event加入到系统订阅表中\r\n           worker_spec(mnesia_subscr, timer:seconds(3), [gen_server]),\r\n        %% mnesia的锁管理进程\r\n           worker_spec(mnesia_locker, timer:seconds(3), ProcLib),\r\n         %% mnesia恢复进程\r\n           worker_spec(mnesia_recover, timer:minutes(3), [gen_server]),\r\n         %% mnesia事务进程\r\n           worker_spec(mnesia_tm, timer:seconds(30), ProcLib),\r\n         %% 检察点监控者进程\r\n           supervisor_spec(mnesia_checkpoint_sup),\r\n         %% snmp监控者进程\r\n           supervisor_spec(mnesia_snmp_sup),\r\n         %% mnesia主控进程\r\n           worker_spec(mnesia_controller, timer:seconds(3), [gen_server]),\r\n         %% mnesia数据加载进程\r\n           worker_spec(mnesia_late_loader, timer:seconds(3), ProcLib)\r\n          ],\r\n    {ok, {Flags, Workers}}.</p>\n\n<pre><code>通过逐个进程的检察，在mnesia_tm进程初始化的时候，会通过mnesia_bup:tm_fallback_start函数来使用FALLBACK.BUP进行数据恢复，在此过程中就会生成schema.DAT。\r\n\r\n## 恢复流程\r\n\r\n### tm_fallback_start函数\r\n在mnesia_bup:tm_fallback_start函数中，整个操作过程都是锁住schema表进行操作的，在这个过程中，本节点上所有的其它schema操作都会进行等待。同时，这个函数的整体操作都是在mnesia_tm进程内进行的。\r\n``` Erlang\r\n%执行回滚操作\r\ndo_fallback_start(true, false) -&gt;\r\n    verbose(\"Starting from fallback...~n\", []),\r\n    %拿到备份文件\r\n    BupFile = fallback_bup(),\r\n    Mod = mnesia_backup,\r\n    %创建一个ets，用来保存本地表\r\n    LocalTabs = ?ets_new_table(mnesia_local_tables, [set, public, {keypos, 2}]),\r\n    case catch iterate(Mod, fun restore_tables/4, BupFile, {start, LocalTabs}) of\r\n        {ok, _Res} -&gt;\r\n            %%  让dets关闭掉schema\r\n            catch dets:close(schema),\r\n            %% 设置临时的文件为schema.TMP\r\n            TmpSchema = mnesia_lib:tab2tmp(schema),\r\n            %% 设置数据文件为schema.DAT\r\n            DatSchema = mnesia_lib:tab2dat(schema),\r\n            %% 得到所有本地表\r\n              AllLT  = ?ets_match_object(LocalTabs, '_'),\r\n            %关闭ets\r\n              ?ets_delete_table(LocalTabs),\r\n            %% schema.TMP重命名为schema.DAT\r\n            case file:rename(TmpSchema, DatSchema) of\r\n                ok -&gt;\r\n                    %% 除了schema表外，全部进行swap操作\r\n                        [(LT#local_tab.swap)(LT#local_tab.name, LT) ||\r\n                             LT &lt;- AllLT, LT#local_tab.name =/= schema],\r\n                    file:delete(BupFile),\r\n                    ok;\r\n                {error, Reason} -&gt;\r\n                    file:delete(TmpSchema),\r\n                    {error, {\"Cannot start from fallback. Rename error.\", Reason}}\r\n            end;\r\n        {error, Reason} -&gt;\r\n            {error, {\"Cannot start from fallback\", Reason}};\r\n        {'EXIT', Reason} -&gt;\r\n            {error, {\"Cannot start from fallback\", Reason}}\r\n    end.</code></pre>\n\n<p>do_fallback_start函数会进行数据恢复的准备工作，它进行了下面这些工作\r\n- 建立mnesia_local_tables的ets表，用来保存restore_tables函数在恢复过程中，恢复出本节点内的表的信息\r\n- 生成schema.DAT文件\r\n- 生成本节点内所有表的.DAT文件，.DCL文件和.DCD文件</p>\n\n<h3>restore_tables函数</h3>\n\n<p>restore_tables函数依旧是依赖mnesia_bup的通用函数iterate，将FALLBACK.BUP文件中的schema数据和表项目数据读取出来，并逐条遍历。</p>\n\n<p>restore_tables函数会有几个状态，这几个状态分别是\r\n- {start, LocalTabs}，从FALLBACK.BUP中读取schema信息，根据表信息构建local_tab这个record，并保存到mnesia_local_tables中，为了可以在后面的恢复操作中使用\r\n- {new, LocalTabs} ，开始各表的数据恢复，会对FALLBACK中的数据项的record名和mnesia_local_tables的table名称进行比对，从而决定是恢复数据还是忽略\r\n- {not_local, LocalTabs, Tab}，如果在mnesia_local_tables查找不到对应的表名称的时候，就会进入此状态，这个过程中读取的数据会全部忽略掉\r\n- {local, LocalTabs, LT}，在mnesia_local_tables中查找到对应表明，进入此状态，进行数据恢复</p>\n\n<h3>init_dat_files函数</h3>\n\n<p>init_dat_files是restore_tables在构建mnesia_local_tables中项目的重要函数。</p>\n\n<p>它的主要工作有：\r\n- 根据schema提供的信息生成local_tab的record，包括schema表自身的信息\r\n- 创建除了schema表外所有的表的数据文件</p>\n\n<p>在仔细观察这个函数会发现，针对存储类型为disc_only_copies的表会建立一个dets，而对ram_copies和disc_copies类型存储的表只会建立.DCL日志存储和.DCD存储。存储方式的不同直接影响到了Mnesia如何读取数据和管理数据，在后面的文章将逐步分析相关内容。</p>\n\n<h2>总结</h2>\n\n<p>从整个过程中，可以看到Mnesia创建schema的过程后半段不仅仅可以创建一个schema.DAT文件，而且能创建包含数据的表。同时可以看出，Mnesia的Schema.DAT就是一个dets文件，完全可以简单的创建出来，但是这个过程确大费周章。当然这样做是有很大的原因的，这就需要考察Mnesia的备份机制和远程安装数据的机制了，在分析完Mnesia的启动和读写过程后，将会逐步对相关机制展开分析。</p>\n","id":157432808256327406235540237792770525466,"intro":"Erlang/Elixir","published":false,"published_at":63734916125,"title":"深入浅出 Mnesia－schema 创建 (2)","topic_id":1},{"content":"<h2>什么是Hook</h2>\n\n<h3>Hook的广义理解</h3>\n\n<ol>\n<li>Hook直译为“钩子”，钩子就是在事件传送到终点前截获并监控事件的传输或使用内存改写技术改写某个函数的入口点，并且能够在钩上事件时或替换函数后，处理一些自己特定的事件；</li>\n<li>Hook使它能够将自己的代码“融入”被勾住（Hook）的进程中，成为目标进程的一部分；</li>\n<li>Hook可以在不改变核心流程的情况，进行一些额外操作。</li>\n</ol>\n\n<h3>ejabberd的Hook</h3>\n\n<p>ejabberd中的Hook可以认为是eJabberd的插件系统，由于Erlang的语言的特性导致ejabberd不是很容易实现常见的插件系统。因此ejabberd设计了Hook系统，\nHook系统完全是基于ejabberd的核心流程和事件订阅发布机制。</p>\n\n<p>在ejabberd中，ejabberd预先定义了一系列的事件。在ejabberd中，每个模块都可以订阅这些事件，当这些事件发生时，订阅的模块就会被调用起来，进行按顺序的操作。</p>\n\n<h4>ejabberd的Hook的核心功能</h4>\n\n<ol>\n<li>管理ejabberd中的所有订阅者（Hook模块）；</li>\n<li>事件发生时，调用订阅者处理事件；</li>\n</ol>\n\n<h2>Hook系统如何工作</h2>\n\n<h3>Hook系统特性</h3>\n\n<ol>\n<li>分域名管理hook，ejabberd支持一个系统绑定多个域名，所以Hook系统可以为每个域名管理一组hook；</li>\n<li>按优先级调用，优先级值越小的hook，越先被调用;</li>\n<li>事件调用动作在事件发布者进程中执行；</li>\n<li>hook安全执行，hook不管引起何种异常，均不影响事件发布者进程；</li>\n</ol>\n\n<h3>Hook系统的启动</h3>\n\n<p>ejabberd的ejabberd_hooks进程是一个非常规范的gen_server进程，启动之后会创建一个名为hooks的命名ets表。</p>\n\n<h3>Hook的添加和删除</h3>\n\n<p>ejabberd的hook是具备优先级的，所以在添加hook的时候，会对将新的hook放入原有hook表中进行排序，请看下面的代码：</p>\n\n<pre><code><span class=\"code\"><span class=\"function\">handle_call</span><span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">add, <span class=\"variable\">Hook</span>, <span class=\"variable\">Host</span>, <span class=\"variable\">Module</span>, <span class=\"variable\">Function</span>, <span class=\"variable\">Seq</span></span>}</span>, <span class=\"variable\">_From</span>, <span class=\"variable\">State</span></span>)</span> -&gt;\n    <span class=\"variable\">Reply</span> = <span class=\"symbol\">case</span> ets:lookup<span class=\"paren1\">(<span class=\"code\">hooks, <span class=\"paren2\">{<span class=\"code\"><span class=\"variable\">Hook</span>, <span class=\"variable\">Host</span></span>}</span></span>)</span> <span class=\"symbol\">of</span>\n                <span class=\"paren1\">[<span class=\"code\"><span class=\"paren2\">{<span class=\"code\"><span class=\"variable\">_</span>, <span class=\"variable\">Ls</span></span>}</span></span>]</span> -&gt;\n                    <span class=\"variable\">El</span> = <span class=\"paren1\">{<span class=\"code\"><span class=\"variable\">Seq</span>, <span class=\"variable\">Module</span>, <span class=\"variable\">Function</span></span>}</span>,\n                    <span class=\"symbol\">case</span> lists:member<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">El</span>, <span class=\"variable\">Ls</span></span>)</span> <span class=\"symbol\">of</span>\n                        true -&gt;\n                            ok;\n                        false -&gt;\n                            <span class=\"variable\">NewLs</span> = lists:merge<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Ls</span>, <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">El</span></span>]</span></span>)</span>,\n                            ets:insert<span class=\"paren1\">(<span class=\"code\">hooks, <span class=\"paren2\">{<span class=\"code\"><span class=\"paren3\">{<span class=\"code\"><span class=\"variable\">Hook</span>, <span class=\"variable\">Host</span></span>}</span>, <span class=\"variable\">NewLs</span></span>}</span></span>)</span>,\n                            ok\n                    <span class=\"symbol\">end</span>;\n                <span class=\"paren1\">[<span class=\"code\"></span>]</span> -&gt;\n                    <span class=\"variable\">NewLs</span> = <span class=\"paren1\">[<span class=\"code\"><span class=\"paren2\">{<span class=\"code\"><span class=\"variable\">Seq</span>, <span class=\"variable\">Module</span>, <span class=\"variable\">Function</span></span>}</span></span>]</span>,\n                    ets:insert<span class=\"paren1\">(<span class=\"code\">hooks, <span class=\"paren2\">{<span class=\"code\"><span class=\"paren3\">{<span class=\"code\"><span class=\"variable\">Hook</span>, <span class=\"variable\">Host</span></span>}</span>, <span class=\"variable\">NewLs</span></span>}</span></span>)</span>,\n                    mongoose_metrics:create_generic_hook_metric<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Host</span>, <span class=\"variable\">Hook</span></span>)</span>,\n                    ok\n            <span class=\"symbol\">end</span>,\n    <span class=\"paren1\">{<span class=\"code\">reply, <span class=\"variable\">Reply</span>, <span class=\"variable\">State</span></span>}</span>;\n<span class=\"function\">handle_call</span><span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\">delete, <span class=\"variable\">Hook</span>, <span class=\"variable\">Host</span>, <span class=\"variable\">Module</span>, <span class=\"variable\">Function</span>, <span class=\"variable\">Seq</span></span>}</span>, <span class=\"variable\">_From</span>, <span class=\"variable\">State</span></span>)</span> -&gt;\n    <span class=\"variable\">Reply</span> = <span class=\"symbol\">case</span> ets:lookup<span class=\"paren1\">(<span class=\"code\">hooks, <span class=\"paren2\">{<span class=\"code\"><span class=\"variable\">Hook</span>, <span class=\"variable\">Host</span></span>}</span></span>)</span> <span class=\"symbol\">of</span>\n                <span class=\"paren1\">[<span class=\"code\"><span class=\"paren2\">{<span class=\"code\"><span class=\"variable\">_</span>, <span class=\"variable\">Ls</span></span>}</span></span>]</span> -&gt;\n                    <span class=\"variable\">NewLs</span> = lists:delete<span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">{<span class=\"code\"><span class=\"variable\">Seq</span>, <span class=\"variable\">Module</span>, <span class=\"variable\">Function</span></span>}</span>, <span class=\"variable\">Ls</span></span>)</span>,\n                    ets:insert<span class=\"paren1\">(<span class=\"code\">hooks, <span class=\"paren2\">{<span class=\"code\"><span class=\"paren3\">{<span class=\"code\"><span class=\"variable\">Hook</span>, <span class=\"variable\">Host</span></span>}</span>, <span class=\"variable\">NewLs</span></span>}</span></span>)</span>,\n                    ok;\n                <span class=\"paren1\">[<span class=\"code\"></span>]</span> -&gt;\n                    ok\n            <span class=\"symbol\">end</span>,\n    <span class=\"paren1\">{<span class=\"code\">reply, <span class=\"variable\">Reply</span>, <span class=\"variable\">State</span></span>}</span>;</span></code></pre>\n\n<p>由于ets表不具备事务性操作，ejabberd_hooks使用handle_call序列化这一添加和删除操作，保证操作顺序。\n在ets表中保存的是已经经过排序好的hook列表，这样可以大大减少每次执行hook所需要的时间。</p>\n\n<h3>Hook的触发</h3>\n\n<p>因为所有的ejabberd_c2s进程都会使用Hook系统，如果将调用都让ejabberd_hooks进程来操作， 会产生大量的延迟甚至会引起进程的崩溃。\n因此ejabberd的Hook系统，选择由事件的发布者进程来执行这些hook的调用的操作。请看下面的代码：</p>\n\n<pre><code><span class=\"code\"><span class=\"function\">run_fold</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Hook</span>, <span class=\"variable\">Val</span>, <span class=\"variable\">Args</span></span>)</span> -&gt;\n    run_fold<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Hook</span>, global, <span class=\"variable\">Val</span>, <span class=\"variable\">Args</span></span>)</span>.\n \n<span class=\"function\">run_fold</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Hook</span>, <span class=\"variable\">Host</span>, <span class=\"variable\">Val</span>, <span class=\"variable\">Args</span></span>)</span> -&gt;\n<span class=\"comment\">%% 针对Host取出相应的hook\n</span>    <span class=\"variable\">Res</span> = <span class=\"symbol\">case</span> ets:lookup<span class=\"paren1\">(<span class=\"code\">hooks, <span class=\"paren2\">{<span class=\"code\"><span class=\"variable\">Hook</span>, <span class=\"variable\">Host</span></span>}</span></span>)</span> <span class=\"symbol\">of</span>\n        <span class=\"paren1\">[<span class=\"code\"><span class=\"paren2\">{<span class=\"code\"><span class=\"variable\">_</span>, <span class=\"variable\">Ls</span></span>}</span></span>]</span> -&gt;\n            mongoose_metrics:increment_generic_hook_metric<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Host</span>, <span class=\"variable\">Hook</span></span>)</span>,\n            run_fold1<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Ls</span>, <span class=\"variable\">Hook</span>, <span class=\"variable\">Val</span>, <span class=\"variable\">Args</span></span>)</span>;\n        <span class=\"paren1\">[<span class=\"code\"></span>]</span> -&gt;\n            <span class=\"variable\">Val</span>\n    <span class=\"symbol\">end</span>,\n    record<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Hook</span>, <span class=\"variable\">Res</span></span>)</span>.</span></code></pre>\n\n<p>Hook系统将自身的ets直接暴露出来，让所有的事件发布者进程直接查询订阅相关事件的hook，之后使用一个内部函数run_fold1来进行安全执行。</p>\n\n<pre><code><span class=\"code\"><span class=\"function\">run_fold1</span><span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">[<span class=\"code\"></span>]</span>, <span class=\"variable\">_Hook</span>, <span class=\"variable\">Val</span>, <span class=\"variable\">_Args</span></span>)</span> -&gt;\n    <span class=\"variable\">Val</span>;\n<span class=\"function\">run_fold1</span><span class=\"paren1\">(<span class=\"code\"><span class=\"paren2\">[<span class=\"code\"><span class=\"paren3\">{<span class=\"code\"><span class=\"variable\">_Seq</span>, <span class=\"variable\">Module</span>, <span class=\"variable\">Function</span></span>}</span> | <span class=\"variable\">Ls</span></span>]</span>, <span class=\"variable\">Hook</span>, <span class=\"variable\">Val</span>, <span class=\"variable\">Args</span></span>)</span> -&gt;\n    <span class=\"variable\">Res</span> = hook_apply_function<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Module</span>, <span class=\"variable\">Function</span>, <span class=\"variable\">Hook</span>, <span class=\"variable\">Val</span>, <span class=\"variable\">Args</span></span>)</span>,\n    <span class=\"symbol\">case</span> <span class=\"variable\">Res</span> <span class=\"symbol\">of</span>\n        <span class=\"paren1\">{<span class=\"code\"><span class=\"atom\">'EXIT'</span>, <span class=\"variable\">Reason</span></span>}</span> -&gt;\n            <span class=\"macro\">?ERROR_MSG(</span><span class=\"string\">\"~p~nrunning hook: ~p\"</span>,\n                       <span class=\"paren1\">[<span class=\"code\"><span class=\"variable\">Reason</span>, <span class=\"paren2\">{<span class=\"code\"><span class=\"variable\">Hook</span>, <span class=\"variable\">Args</span></span>}</span></span>]</span>),\n            run_fold1<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Ls</span>, <span class=\"variable\">Hook</span>, <span class=\"variable\">Val</span>, <span class=\"variable\">Args</span></span>)</span>;\n        stop -&gt;\n            stopped;\n        <span class=\"paren1\">{<span class=\"code\">stop, <span class=\"variable\">NewVal</span></span>}</span> -&gt;\n            <span class=\"variable\">NewVal</span>;\n        <span class=\"variable\">NewVal</span> -&gt;\n            run_fold1<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Ls</span>, <span class=\"variable\">Hook</span>, <span class=\"variable\">NewVal</span>, <span class=\"variable\">Args</span></span>)</span>\n    <span class=\"symbol\">end</span>.\n<span class=\"comment\">%% 优先处理匿名函数\n</span><span class=\"function\">hook_apply_function</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">_Module</span>, <span class=\"variable\">Function</span>, <span class=\"variable\">_Hook</span>, <span class=\"variable\">Val</span>, <span class=\"variable\">Args</span></span>)</span> <span class=\"symbol\">when</span> <span class=\"symbol\">is_function</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Function</span></span>)</span> -&gt;\n    safely:apply<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Function</span>, <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">Val</span> | <span class=\"variable\">Args</span></span>]</span></span>)</span>;\n<span class=\"comment\">%% 处理模块到处的函数    \n</span><span class=\"function\">hook_apply_function</span><span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Module</span>, <span class=\"variable\">Function</span>, <span class=\"variable\">Hook</span>, <span class=\"variable\">Val</span>, <span class=\"variable\">Args</span></span>)</span> -&gt;\n    <span class=\"variable\">Result</span> = safely:apply<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Module</span>, <span class=\"variable\">Function</span>, <span class=\"paren2\">[<span class=\"code\"><span class=\"variable\">Val</span> | <span class=\"variable\">Args</span></span>]</span></span>)</span>,\n    record<span class=\"paren1\">(<span class=\"code\"><span class=\"variable\">Hook</span>, <span class=\"variable\">Module</span>, <span class=\"variable\">Function</span>, <span class=\"variable\">Result</span></span>)</span>.</span></code></pre>\n\n<p>safely:apply函数就是使用try catch包裹要执行的函数，捕获所有异常从而不影响事件发布进程的执行。</p>\n\n<p>在hook被执行的过程中，高优先级的hook可以通过返回stop或{stop, NewVal}来阻止低优先级的hook被执行。\n同时在hook链的实行过程中，高优先级的hook可以改变低优先级hook被执行时传入的初始值。在整个hook链结束执行的时候，\n会返回最后一个hook的执行结果给事件发布者，事件发布者可以根据这个值进行进一步的操作。</p>\n\n<h2>开发Hook的注意事项</h2>\n\n<ol>\n<li>hook操作不应该是一个无法退出的循环操作，因为这会影响到原有流程的执行，会引发不可预知的事情；</li>\n<li>hook函数尽量不要包含私有的上下文，虽然ejabberd的Hook系统中可以这样做，但是非常不推荐，因为Hook系统不会关联事件发布者到hook函数中；</li>\n<li>hook的函数尽量不要做耗时的超做，因为这会占用事件发布进程的时间片，影响消息的效率；</li>\n</ol>\n","id":192502678955491503939968974258888511941,"intro":"ejabberd是一款非常著名的XMPP服务器，它不但功能强大，还提供了Hook系统便于用户扩展。本文将为读者介绍，ejabberd中的Hook是什么，以及如何使用Hook。","published":true,"published_at":63734916122,"title":"ejabberd的Hook系统","topic_id":1}],"topic":[{"id":1,"intro":"全站点没有进行分类的文章聚集地，包含了各个方面的文章","title":"杂谈"},{"id":3,"intro":"对OCaml的你用笔记，对知名开源项目代码分析，编译原理","title":"OCaml"},{"id":2,"intro":"对Erlang本身的研究，教程和对行业内使用Erlang开发的知名项目进行代码分析","title":"Erlang"}]}